
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>16장 비지도학습과 주성분 분석 &#8212; 데이터과학의 첫걸음</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b76e3c8a" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/16_비지도학습과_주성분_분석';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="17장 생존분석" href="17_%EC%83%9D%EC%A1%B4%EB%B6%84%EC%84%9D.html" />
    <link rel="prev" title="15장 딥러닝 입문" href="15_%EB%94%A5%EB%9F%AC%EB%8B%9D_%EC%9E%85%EB%AC%B8.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="00_%EC%84%9C%EB%AC%B8.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="데이터과학의 첫걸음 - Home"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="데이터과학의 첫걸음 - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="00_%EC%84%9C%EB%AC%B8.html">
                    데이터과학의 첫걸음: 시작하며
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="01_%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0.html">1장 파이썬 시작하기</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EC%BD%94%EB%94%A9_%EA%B8%B0%EC%B4%88.html">2장 파이썬 코딩 기초</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_%EC%9D%80%ED%96%89_%ED%85%94%EB%A0%88%EB%A7%88%EC%BC%80%ED%8C%85_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B6%84%EC%84%9D.html">3장 은행 텔레마케팅 데이터 분석</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_%EC%A0%84%EC%9E%90%EC%83%81%EA%B1%B0%EB%9E%98_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B6%84%EC%84%9D.html">4장 전자상거래 데이터 분석</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_%ED%86%B5%EA%B3%84%EC%A0%81_%ED%95%99%EC%8A%B5.html">5장 통계적 학습</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_%EC%84%A0%ED%98%95_%ED%9A%8C%EA%B7%80.html">6장 선형 회귀</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_%EB%A1%9C%EC%A7%80%EC%8A%A4%ED%8B%B1_%ED%9A%8C%EA%B7%80%EB%A5%BC_%EC%9D%B4%EC%9A%A9%ED%95%9C_%EB%B6%84%EB%A5%98.html">7장 로지스틱 회귀를 이용한 분류</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_KNN%EC%9D%84_%EC%9D%B4%EC%9A%A9%ED%95%9C_%EB%B6%84%EB%A5%98.html">8장 KNN 분류</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_%EB%82%98%EC%9D%B4%EB%B8%8C_%EB%B2%A0%EC%9D%B4%EC%A6%88_%EB%B6%84%EB%A5%98.html">9장 나이브 베이즈 분류</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_%EB%B3%80%EC%88%98%EC%84%A0%ED%83%9D_%EB%B0%8F_%EC%A0%95%EA%B7%9C%ED%99%94.html">10장 변수선택 및 정규화</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C.html">11장 추천 시스템</a></li>
<li class="toctree-l1"><a class="reference internal" href="12_%EA%B2%B0%EC%A0%95_%ED%8A%B8%EB%A6%AC_%EB%A7%8C%EB%93%A4%EA%B8%B0.html">12장 결정 트리 만들기</a></li>
<li class="toctree-l1"><a class="reference internal" href="13_%ED%8A%B8%EB%A6%AC_%EA%B8%B0%EB%B0%98_%EB%AA%A8%ED%98%95.html">13장 트리 기반 모형</a></li>
<li class="toctree-l1"><a class="reference internal" href="14_%EC%84%9C%ED%8F%AC%ED%8A%B8_%EB%B2%A1%ED%84%B0_%EB%A8%B8%EC%8B%A0.html">14장 서포트 벡터 머신</a></li>
<li class="toctree-l1"><a class="reference internal" href="15_%EB%94%A5%EB%9F%AC%EB%8B%9D_%EC%9E%85%EB%AC%B8.html">15장 딥러닝 입문</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">16장 비지도학습과 주성분 분석</a></li>
<li class="toctree-l1"><a class="reference internal" href="17_%EC%83%9D%EC%A1%B4%EB%B6%84%EC%84%9D.html">17장 생존분석</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/pilsunchoi/book1" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/pilsunchoi/book1/issues/new?title=Issue%20on%20page%20%2Fnotebooks/16_비지도학습과_주성분_분석.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/notebooks/16_비지도학습과_주성분_분석.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>16장 비지도학습과 주성분 분석</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">16.1 개요</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">16.2 주성분의 개념</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#chatgpt-q-a">ChatGPT Q&amp;A</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">16.3 주성분 도출</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">16.4 주성분 계산 단계별 설명</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-1">STEP 1:  표준화</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-2">STEP 2: 공분산 행렬</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-3">STEP 3: 공분산 행렬의 고유벡터와 고유값으로 주성분 식별</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-4">STEP 4: 주성분 선택</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-5">STEP 5: 주성분 축을 따라 데이터를 변환</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">16.5 파이썬으로 주성분 계산하기</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#usarrest">USArrest 데이터세트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iris">IRIS 데이터세트</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nci60">16.6 NCI60 데이터: 시각화</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">유전자 데이터 분석</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">주성분 분석</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">16.7 손글씨 데이터: 노이즈 필터링</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">데이터세트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pca">노이즈 필터링 PCA</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mnist">16.8 MNIST 데이터: 주성분 회귀</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">주성분 회귀</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#keras">Keras 및 데이터세트 불러들이기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">다항 로지스틱 회귀</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">다항 로지스틱 주성분 회귀</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">참고: PCA의 한계</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>16장 비지도학습과 주성분 분석<a class="headerlink" href="#id1" title="Link to this heading">#</a></h1>
<p>자료 출처: <a class="reference external" href="https://www.statlearning.com/">ISLP (An Introduction to Statistical Learning with Applications in Python)</a></p>
<section id="id2">
<h2>16.1 개요<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<p>이 책의 대부분은 회귀 및 분류와 같은 <strong>지도학습</strong>(supervised learning)에 관한 것이다. 지도학습은 일반적으로 예측변수 또는 특성(feature)이 <span class="math notranslate nohighlight">\(p\)</span>개(즉 <span class="math notranslate nohighlight">\(X_1,X_2,...,X_p\)</span>)가 있고, 반응변수 <span class="math notranslate nohighlight">\(Y\)</span>가 있는 상황에서 <span class="math notranslate nohighlight">\(X_1,X_2,...,X_p\)</span>를 사용하여 <span class="math notranslate nohighlight">\(Y\)</span>를 예측하는 것을 목표로 한다.</p>
<p>이 장에서는 이러한 지도학습 대신 반응변수는 없고 <span class="math notranslate nohighlight">\(X_1,X_2,...,X_p\)</span>의 특성 세트만 있는 <strong>비지도학습</strong>(unsupervised learning)에 초점을 맞춘다. 비지도학습은 관련된 반응변수 <span class="math notranslate nohighlight">\(Y\)</span>가 없기 때문에 예측에는 관심이 없다. 그 대신 비지도학습의 목표는 <span class="math notranslate nohighlight">\(X_1,X_2,...,X_p\)</span>의 측정값에 대해 어떤 흥미로운 점들을 발견하는 것이다. 예를 들어, 데이터를 시각화하는 좋은 방법이 있는지, 그리고 변수 또는 관측 사이에 어떤 부분그룹들(subgroups)을 찾을 수 있는지 등이다. 비지도학습은 이와 같은 질문에 답하기 위한 다양한 기법을 말한다.</p>
<p>지금까지 살펴본 지도학습은 잘 알려진 영역이다. 예를 들어, 데이터세트에서 이항(binary) 결과를 예측(즉 분류)하는 것이 목표라면, 여러 가지 잘 개발된 도구(예: 로지스틱 회귀, 분류 트리, 서포트 벡터 머신 등)를 사용할 수 있다. 또한 분류 성과를 평가하는 방법에 있어서도 교차검증(cross-validation)이나 검증 세트를 이용하는 등 명확한 방법들이 있다.</p>
<p>이에 반해, 비지도학습은 훨씬 더 도전적인 분야이다. 반응을 예측하는 것과 같은 어떤 정해진 목표가 없으며, 접근이 보다 주관적인 경향이 있다. 비지도학습은 종종 <strong>탐색적 데이터 분석</strong>(exploratory data analysis)의 일부로 수행된다. 또한 교차검증이나 검증 세트 등 분석 결과를 검증하기 위해 보편적으로 허용되는 메커니즘이 없기 때문에 비지도학습 기법에서 얻은 결과를 평가하기 어렵다. 이러한 차이가 발생하는 이유는 간단하다. 지도학습 기법을 사용하여 예측 모델을 피팅하면, 모델 피팅에 사용되지 않은 관측을 이용하여 모델의 예측 성과를 쉽게 평가할 수 있다. 그러나 비지도학습에서는 올바른 답을 알지 못하기 때문에 우리의 작업 성과를 확인할 방법이 없다. 한마디로 비지도(unsupervised)가 어려움을 낳는 원인이다.</p>
<p>비지도학습 기법은 여러 분야에서 중요성이 커지고 있다. 가령 어떤 <strong>암 연구자</strong>가 유방암 환자 100명의 유전자 발현(gene expression) 데이터를 분석한다. 암에 대해 더 잘 알기 위해 유방암 샘플 또는 유전자와 같은 것에서 비슷한 성질을 지닌 부분그룹(subgroup)을 찾으려는 것이 분석의 목표라면 이런 것이 비지도학습의 예이다. 다른 예로 <strong>온라인 쇼핑 사이트</strong>는 브라우징 및 구매 이력이 유사한 사용자 그룹을 찾아내고, 각 그룹 내에서 사용자들이 특히 관심을 갖는 아이템을 식별하는 것이 중요하다. 이를 통해 어떤 사용자에게 다른 유사한 사용자들의 구매 이력을 기반으로 이들이 특히 관심을 가질 가능성이 있는 아이템을 우선적으로 보여줄 수 있다. 또 다른 예로 <strong>검색 엔진</strong>은 유사한 검색 패턴을 지닌 다른 개인의 클릭 기록을 기반으로 특정 개인에게 제시할 검색 결과를 선택할 수 있다. 이러한 통계적 학습 과제들은 비지도학습 기법을 통해 수행된다.</p>
<p>이 장에서는 대규모 변수 집합에서 저차원 변수 집합을 도출하는 데 널리 사용되는 <strong>주성분 분석</strong>(<strong>PCA</strong>: principal components analysis)에 대해 살펴본다. PCA는 입력변수의 차원을 축소시켜 회귀분석을 수행하는 지도학습에서도 사용된다. 소위 <strong>주성분 회귀</strong>(principal components regression) 분석이다. 하지만 이 장에서는 비지도 데이터 탐색(unsupervised data exploration)을 위한 도구로서의 PCA에 주로 초점을 맞춘다. 즉 데이터의 차원을 축소시켜 데이터를 시각화한다든지 또는 클러스터링(clustring), 노이즈 필터링(noise filtering), 특성 추출(feature extraction) 등을 위한 PCA이다.</p>
</section>
<section id="id3">
<h2>16.2 주성분의 개념<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p><strong>주성분 분석</strong>(PCA: principal component analysis)을 단순화시켜 설명하면 다음과 같다. 어떤 데이터세트가 있을 때, 우리는 해당 데이터를 가장 잘 대표하는 소위 <strong>주성분</strong>(principal components)을 찾아낼 수 있다. 특성 <span class="math notranslate nohighlight">\(X_1,X_2,...,X_p\)</span>가 있고, 이들에 대해 <span class="math notranslate nohighlight">\(n\)</span>개 관측이 있을 때, 우리는 최대 <span class="math notranslate nohighlight">\({\rm min}(n − 1, p)\)</span>개 주성분을 찾을 수 있는데, 가령 원래 데이터세트의 변수 개수가 100개이면, (관측 개수가 변수 개수보다 많다고 했을 때) 주성분을 100개까지 찾을 수 있다. 이때 첫 번째 주성분이 해당 데이터세트의 특징을 가장 잘 대표하는 가장 중요한 주성분이고, 두 번째 주성분이 그 다음으로 중요한 주성분이고, 이런 식으로 100번째 주성분까지 도출할 수 있다. 이렇게 100개의 주성분이 도출되면, 결국 이들 100개의 주성분 전체는 원래 데이터세트의 모든 특징을 하나도 빠짐없이 담고 있게 된다.</p>
<p>그런데 여기에서 핵심적인 부분은 첫 번째 주성분이 가장 중요하고, 마지막 100번째 주성분이 가장 덜 중요하다는 점이다. 바로 이 점 때문에 주성분 분석이 변수의 차원축소 도구로 사용될 수 있다. 이것은 마치 원래 데이터세트의 100개 변수를 용광로 같은 곳에 집어넣어 거기에서 주성분이라는 이름의 또 다른 100개 변수를 뽑아내는 작업에 비유할 수 있다. 그런데 만약 그렇게 해서 뽑아낸 처음 10개의 주성분에 원래 데이터세트가 갖고 있는 대부분의 특징 또는 정보가 들어있다면, 원래 100개의 변수 대신 (약간의 정보 손실을 감수하면서) 10개의 주성분만을 사용함으로써 변수의 개수를 대폭 줄일 수 있는 것이다.</p>
<p>가장 간단한 예로서 변수가 2개만 있는 경우를 생각해보자. 100개 도시에 제품을 파는 어떤 회사가 있는데, 도시별로 광고지출이 다르다. 우리에게 주어진 데이터세트는 각 도시별 인구규모(<span class="math notranslate nohighlight">\(pop\)</span>: 만명)와 해당 회사의 광고지출(<span class="math notranslate nohighlight">\(ad\)</span>: 천달러)에 관한 것이다. 이 경우 <span class="math notranslate nohighlight">\(p=2\)</span>이고, <span class="math notranslate nohighlight">\(n=100\)</span>이다.</p>
<p>아래 그림 16.1은 이들 2개 변수간의 관계를 산점도로 그린 것이다. 여기에서 주성분 분석이 제공하는 것은 데이터세트에 가장 잘 피팅하는 <strong>주성분 직선</strong>(line) 또는 방향(direction)이다. 이것을 간단히 <strong>주축</strong>(principal axes)이라고도 한다. 그림에서 우상향의 녹색 실선으로 표시된 것이 바로 주어진 데이터의 <strong>첫 번째 주성분 직선</strong>이다. 눈으로 보기에도 녹색선이 주어진 데이터 포인트들을 가장 잘 대표하는 직선으로 여겨진다. 이 첫 번째 주성분 직선은 각 점과 직선 사이의 수직 거리의 제곱합을 최소화하는 방법으로 찾는다.</p>
<p><strong>그림 16.1.</strong> 100개의 도시에 대한 인구규모(<span class="math notranslate nohighlight">\(pop\)</span>) 및 광고지출(<span class="math notranslate nohighlight">\(ad\)</span>)이 보라색 동그라미 점으로 표시돼있다. 녹색 실선은 첫 번째 주성분 직선을 나타내고, 파란색 점선은 두 번째 주성분 직선을 나타낸다.</p>
<p><img alt="광고 데이터 주성분 직선" src="https://raw.githubusercontent.com/pilsunchoi/images/main/16-1.png" /></p>
<ul class="simple">
<li><p>그림 출처: ISLP, FIGURE 6.14</p></li>
</ul>
<p>위 예에서는 변수가 2개만 있기 때문에 주성분 직선은 2개의 숫자만으로 표현할 수 있다. 즉 (0.839, 0.544)이다. 여기에서 첫 번째 숫자 0.839는 <span class="math notranslate nohighlight">\(pop\)</span> 변수에 대한 숫자이고, 0.544는 <span class="math notranslate nohighlight">\(ad\)</span> 변수에 대한 숫자이다. 한 마디로 이 숫자들은 그림에서 녹색선의 기울기를 알려준다. 즉 가로축으로 0.839만큼 간 다음, 거기에서 세로축으로 0.544만큼 가는 기울기를 갖는다는 것이다. 그것이 첫 번째 주성분 직선이다. 아래에서 다시 설명이 나오지만, 주성분 직선을 (0.839, 0.544)와 같이 표현할 때, 이것을 주성분의 <strong>부하량</strong>(loading) 벡터, 또는 <strong>고유벡터</strong>라고 칭한다.</p>
<p>그림 16.1에서 녹색선으로 표현된 첫 번째 주성분의 부하량 벡터가 (0.839, 0.544)으로 주어지는 경우, 이를 이용한 다음과 같은 변수를 생각해보자.</p>
<div class="math notranslate nohighlight">
\[
Z_{1} = 0.839\cdot(pop-\overline{pop}) + 0.544 \cdot (ad-\overline{ad}) \tag{16.1}
\]</div>
<p>이 식에서 <span class="math notranslate nohighlight">\(\overline{pop}\)</span>는 <span class="math notranslate nohighlight">\(pop\)</span> 평균값이고, <span class="math notranslate nohighlight">\(\overline{ad}\)</span>는 <span class="math notranslate nohighlight">\(ad\)</span> 평균값이다. 위 식으로 표현된 <span class="math notranslate nohighlight">\(Z_{1}\)</span>을 <strong>첫 번째 주성분 점수</strong>(principal component score)라고 부른다. 첫 번째 주성분 <strong>변수</strong>라고 부를 수도 있다. 이로써 우리는 PCA를 통해 변수가 2개 있는 2차원의 데이터세트로부터 그 특징을 가장 잘 대표하는 첫 번째 주성분 변수 <span class="math notranslate nohighlight">\(Z_{1}\)</span>을 뽑아낸 것이다. 만약 원래의 데이터세트 대신 첫 번째 주성분 변수만 사용한다면, 입력변수의 차원을 2차원에서 1차원으로 축소한 것이 된다. 결국 <span class="math notranslate nohighlight">\(pop\)</span>와 <span class="math notranslate nohighlight">\(ad\)</span> 두 변수의 <strong>선형결합</strong>(linear combination)에 의해 이들의 특징을 가장 잘 포착하는 <span class="math notranslate nohighlight">\(Z_{1}\)</span>이라는 새로운 변수(즉 첫 번째 주성분 변수)를 도출한 것이다.</p>
<p>위 예에서 데이터세트의 관측 개수가 100개(<span class="math notranslate nohighlight">\(n = 100\)</span>)이므로 <span class="math notranslate nohighlight">\(pop\)</span>와 <span class="math notranslate nohighlight">\(ad\)</span>는 각각 길이가 100인 벡터이고, 식 16.1의 <span class="math notranslate nohighlight">\(Z_1\)</span> 역시 길이가 100인 벡터이다. <span class="math notranslate nohighlight">\(Z_1\)</span>의 개별 원소인 <span class="math notranslate nohighlight">\(z_{11},...,z_{n1}\)</span>, 즉 주성분 점수를 식으로 표현하면 다음과 같다.</p>
<div class="math notranslate nohighlight">
\[
z_{i1} = 0.839 \cdot (pop_i-\overline{pop}) + 0.544 \cdot (ad_i-\overline{ad}) \tag{16.2}
\]</div>
<p>아래 그림 16.2의 왼쪽 패널에서 녹색선 위의 x 표시는 첫 번째 주성분 직선에 대한 각 데이터 포인트의 수직 <strong>투영</strong>(projection, 또는 정사영)을 나타낸다. 앞에서도 언급했지만, 첫 번째 주성분 직선은 각 데이터 포인트와 직선 사이의 수직 거리의 제곱합을 최소화하는 방법으로 찾는다. 즉 첫 번째 주성분은 원래의 데이터 포인트와 그것의 투영된 점들이 <strong>최대한 가깝도록</strong> 선택된다. 그래야만 주성분이 데이터 포인트의 특징을 가장 잘 대표할 수 있기 때문이다.</p>
<p>한편, 그림 16.2의 오른쪽 패널은 첫 번째 주성분 방향(즉 녹색선)을 수평으로 만들기 위해 왼쪽 패널을 45도 정도 오른쪽으로 회전시킨 것이다. 이 오른쪽 패널에서 녹색선 상에 표시된 x 표시의 가로축 값이 바로 식 16.2의 <span class="math notranslate nohighlight">\(z_{i1}\)</span>, 즉 <span class="math notranslate nohighlight">\(i\)</span>번째 관측에 대한 첫 번째 주성분 점수이다. 예를 들어, 그림에서 왼쪽 패널의 왼쪽 하단 모서리에 있는 점은 식 16.2에 따르면 <span class="math notranslate nohighlight">\(z_{i1} = −26.1\)</span>으로서 큰 음의 주성분 점수를 갖는다. 이 값이 그림에서 무엇에 해당하냐면, 해당 데이터 포인트를 녹색선에 투영시킨 x 표시에서 <span class="math notranslate nohighlight">\(pop\)</span> 및 <span class="math notranslate nohighlight">\(ad\)</span>의 평균값을 나타내는 중앙의 파란색 원까지의 거리이다.</p>
<p><strong>그림 16.2.</strong> 그림을 간단히 하기 위해 광고 데이터세트 전체 관측이 아니라 일부만을 표시해 놓았다. 중앙 부분에 표시된 파란색 원은 <span class="math notranslate nohighlight">\(pop\)</span> 및 <span class="math notranslate nohighlight">\(ad\)</span>의 평균값이다. 왼쪽: 첫 번째 주성분 직선이 녹색으로 표시돼 있다. 녹색선이 첫 번째 주성분 직선이라는 것은 데이터 포인트들을 녹색선에 투영시켰을 때 데이터의 변동성이 가장 커진다는 것을 의미한다. 녹색선은 모든 <span class="math notranslate nohighlight">\(n\)</span>개 데이터 포인트에 가장 가까운 직선, 즉 데이터를 가장 잘 대표하는 직선이기도 하다. 오른쪽: 첫 번째 주성분 방향이 가로축과 일치하도록 왼쪽 패널을 45도 정도 오른쪽으로 회전시켜 놓았다.</p>
<p><img alt="광고 데이터 주성분" src="https://raw.githubusercontent.com/pilsunchoi/images/main/16-2.png" /></p>
<ul class="simple">
<li><p>그림 출처: ISLP, FIGURE 6.15</p></li>
</ul>
<p>위 식 16.2에서 <span class="math notranslate nohighlight">\(pop\)</span>과 <span class="math notranslate nohighlight">\(ad\)</span>의 모든 가능한 선형결합, 즉 <span class="math notranslate nohighlight">\(\phi_{11}\cdot pop + \phi_{21}\cdot ad\)</span>에서 <span class="math notranslate nohighlight">\(\phi_{11}=0.839\)</span> 및 <span class="math notranslate nohighlight">\(\phi_{21}=0.544\)</span>일 때, 주성분 점수의 변동성(분산)이 가장 크다. 즉 <span class="math notranslate nohighlight">\({\rm Var} \left( \phi_{11} \cdot (pop-\overline{pop}) + \phi_{21} \cdot (ad-\overline{ad}) \right)\)</span>가 최대가 된다. 단, 이때 <span class="math notranslate nohighlight">\(\phi_{11}^2 + \phi_{21}^2 = 1\)</span>의 조건이 부과되는데, 이 조건을 만족하는 모든 선형결합 중 위 결과가 주성분 점수의 변동성을 가장 크게 만든다는 것이다. 이처럼 변동성을 가장 크게 만드는 선형결합을 찾는 이유는 그래야만 개별 변수들의 특징(변동성)을 가장 잘 포착할 수 있으며, 그것을 통해 데이터 포인트들을 가장 잘 대표하는 성분을 찾을 수 있기 때문이다. 여기에서 <span class="math notranslate nohighlight">\(\phi_{11}^2 + \phi_{21}^2 = 1\)</span>의 조건을 부과하는 이유는 그렇게 하지 않으면 <span class="math notranslate nohighlight">\(\phi_{11}\)</span>과 <span class="math notranslate nohighlight">\(\phi_{21}\)</span>의 값을 무한히 키우는 것만으로도 선형결합의 분산을 무한히 키울 수 있기 때문이다.</p>
<p>첫 번째 주성분 점수, 즉 <span class="math notranslate nohighlight">\(z_{i1}\)</span>은 <span class="math notranslate nohighlight">\(pop\)</span> 및 <span class="math notranslate nohighlight">\(ad\)</span> 두 개의 변수값을 <strong>하나의 숫자로 요약한 것</strong>으로 생각할 수 있다. 이때 주성분 분석에 의해 도출한 하나의 숫자가 두 개 변수의 특징을 가급적 잘 포착할 수 있기 위해서는 그림 16.1에서 보았듯이 <span class="math notranslate nohighlight">\(pop\)</span>과 <span class="math notranslate nohighlight">\(ad\)</span>의 관계를 가장 잘 대표할 수 있도록 직선(즉 녹색선)을 도출해야 한다. 주성분이 실제로 그런 역할을 잘 하는지 알아보기 위해 아래 그림 16.3은 첫 번째 주성분 점수인 <span class="math notranslate nohighlight">\(z_{i1}\)</span>을 가로축으로 하고 <span class="math notranslate nohighlight">\(pop\)</span> 및 <span class="math notranslate nohighlight">\(ad\)</span>를 세로축으로 하여 둘 사이의 관계를 표시한 것이다. 그림에서 알 수 있듯이 첫 번째 주성분 변수와 <span class="math notranslate nohighlight">\(pop\)</span>, 그리고 첫 번째 주성분 변수와 <span class="math notranslate nohighlight">\(ad\)</span>가 모두 강한 관계를 보인다. 달리 표현하면, 첫 번째 주성분은 <span class="math notranslate nohighlight">\(pop\)</span> 및 <span class="math notranslate nohighlight">\(ad\)</span>의 두 가지 특성(feature)에 포함된 정보를 (주성분 하나만으로도) 아주 잘 보존하고 있는 것이다.</p>
<p><strong>그림 16.3.</strong> <span class="math notranslate nohighlight">\(pop\)</span> 및 <span class="math notranslate nohighlight">\(ad\)</span>와 첫 번째 주성분 점수 <span class="math notranslate nohighlight">\(z_{i1}\)</span>과의 관계: 상당히 관계가 강한 편이다.</p>
<p><img alt="관계가 강함" src="https://raw.githubusercontent.com/pilsunchoi/images/main/16-3.png" /></p>
<ul class="simple">
<li><p>그림 출처: ISLP, FIGURE 6.16</p></li>
</ul>
<p>지금까지 우리는 첫 번째 주성분만 다뤘다. 그런데 변수가 <span class="math notranslate nohighlight">\(p\)</span>개이면, 일반적으로 최대 <span class="math notranslate nohighlight">\(p\)</span>개의 주성분을 뽑아낼 수 있다. 우리 예에서는 변수가 2개이므로 위에서 설명한 첫 번째 주성분 외에 또 하나의 주성분을 찾을 수 있다. 두 번째 주성분 변수 <span class="math notranslate nohighlight">\(Z_2\)</span>는 <span class="math notranslate nohighlight">\(Z_1\)</span>과 선형의 상관관계가 없어야 한다는 제약 조건이 추가되는 것을 제외하면 첫 번째 주성분을 찾을 때와 동일한 방식이 적용된다.</p>
<p>동일한 방식으로 얻은 <strong>두 번째 주성분 직선</strong>이 위 첫 번째 그림 16.1에 파란색 점선으로 표시돼 있다. <span class="math notranslate nohighlight">\(Z_1\)</span>과 <span class="math notranslate nohighlight">\(Z_2\)</span>의 상관관계가 0이라는 조건은 두 번째 주성분 직선이 첫 번째 주성분 직선에 <strong>직교</strong>(perpendicular 또는 orthogonal)해야 한다는 조건과 동일하다. 그렇게 해서 찾은 두 번째 주성분 변수는 다음과 같다.</p>
<div class="math notranslate nohighlight">
\[
Z_{2} = 0.544 \cdot (pop-\overline{pop}) + 0.839 \cdot (ad-\overline{ad})
\]</div>
<p>우리 데이터세트에는 변수가 2개이므로 이상에서 설명한 두 개의 주성분에 <span class="math notranslate nohighlight">\(pop\)</span> 및 <span class="math notranslate nohighlight">\(ad\)</span>에 있는 모든 정보가 포함된다. 그런데 두 개의 주성분끼리 비교하면 첫 번째 주성분에 훨씬 많은 정보가 포함돼 있다. 그것을 잘 보여주는 것이 위 그림 16.2의 오른쪽 패널이다. 여기에서 녹색선 상의 x 표시를 가로축으로 읽은 것이 첫 번째 주성분 점수 <span class="math notranslate nohighlight">\(z_{i1}\)</span>이고, 각 데이터 포인트와 녹색선과의 거리(검은색 점선으로 표시)가 두 번째 주성분 점수 <span class="math notranslate nohighlight">\(z_{i2}\)</span>이다. 그림에서 보듯이 첫 번째 주성분 점수의 변동성(분산)이 훨씬 큰 것을 알 수 있는데, 이것이 바로 첫 번째 주성분이 훨씬 많은 정보를 포착한다는 것을 의미한다.</p>
<p>아래 그림 16.4는 두 번째 주성분 점수인 <span class="math notranslate nohighlight">\(z_{21}\)</span>을 가로축으로 하고 <span class="math notranslate nohighlight">\(pop\)</span> 및 <span class="math notranslate nohighlight">\(ad\)</span>를 세로축으로 하여 둘 사이의 관계를 표시한 것이다. 그림에서 알 수 있듯이 두 번째 주성분과 <span class="math notranslate nohighlight">\(pop\)</span> 및 <span class="math notranslate nohighlight">\(ad\)</span>의 관계는 상당히 약한 편이다.</p>
<p><strong>그림 16.4.</strong> <span class="math notranslate nohighlight">\(pop\)</span> 및 <span class="math notranslate nohighlight">\(ad\)</span>와 두 번째 주성분 점수 <span class="math notranslate nohighlight">\(z_{i2}\)</span>와의 관계: 상당히 관계가 약한 편이다.</p>
<p><img alt="관계가 약함" src="https://raw.githubusercontent.com/pilsunchoi/images/main/16-4.png" /></p>
<ul class="simple">
<li><p>그림 출처: ISLP, FIGURE 6.17</p></li>
</ul>
<section id="chatgpt-q-a">
<h3>ChatGPT Q&amp;A<a class="headerlink" href="#chatgpt-q-a" title="Link to this heading">#</a></h3>
<blockquote>
<div><p><strong>어떤 주어진 데이터세트에서 도출한 첫 번째 주성분이 무슨 의미를 지니는지 쉽고 간단히 설명해줘. 또한 첫 번째 주성분과 두 번째 주성분은 어떤 관계인지에 대해서도.</strong></p>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p>주성분 분석(PCA)에서 첫 번째 주성분은 주어진 데이터세트의 변동성(variability)을 가장 많이 설명하는 방향입니다. 다시 말해, 데이터가 이 방향으로 가장 넓게 퍼져 있으며, 이를 통해 데이터 세트 내의 가장 중요한 패턴이나 구조를 포착할 수 있습니다. 첫 번째 주성분은 데이터 세트의 주요 차이나 변동을 잡아내는 데 사용됩니다.</p>
<p>두 번째 주성분은 첫 번째 주성분과 완전히 직교(orthogonal)하며, 첫 번째 주성분으로 설명되지 않는 다음으로 큰 변동성을 설명합니다. 이는 두 번째 주성분이 첫 번째 주성분과는 전혀 다른 차원의 정보를 제공한다는 것을 의미합니다. 두 번째 주성분은 첫 번째 주성분에 수직인 방향으로 데이터의 분산이 최대가 되는 방향입니다.</p>
<p>간단히 말해서, 첫 번째 주성분은 데이터에서 가장 많은 정보를 담고 있는 방향을 나타내고, 두 번째 주성분은 첫 번째 주성분에 직각을 이루면서 남은 정보 중 가장 많은 정보를 담고 있는 방향을 나타냅니다. 이렇게 PCA는 데이터 세트를 구성하는 여러 변수들 사이의 상관관계를 이해하고, 이를 몇 개의 주성분으로 요약하여 데이터의 구조를 간략화하는 데 유용합니다.</p>
</div></blockquote>
</section>
</section>
<section id="id4">
<h2>16.3 주성분 도출<a class="headerlink" href="#id4" title="Link to this heading">#</a></h2>
<p>데이터세트가 <span class="math notranslate nohighlight">\(p\)</span>개의 변수 <span class="math notranslate nohighlight">\(X_1,X_2, . . . ,X_p\)</span>에 대해 <span class="math notranslate nohighlight">\(n\)</span>개의 관측이 있다고 하자. 가령 탐색적 데이터 분석의 일환으로 이 데이터세트를 시각화하려고 한다. 그런데 변수가 3개만 넘어도 이를 시각화할 수 없다. 사실 3차원 그림도 입체적으로 그려야 하기 때문에 시각적 표현이 번거롭다. 그래서 보통 우리는 데이터를 2차원 산점도(scatterplot)로 시각화를 수행한다. 산점도에는 두 개의 변수에 대해 <span class="math notranslate nohighlight">\(n\)</span>개의 관측값이 표시된다. 따라서 변수가 <span class="math notranslate nohighlight">\(p\)</span>개일 때, 두 개씩의 모든 변수 조합을 고려하려면, 산점도가 <span class="math notranslate nohighlight">\(\binom{p}{2}=p(p-1)/2\)</span>개가 필요하다. 예를 들어, <span class="math notranslate nohighlight">\(p = 100\)</span>인 경우 산점도 개수는 총 4,950개나 된다. <span class="math notranslate nohighlight">\(p\)</span>가 크면 모든 것을 자세히 따져 보는 것은 사실상 불가능할 것이다. 게다가, 각 산점도들은 데이터세트에 존재하는 전체 정보의 작은 부분만을 포함하고 있기 때문에 그들 중 일부는 그다지 유익하지 않을 가능성이 크다. <span class="math notranslate nohighlight">\(p\)</span>가 클 때 <span class="math notranslate nohighlight">\(n\)</span>개 관측을 시각화하려면 분명히 더 나은 방법이 필요하다. 즉, 가능한 많은 정보를 포착하는 데이터의 저차원 표현(low-dimensional representation)이 필요하다. 예를 들어, 데이터세트에 들어있는 대부분의 정보를 포착할 수 있는 데이터의 2차원 표현을 구해, (바라건대) 이 2차원 공간에 모든 관측을 표시할 수 있다면 아주 유용할 것이다.</p>
<p>PCA가 바로 이런 것을 수행하는 도구이다. PCA는 주어진 데이터세트로부터 가능한 많은 변동(variation)을 내포하는 저차원 표현을 찾는 도구이다. 직관적으로 표현하면, <strong>많은 변동</strong>이라는 것은 <strong>많은 정보</strong>를 의미한다고 보면 된다. 데이터 포인트들을 주성분 직선에 투영시킨 소위 주성분 값(점수)들이 서로 최대한 넓게 퍼져 있어야 해당 주성분 직선이 해당 데이터의 특징을 잘 포착하는 것을 의미하기 때문이다.</p>
<p>PCA의 기본 아이디어는 이렇다. <span class="math notranslate nohighlight">\(n\)</span>개 관측값이 <span class="math notranslate nohighlight">\(p\)</span>차원(dimension) 공간에 있는데, 이들 차원이 모두 똑같이 흥미롭지는 않다는 것이다. PCA는 가능한 흥미로운 <strong>소수의 차원을 찾는</strong> 방법이다. 여기서 흥미롭다(interesting)는 개념은 PCA에 의해 구한 각 차원에서의 관측값(즉 투영)이 얼마나 변동하는지에 의해 측정된다. PCA의 각 차원은 <span class="math notranslate nohighlight">\(p\)</span>개 변수의 선형결합(linear combination)에 의해 구한다.</p>
<p>그렇다면 구체적으로 <strong>주성분</strong>을 어떻게 찾는지 그 방법을 알아보자. 변수 집합 <span class="math notranslate nohighlight">\(X_1,X_2, . . . ,X_p\)</span>의 <strong>첫 번째 주성분</strong>은 변수들의 정규화된(normalized) 선형결합 중 분산(즉 변동)이 가장 큰 것을 말한다. 식으로 표현하면 다음과 같다.</p>
<div class="math notranslate nohighlight">
\[
Z_1 = \phi_{11}X_1 + \phi_{21}X_2 + \dots + \phi_{p1}X_p \tag{16.3}
\]</div>
<p>여기에서 <strong>정규화</strong>는 <span class="math notranslate nohighlight">\(\sum_{j=1}^{p} \phi_{j1}^2 = 1\)</span>를 의미한다. 그리고 <span class="math notranslate nohighlight">\(\phi_{11},...,\phi_{p1}\)</span>을 첫 번째 주성분의 <strong>부하량</strong>(loading)이라고 부른다. 또한 <span class="math notranslate nohighlight">\(\phi_{1} = (\phi_{11} \ \phi_{21} \ ... \ \phi_{p1})^T\)</span>를 첫 번째 주성분 부하량 벡터라고 부른다.</p>
<p>위 식에서 보듯이 부하량은 선형결합에 있어서 각 변수의 계수이기 때문에 주성분 변수(점수)에 있어서 각 변수의 중요도 또는 기여도를 의미한다고 할 수 있다. 부하량을 구할 때, 정규화 조건(즉 부하량의 제곱합이 1이라는 조건)을 두는 이유는 그렇지 않으면 각 부하량의 절대값을 키우는 것만으로도 분산을 무한히 키울 수 있기 때문이다.</p>
<p>구체적으로 <span class="math notranslate nohighlight">\(n \times p\)</span> 데이터세트 <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>가 주어졌을 때, 첫 번째 주성분을 찾는 방법은 다음과 같다. 우선 우리는 분산에만 관심이 있기 때문에 <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>의 모든 개별 변수의 평균이 0이 되도록 만든다. 그런 다음, 정규화 조건 <span class="math notranslate nohighlight">\(\sum_{j=1}^{p} \phi_{j1}^2 = 1\)</span> 하에서 다음의 선형결합 중 <span class="math notranslate nohighlight">\(z_{i1}\)</span>(여기에서 <span class="math notranslate nohighlight">\(i=1,...,n\)</span>)의 표본분산을 가장 크게 만드는 <span class="math notranslate nohighlight">\(\phi_{11},\phi_{21},...,\phi_{p1}\)</span>을 구한다.</p>
<div class="math notranslate nohighlight">
\[
z_{i1} = \phi_{11}x_{i1} + \phi_{21}x_{i2} + \dots + \phi_{p1}x_{ip} \tag{16.4}
\]</div>
<p>이렇게 해서 구한 첫 번째 주성분 벡터 <span class="math notranslate nohighlight">\(z_{i1}\)</span>, 즉 <span class="math notranslate nohighlight">\(z_{11},...,z_{n1}\)</span>이 첫 번째 주성분 점수이다.</p>
<p>지금까지 설명한 첫 번째 주성분을 기하학적으로 해석하면 다음과 같다. <span class="math notranslate nohighlight">\(\phi_{11},\phi_{21},...,\phi_{p1}\)</span>을 원소로 하는 부하량 벡터 <span class="math notranslate nohighlight">\(\phi_1\)</span>은 <span class="math notranslate nohighlight">\(p\)</span>차원의 변수 공간에서 데이터의 변동성이 가장 큰 방향(direction)으로 정의된다. 즉 부하량 벡터는 위에서 설명한 주성분 직선에 해당한다. <span class="math notranslate nohighlight">\(n\)</span>개의 데이터 포인트 <span class="math notranslate nohighlight">\(x_{1},...,x_{n}\)</span>을 해당 주성분 직선에 투영하면 그 값이 주성분 점수 <span class="math notranslate nohighlight">\(z_{11},...,z_{n1}\)</span>이 된다. 앞의 그림 16.1에서 광고 데이터세트의 첫 번째 주성분 직선은 녹색선이고, 식 16.2에서 볼 수 있듯이 부하량은 <span class="math notranslate nohighlight">\(\phi_{11}=0.839\)</span> 및 <span class="math notranslate nohighlight">\(\phi_{21}=0.544\)</span>이다.</p>
<p>데이터세트의 첫 번째 주성분 <span class="math notranslate nohighlight">\(Z_1\)</span>이 결정되면, 두 번째 주성분 <span class="math notranslate nohighlight">\(Z_2\)</span>를 찾을 수 있다. 두 번째 주성분은 <span class="math notranslate nohighlight">\(Z_1\)</span>과 선형의 상관관계가 없는 모든 선형결합 중에서 최대 분산을 갖는 <span class="math notranslate nohighlight">\(X_{1},...,X_{p}\)</span>의 선형결합이다. 그런 식으로 두 번째 부하량 벡터 <span class="math notranslate nohighlight">\(\phi_2\)</span>를 구하면 <strong>두 번째 주성분 점수</strong> <span class="math notranslate nohighlight">\(z_{12},z_{12},...,z_{n2}\)</span>는 다음과 같이 표현된다.</p>
<div class="math notranslate nohighlight">
\[
z_{i2} = \phi_{12}x_{i1} + \phi_{22}x_{i2} + \dots + \phi_{p2}x_{ip} \tag{16.5}
\]</div>
<p>여기서 <span class="math notranslate nohighlight">\(\phi_{2}\)</span>는 <span class="math notranslate nohighlight">\(\phi_{12},\phi_{22},...,\phi_{p2}\)</span>를 원소로 하는 두 번째 주성분 부하량 벡터이다. <span class="math notranslate nohighlight">\(Z_2\)</span>를 <span class="math notranslate nohighlight">\(Z_1\)</span>과 상관관계가 없도록 제한하는 것은 <span class="math notranslate nohighlight">\(\phi_{2}\)</span> 벡터를 <span class="math notranslate nohighlight">\(\phi_{1}\)</span> 벡터에 <strong>직교</strong>(orthogonal)하도록 제한하는 것과 같다. 앞의 그림 16.1의 예에서 관측이 2차원 공간에 있으므로(즉 <span class="math notranslate nohighlight">\(p = 2\)</span>이므로) <span class="math notranslate nohighlight">\(\phi_{1}\)</span>을 찾으면 <span class="math notranslate nohighlight">\(\phi_{2}\)</span>에 대한 가능성은 단 하나이며, 그림에서 파란색 점선이 그것이다. <span class="math notranslate nohighlight">\(\phi_{2}\)</span>를 찾는 것은 <span class="math notranslate nohighlight">\(\phi_{2}\)</span>가 <span class="math notranslate nohighlight">\(\phi_{1}\)</span>에 직교한다는 제약 조건만 추가하고, 나머지는 <span class="math notranslate nohighlight">\(\phi_{1}\)</span>을 찾을 때와 동일하다. 이렇게 해서 찾은 것이 앞에서도 나왔듯이 <span class="math notranslate nohighlight">\(\phi_{12}=0.544\)</span> 및 <span class="math notranslate nohighlight">\(\phi_{22}=−0.839\)</span>이다. <span class="math notranslate nohighlight">\(p &gt; 2\)</span> 변수를 가진 더 큰 데이터 세트에는 2개보다 많은 주성분이 있다. 이미 두 번째 주성분까지는 설명했고, 세 번째 이후의 주성분을 찾는 것도 마찬가지 방식으로 정의된다.</p>
<p>이상은 주성분 도출을 직관적으로 설명한 것이고, 그렇다면 실제로 주성분을 어떻게 구하냐면, 선형대수(linear algebra)의 표준적 기법인 <strong>고유분해</strong>(eigen decomposition)를 통해 구할 수 있다.  데이터세트 <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>가 있을 때 공분산 행렬 <span class="math notranslate nohighlight">\(\mathbf{X}^T\mathbf{X}\)</span>의 <strong>고유벡터</strong>(eigenvectors)들이 주성분 부하량 벡터 <span class="math notranslate nohighlight">\(\phi_{1},\text{ }\phi_{2},\text{ },..., \phi_{p}\)</span>이다. 달리 표현하면 주성분의 직선(방향)이다. 그리고 공분산 행렬의 해당 <strong>고유값</strong>(eigenvalues)은 해당 주성분 점수의 분산에 해당한다. 데이터세트가 <span class="math notranslate nohighlight">\(p\)</span>개의 변수와 <span class="math notranslate nohighlight">\(n\)</span>개의 관측으로 이루어져 있을 때, 최대 <span class="math notranslate nohighlight">\({\rm min}(n − 1, p)\)</span>개의 주성분이 있다.</p>
</section>
<section id="id5">
<h2>16.4 주성분 계산 단계별 설명<a class="headerlink" href="#id5" title="Link to this heading">#</a></h2>
<p>출처: (1) <a class="reference external" href="https://builtin.com/data-science/step-step-explanation-principal-component-analysis">A Step-by-Step Explanation of Principal Component Analysis</a>, (2) <a class="reference external" href="http://www.cs.otago.ac.nz/cosc453/student_tutorials/principal_components.pdf">A tutorial on Principal Components Analysis</a></p>
<p>주성분 분석(PCA)은 변수 집합이 클 때, 이들 소수의 변수로 변환하는 방법이다. 달리 표현하면 큰 데이터 집합의 차원(dimension)을 줄이는 데 주로 사용되는 <strong>차원축소</strong>(dimension reduction) 방법이다. 가령 데이터세트에 100개의 변수가 있는데 이를 10개의 변수로 변환하는 것이다. 이때 중요한 것은 변환된 소수의 변수가 원래(original) 변수에 들어있는 가능한 많은 정보를 담고 있어야 한다는 점이다. 이를 가능하게 해주는 방법 중의 하나가 PCA이다.</p>
<p>데이터세트의 변수 개수를 줄이면 자연스럽게 정확도를 희생하게 된다. 차원 감소 아이디어는 기본적으로 단순함을 위해 약간의 정확도를 희생하는 것이다. 변수 개수를 줄이면, 데이터를 탐색하고 시각화하고 분석하기가 훨씬 쉽고 빠르기 때문이다. 달리 표현하면, PCA는 데이터세트의 변수 개수를 줄이면서도 가능한 많은 정보를 보존하려는 기법이다.</p>
<p>PCA 작업은 다음 다섯 단계로 나눌 수 있다.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>원래 변수를 표준화</p></li>
<li><p>공분산 행렬 계산</p></li>
<li><p>공분산 행렬의 고유벡터와 고유값 계산</p></li>
<li><p>주성분 선택</p></li>
<li><p>주성분 축을 따라 데이터 재구성하기</p></li>
</ol>
</div></blockquote>
<section id="step-1">
<h3>STEP 1:  표준화<a class="headerlink" href="#step-1" title="Link to this heading">#</a></h3>
<p>데이터세트 각 변수의 범위를 <strong>표준화</strong>(standardization)하여 모든 변수가 분석에 동등하게 기여하도록 할 필요가 있다. PCA에 있어서 표준화가 중요한 이유는 PCA가 변수의 평균과 분산에 상당히 민감하기 때문이다. 즉, 주어진 변수들이 범위(range)에 있어서 큰 차이가 있는 경우, 범위가 더 큰 변수가 작은 범위를 가진 변수보다 PCA에서 우세한 영향을 미친다.</p>
<p>예를 들어 100에서 200 사이에서 변하는 변수가 1에서 2 사이에서 변하는 변수보다 우세한 영향을 미친다. 이것은 문제가 아닐 수 없다. 왜냐하면 가령 데이터세트에 키(height) 변수가 있는데 단위를 센티미터로 하느냐, 아니면 미터로 표시하느냐에 따라 PCA의 결과가 달라지기 때문이다. 이런 문제를 해결하는 방법 중의 하나가 모든 변수를 표준화시키는 것이다. 즉 각 변수의 평균을 0으로 만들고 표준편차(및 분산)를 1로 만들어 척도를 통일하는 것이다.</p>
<p>표준화를 하는 방법은 간단한데, 각 변수별로 각 관측값에서 해당 변수의 평균값을 빼고, 그것을 해당 변수의 표준편차로 나누면 된다. 이렇게 하면 각 변수의 평균이 0이 되고 표준편차가 1로 바뀌게 된다.</p>
</section>
<section id="step-2">
<h3>STEP 2: 공분산 행렬<a class="headerlink" href="#step-2" title="Link to this heading">#</a></h3>
<p>PCA의 목표가 가능한 많은 정보를 보존하면서 변수 개수를 줄이는 것이기 때문에 변수 간의 중복된(또는 상관된) 정보를 식별하는 것이 중요하다. 모든 변수를 용광로에 넣어 중복된 정보를 압축시키는 것에 비유할 수 있다. 이런 맥락에서 PCA를 위해서는 가장 먼저 변수 간의 상관관계를 식별할 수 있는 공분산 행렬(covariance matrix)을 계산해야 한다.</p>
<p>변수가 <span class="math notranslate nohighlight">\(p\)</span>개 일 때, 공분산 행렬은 <span class="math notranslate nohighlight">\(p \times p\)</span> 대칭 행렬이다. 예를 들어, 3개의 변수 <span class="math notranslate nohighlight">\(x, y, z\)</span>가 있는 3차원 데이터세트의 경우 공분산 행렬은 다음과 같은 <span class="math notranslate nohighlight">\(3 \times 3\)</span> 행렬이다.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{bmatrix}
Cov(x,x)&amp;Cov(x,y)&amp;Cov(x,z)\\
Cov(y,x)&amp;Cov(y,y)&amp;Cov(y,z)\\
Cov(z,x)&amp;Cov(z,y)&amp;Cov(z,z)\\
\end{bmatrix}
\end{split}\]</div>
<p>그런데 변수 자신과의 공분산을 우리는 분산이라고 한다. 즉 <span class="math notranslate nohighlight">\(Cov(a,a)=Var(a)\)</span>이다. 따라서 공분산 행렬의 주대각선 원소(왼쪽 상단에서 오른쪽 하단까지의 원소)는 차례로 <span class="math notranslate nohighlight">\(Var(x)\)</span>, <span class="math notranslate nohighlight">\(Var(y)\)</span>, <span class="math notranslate nohighlight">\(Var(z)\)</span>에 해당한다. 그리고 공분산은 <span class="math notranslate nohighlight">\(Cov(a,b)=Cov(b,a)\)</span>이 성립하므로 공분산 행렬은 주대각선에 대해 대칭 행렬이다.</p>
</section>
<section id="step-3">
<h3>STEP 3: 공분산 행렬의 고유벡터와 고유값으로 주성분 식별<a class="headerlink" href="#step-3" title="Link to this heading">#</a></h3>
<p>데이터의 주성분은 공분산 행렬을 이용하여 구한다. 즉 공분산 행렬에 대해 선형대수의 <strong>고유분해</strong>를 적용하여 <strong>고유벡터</strong>와 <strong>고유값</strong>을 구해야 한다.</p>
<p>고유벡터와 고유값에 대해 가장 먼저 알아야 할 것은 고유벡터와 고유값이 항상 쌍으로 나타나며, 따라서 모든 고유벡터가 자신의 고유값을 갖는다는 것이다. 그리고 그 개수는 일반적으로 데이터의 차원 수와 같다. 예를 들어, 3차원 데이터세트의 경우, 즉 변수가 3개 있는 경우, 고유벡터가 3개이고 그 각각에 대해 해당 고유값이 있다.</p>
<p>공분산 행렬의 고유벡터는 우리가 주성분의 방향 또는 부하량 벡터라고 부르는 것이다. 그리고 고유값은 각 주성분에 포함된 분산의 양을 의미한다. 고유값의 크기대로 고유벡터의 순서를 매기면 가장 높은 것부터 가장 낮은 것까지 순서대로 주성분을 얻을 수 있다. 데이터세트에 2개의 변수 <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>가 있고, 공분산 행렬의 고유벡터와 고유값이 다음과 같다고 해보자.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
v_1 = \begin{bmatrix}
0.6779\\
0.7352\\
\end{bmatrix}
~~~~~~~~~~
\lambda_1 = 1.2840\\[4ex]
v_2 = \begin{bmatrix}
-0.7352\\
0.6779\\
\end{bmatrix}
~~~~~~~
\lambda_2 = 0.0491
\end{split}\]</div>
<p>이 경우 고유값 크기를 보면 <span class="math notranslate nohighlight">\(\lambda_1&gt;\lambda_2\)</span>이다. 따라서 <span class="math notranslate nohighlight">\(\lambda_1\)</span>에 해당하는 고유벡터 <span class="math notranslate nohighlight">\(v_1\)</span>이 첫 번째 주성분(PC1)이고, <span class="math notranslate nohighlight">\(\lambda_2\)</span>에 해당하는 고유벡터 <span class="math notranslate nohighlight">\(v_2\)</span>가 두 번째 주성분(PC2)이 된다.</p>
<p>주성분을 얻은 후 각 성분이 설명하는 분산(정보)의 백분율을 계산하기 위해서는 각 주성분의 고유값을 전체 고유값으로 나누면 된다. 위의 예에 이를 적용하면 PC1과 PC2가 각각 데이터 분산의 96%와 4%를 설명(전달)한다.</p>
</section>
<section id="step-4">
<h3>STEP 4: 주성분 선택<a class="headerlink" href="#step-4" title="Link to this heading">#</a></h3>
<p>공분산 행렬의 고유벡터를 계산하고 그것을 고유값에 따라 내림차순으로 정렬하면 주성분을 중요한 순서대로 찾을 수 있다. 즉 가장 큰 고유값에 해당하는 고유벡터가 첫 번째 부하량 벡터이고, 두 번째로 큰 고유값에 해당하는 고유벡터가 두 번째 부하량 벡터가 되는 식이다.</p>
<p>이 단계에서 우리가 하는 일은 이러한 모든 주성분을 유지할지 아니면 (고유값이 낮은) 덜 중요한 주성분을 버릴지 선택하는 것이다. 이러한 선택이 이루어지면 소위 특성 벡터(feature vector)를 만든다. 만약 총 <span class="math notranslate nohighlight">\(p\)</span>개의 고유벡터에서 처음 <span class="math notranslate nohighlight">\(m\)</span>개의 고유벡터를 사용하기로 결정했다면 특성 벡터는 다음과 같다.</p>
<div class="math notranslate nohighlight">
\[
{\rm Feature \ Vector} = (v_1, v_2, ..., v_m)
\]</div>
<p>앞의 <span class="math notranslate nohighlight">\(p=2\)</span> 예에서 고유벡터 <span class="math notranslate nohighlight">\(v_1\)</span>과 <span class="math notranslate nohighlight">\(v_2\)</span>를 모두 사용하기로 한다면 특성 벡터는 다음과 같다.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{bmatrix}
0.6779&amp;-0.7352\\
0.7352&amp;0.6779\\
\end{bmatrix}
\end{split}\]</div>
<p>반면, 중요도가 떨어지는 고유벡터 <span class="math notranslate nohighlight">\(v_2\)</span>를 버리고 <span class="math notranslate nohighlight">\(v_1\)</span>만으로 특성 벡터를 만드는 선택을 할 수도 있다.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{bmatrix}
0.6779\\
0.7352\\
\end{bmatrix}
\end{split}\]</div>
<p>고유벡터 <span class="math notranslate nohighlight">\(v_2\)</span>를 버리면 차원이 하나 줄어들고 결과적으로 원래 데이터세트의 정보가 손실된다. 그러나 <span class="math notranslate nohighlight">\(v_2\)</span>가 정보의 4%만 전달한다는 점을 감안할 때 정보 손실은 크지 않으며 <span class="math notranslate nohighlight">\(v_1\)</span>이 전달하는 96%의 정보는 여전히 유지된다.</p>
</section>
<section id="step-5">
<h3>STEP 5: 주성분 축을 따라 데이터를 변환<a class="headerlink" href="#step-5" title="Link to this heading">#</a></h3>
<p>마지막 단계에서는 앞에서 만든 특성 벡터를 사용하여 데이터를 원래 축에서 주성분 축으로 재배향(reorient)한다. 즉 주성분 변수를 만들어 원래 데이터세트를 대체하는 것이다. 주성분 점수를 계산하기 위해서는 표준화된 원래 데이터세트에다 특성 벡터를 곱하면 된다.</p>
<div class="math notranslate nohighlight">
\[
{\rm Final \ Data \ Set = Stadarized \ Original \ Data \ Set \times Feature \ Vector} 
\]</div>
<p>이렇게 하면 관측 개수 <span class="math notranslate nohighlight">\(n\)</span>은 동일하면서 변수가 원래의 <span class="math notranslate nohighlight">\(p\)</span>개에서 <span class="math notranslate nohighlight">\(m\)</span>개로 줄어들게 된다.</p>
</section>
</section>
<section id="id6">
<h2>16.5 파이썬으로 주성분 계산하기<a class="headerlink" href="#id6" title="Link to this heading">#</a></h2>
<section id="usarrest">
<h3>USArrest 데이터세트<a class="headerlink" href="#usarrest" title="Link to this heading">#</a></h3>
<p>코드 출처: <a class="reference external" href="https://github.com/jcrouser/islr-python/blob/master/Lab%2018%20-%20PCA%20in%20Python.ipynb">PCA in Python</a></p>
<p><strong>데이터세트 로딩</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">USArrest</span></code> 데이터세트에는 미국 50개 주(state) 별로 4개의 특성이 들어있다. 즉, 폭행(<code class="docutils literal notranslate"><span class="pre">Assault</span></code>), 살인(<code class="docutils literal notranslate"><span class="pre">Murder</span></code>), 강간(<code class="docutils literal notranslate"><span class="pre">Rape</span></code>)이라는 세 가지 중범죄에 대해 주민 100,000명당 체포 건수가 나와 있으며, 마지막으로 <code class="docutils literal notranslate"><span class="pre">UrbanPop</span></code>은 해당 주의 도시 지역 거주 인구 비율(%)이다. 우선 기본 라이브러리와 데이터세트를 불러들인다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;https://raw.githubusercontent.com/JWarmenhoven/ISLR-python/master/Notebooks/</span><span class="se">\</span>
<span class="s1">Data/USArrests.csv&#39;</span>
<span class="n">USArrest</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">USArrest</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Murder</th>
      <th>Assault</th>
      <th>UrbanPop</th>
      <th>Rape</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Alabama</th>
      <td>13.2</td>
      <td>236</td>
      <td>58</td>
      <td>21.2</td>
    </tr>
    <tr>
      <th>Alaska</th>
      <td>10.0</td>
      <td>263</td>
      <td>48</td>
      <td>44.5</td>
    </tr>
    <tr>
      <th>Arizona</th>
      <td>8.1</td>
      <td>294</td>
      <td>80</td>
      <td>31.0</td>
    </tr>
    <tr>
      <th>Arkansas</th>
      <td>8.8</td>
      <td>190</td>
      <td>50</td>
      <td>19.5</td>
    </tr>
    <tr>
      <th>California</th>
      <td>9.0</td>
      <td>276</td>
      <td>91</td>
      <td>40.6</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>먼저 네 개 변수의 평균을 살펴보면, 변수별로 평균값이 크게 다른 것을 알 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">USArrest</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Murder        7.788
Assault     170.760
UrbanPop     65.540
Rape         21.232
dtype: float64
</pre></div>
</div>
</div>
</div>
<p>이번에는 네 개 변수의 분산을 살펴보면, 분산 역시 변수별로 매우 다르다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">USArrest</span><span class="o">.</span><span class="n">var</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Murder        18.970465
Assault     6945.165714
UrbanPop     209.518776
Rape          87.729159
dtype: float64
</pre></div>
</div>
</div>
</div>
<p><strong>데이터 표준화</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">USArrest</span></code> 데이터세트의 경우 PCA를 수행하기 전에 변수의 척도를 조정하지 않으면 우리가 관찰한 대부분의 주성분은 <code class="docutils literal notranslate"><span class="pre">Assault</span></code> 변수에 의해 지배될 것이다. 왜냐하면 <code class="docutils literal notranslate"><span class="pre">Assault</span></code> 변수가 가장 큰 평균과 분산값을 갖고 있기 때문이다. 더구나 <code class="docutils literal notranslate"><span class="pre">UrbanPop</span></code> 변수는 도시 지역에 거주하는 각 주의 인구 비율(%)을 측정하기 때문에 이는 100,000명당 범죄 건수와 척도 자체가 다르다. 이 점에서도 척도를 통일시킬 필요가 있다.</p>
<p>따라서 PCA를 수행하기 전에 평균이 0이고 표준편차가 1이 되도록 변수를 표준화하기로 한다. 사이킷런(<code class="docutils literal notranslate"><span class="pre">sklearn</span></code>)의 <code class="docutils literal notranslate"><span class="pre">scale()</span></code> 함수를 사용하여 이 작업을 수행할 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">scale</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scale</span><span class="p">(</span><span class="n">USArrest</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">USArrest</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">USArrest</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
<span class="n">X</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Murder</th>
      <th>Assault</th>
      <th>UrbanPop</th>
      <th>Rape</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Alabama</th>
      <td>1.255179</td>
      <td>0.790787</td>
      <td>-0.526195</td>
      <td>-0.003451</td>
    </tr>
    <tr>
      <th>Alaska</th>
      <td>0.513019</td>
      <td>1.118060</td>
      <td>-1.224067</td>
      <td>2.509424</td>
    </tr>
    <tr>
      <th>Arizona</th>
      <td>0.072361</td>
      <td>1.493817</td>
      <td>1.009122</td>
      <td>1.053466</td>
    </tr>
    <tr>
      <th>Arkansas</th>
      <td>0.234708</td>
      <td>0.233212</td>
      <td>-1.084492</td>
      <td>-0.186794</td>
    </tr>
    <tr>
      <th>California</th>
      <td>0.281093</td>
      <td>1.275635</td>
      <td>1.776781</td>
      <td>2.088814</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p><strong>주성분 부하량 벡터</strong></p>
<p>이제 <code class="docutils literal notranslate"><span class="pre">sklearn</span></code>의 <code class="docutils literal notranslate"><span class="pre">PCA()</span></code> 함수를 사용하여 고유벡터(즉 주성분 부하량 벡터)를 계산해보자. 우선 <code class="docutils literal notranslate"><span class="pre">PCA()</span></code> 함수(또는 모델이라고 표현할 수도 있음)를 <code class="docutils literal notranslate"><span class="pre">pca</span></code>라는 이름으로 지정한 다음, <code class="docutils literal notranslate"><span class="pre">fit</span></code> 메서드를 사용하여 바로 앞에서 표준화시킨 데이터세트 <code class="docutils literal notranslate"><span class="pre">X</span></code>에 피팅한다. 피팅 결과에서 <code class="docutils literal notranslate"><span class="pre">PCA()</span></code> 함수의 속성(attribute)인 <code class="docutils literal notranslate"><span class="pre">components_</span></code>를 사용하여 주성분의 방향(선 또는 축), 달리 표현하면 부하량 벡터를 구할 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>

<span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">()</span>
<span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">pca_loading</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">components_</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                           <span class="n">index</span><span class="o">=</span><span class="n">USArrest</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;v1&#39;</span><span class="p">,</span> <span class="s1">&#39;v2&#39;</span><span class="p">,</span> <span class="s1">&#39;v3&#39;</span><span class="p">,</span> <span class="s1">&#39;v4&#39;</span><span class="p">])</span>
<span class="n">pca_loading</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>v1</th>
      <th>v2</th>
      <th>v3</th>
      <th>v4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Murder</th>
      <td>0.535899</td>
      <td>-0.418181</td>
      <td>-0.341233</td>
      <td>-0.649228</td>
    </tr>
    <tr>
      <th>Assault</th>
      <td>0.583184</td>
      <td>-0.187986</td>
      <td>-0.268148</td>
      <td>0.743407</td>
    </tr>
    <tr>
      <th>UrbanPop</th>
      <td>0.278191</td>
      <td>0.872806</td>
      <td>-0.378016</td>
      <td>-0.133878</td>
    </tr>
    <tr>
      <th>Rape</th>
      <td>0.543432</td>
      <td>0.167319</td>
      <td>0.817778</td>
      <td>-0.089024</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p><strong>주성분 해석</strong></p>
<p><span class="math notranslate nohighlight">\(n\)</span>개 관측과 <span class="math notranslate nohighlight">\(p\)</span>개 변수가 있는 데이터 세트에는 최대 <span class="math notranslate nohighlight">\( {\rm min}(n − 1, p)\)</span>개의 주성분이 있다. 따라서 <code class="docutils literal notranslate"><span class="pre">USArrest</span></code> 데이터세트의 경우에는 위 결과에서 보듯이 4개의 주성분이 있다.</p>
<p>먼저 첫 번째 부하량 벡터(<code class="docutils literal notranslate"><span class="pre">v1</span></code>)를 보면, <code class="docutils literal notranslate"><span class="pre">Assault</span></code>, <code class="docutils literal notranslate"><span class="pre">Murder</span></code>, <code class="docutils literal notranslate"><span class="pre">Rape</span></code> 등 3개 중범죄 변수에 대해서는 0.55 전후의 거의 동일한 가중치를 부여하지만 <code class="docutils literal notranslate"><span class="pre">UrbanPop</span></code>에 대해서는 훨씬 작은 가중치(0.278)를 부여한다는 것을 알 수 있다. 따라서 이 주성분은 3개 범죄에 초점을 맞춰 이들의 평균값을 구한다고 볼 수 있다. 이는 범죄 관련 변수가 높은 상관관계가 있음을 의미하는 것이기도 하다. 즉, 살인율이 높은 주에서는 폭행 및 강간율이 높은 경향이 있는 것이다. 반면, <code class="docutils literal notranslate"><span class="pre">UrbanPop</span></code> 변수는 다른 세 가지 변수와 상관관계가 낮다는 것을 변수별 부하량을 통해 짐작할 수 있다.</p>
<p>한편 두 번째 부하량 벡터를 보면, 대부분의 가중치를 <code class="docutils literal notranslate"><span class="pre">UrbanPop</span></code>에 배치하고(절대값이 가장 큼), 다른 3개 특성에 대해서는 훨씬 작은 가중치를 부여한다. 따라서 이 두 번째 주성분은 대략 주의 도시화 수준을 대변하는 성분에 해당한다.</p>
<p>사실 이 경우에는 두 개 주성분의 해석이 어느 정도 가능하다. 즉 첫 번째 주성분은 각 주의 중범죄 관련 특성을 보여주고, 두 번째 주성분은 도시화 수준 특성을 보여주는 것으로 해석할 수 있다. 그러나 일반적으로 보았을 때, 주성분 변수가 항상 이처럼 해석이 잘 되는 것은 아니다.</p>
<p><strong>주성분 점수</strong></p>
<p>주성분 피팅 결과(즉 <code class="docutils literal notranslate"><span class="pre">pca</span></code>)에 <code class="docutils literal notranslate"><span class="pre">fit_transform()</span></code> 메서드를 적용하여 4개 주성분 변수를 얻을 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pca_score</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">),</span>
                         <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;PC1&#39;</span><span class="p">,</span> <span class="s1">&#39;PC2&#39;</span><span class="p">,</span> <span class="s1">&#39;PC3&#39;</span><span class="p">,</span> <span class="s1">&#39;PC4&#39;</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
<span class="n">pca_score</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PC1</th>
      <th>PC2</th>
      <th>PC3</th>
      <th>PC4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Alabama</th>
      <td>0.985566</td>
      <td>-1.133392</td>
      <td>-0.444269</td>
      <td>-0.156267</td>
    </tr>
    <tr>
      <th>Alaska</th>
      <td>1.950138</td>
      <td>-1.073213</td>
      <td>2.040003</td>
      <td>0.438583</td>
    </tr>
    <tr>
      <th>Arizona</th>
      <td>1.763164</td>
      <td>0.745957</td>
      <td>0.054781</td>
      <td>0.834653</td>
    </tr>
    <tr>
      <th>Arkansas</th>
      <td>-0.141420</td>
      <td>-1.119797</td>
      <td>0.114574</td>
      <td>0.182811</td>
    </tr>
    <tr>
      <th>California</th>
      <td>2.523980</td>
      <td>1.542934</td>
      <td>0.598557</td>
      <td>0.341996</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p><strong>설명된 분산 비중</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">PCA()</span></code> 함수는 각 주성분이 설명하는 분산의 크기도 제공한다. <code class="docutils literal notranslate"><span class="pre">PCA()</span></code>의 속성인 <code class="docutils literal notranslate"><span class="pre">explained_variance_</span></code>을 사용하여 분산 값에 액세스할 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([2.53085875, 1.00996444, 0.36383998, 0.17696948])
</pre></div>
</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">PCA()</span></code>의 또 다른 속성인 <code class="docutils literal notranslate"><span class="pre">explained_variance_ratio_</span></code>을 사용하여 각 주성분에 의해 설명된 분산의 비중(proportion of variance explained)을 구할 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0.62006039, 0.24744129, 0.0891408 , 0.04335752])
</pre></div>
</div>
</div>
</div>
<p>위 결과를 보면, 첫 번째 주성분이 데이터 분산의 62.0%를 설명하고, 두 번째 주성분이 분산의 24.7%를 설명한다. 다음과 같이 각 주성분에 의해 설명되는 분산의 비중을 그림으로 그릴 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Proportion of Variance Explained&#39;</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Principal Component&#39;</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/be84343cd0155b5201daba02db053aea3fcb1af740aca77cb35d1dd1d26264e1.png" src="../_images/be84343cd0155b5201daba02db053aea3fcb1af740aca77cb35d1dd1d26264e1.png" />
</div>
</div>
</section>
<section id="iris">
<h3>IRIS 데이터세트<a class="headerlink" href="#iris" title="Link to this heading">#</a></h3>
<p>코드 출처: <a class="reference external" href="https://towardsdatascience.com/pca-using-python-scikit-learn-e653f8989e60">PCA using Python (scikit-learn)</a></p>
<p>많은 기계학습 문제에서 데이터를 시각화할 수 있으면 도움이 된다. 2차원 또는 3차원 데이터를 시각화하는 것은 어려운 일이 아니다. 그러나 4차원부터는 시각화가 불가능하다. 차원이 훨씬 높은 데이터의 경우에는 말할 것도 없다. 여기에서 예시적으로 다룰 IRIS 데이터세트는 4차원이다. 즉 변수가 4개이다. PCA를 사용하여 4차원 데이터를 2차원 또는 3차원으로 줄여 데이터를 더 잘 이해할 수 있다.</p>
<p><strong>데이터세트 로딩</strong></p>
<p>IRIS 데이터세트를 <a class="reference external" href="https://archive.ics.uci.edu/ml/datasets/iris">UC Irvine Machine Learning Repository</a>에서 불러들인다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&quot;</span>
<span class="n">IRIS</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">url</span><span class="p">,</span>
            <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sepal length&#39;</span><span class="p">,</span><span class="s1">&#39;sepal width&#39;</span><span class="p">,</span><span class="s1">&#39;petal length&#39;</span><span class="p">,</span><span class="s1">&#39;petal width&#39;</span><span class="p">,</span><span class="s1">&#39;target&#39;</span><span class="p">])</span>
<span class="n">IRIS</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sepal length</th>
      <th>sepal width</th>
      <th>petal length</th>
      <th>petal width</th>
      <th>target</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5.1</td>
      <td>3.5</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>Iris-setosa</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.9</td>
      <td>3.0</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>Iris-setosa</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.7</td>
      <td>3.2</td>
      <td>1.3</td>
      <td>0.2</td>
      <td>Iris-setosa</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.6</td>
      <td>3.1</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>Iris-setosa</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.0</td>
      <td>3.6</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>Iris-setosa</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>145</th>
      <td>6.7</td>
      <td>3.0</td>
      <td>5.2</td>
      <td>2.3</td>
      <td>Iris-virginica</td>
    </tr>
    <tr>
      <th>146</th>
      <td>6.3</td>
      <td>2.5</td>
      <td>5.0</td>
      <td>1.9</td>
      <td>Iris-virginica</td>
    </tr>
    <tr>
      <th>147</th>
      <td>6.5</td>
      <td>3.0</td>
      <td>5.2</td>
      <td>2.0</td>
      <td>Iris-virginica</td>
    </tr>
    <tr>
      <th>148</th>
      <td>6.2</td>
      <td>3.4</td>
      <td>5.4</td>
      <td>2.3</td>
      <td>Iris-virginica</td>
    </tr>
    <tr>
      <th>149</th>
      <td>5.9</td>
      <td>3.0</td>
      <td>5.1</td>
      <td>1.8</td>
      <td>Iris-virginica</td>
    </tr>
  </tbody>
</table>
<p>150 rows × 5 columns</p>
</div></div></div>
</div>
<p><strong>데이터세트 내용</strong></p>
<p>이 데이터세트는 아이리스(iris, 붓꽃) 150개 관측 표본에 대한 것이다. 영국의 통계학자이자 생물학자인 Ronald Fisher가 1936년 논문에서 선형판별분석(LDA: linear discriminant analysis)의 예로 사용한 데이터세트이다. 데이터는 3종의 아이리스 꽃(Iris setosa, Iris virginica, Iris versicolor) 각각 50개씩의 표본으로 구성돼 있다. 각 관측마다 4가지 특성(feature)이 기록돼 있는데, 꽃받침(sepal)과 꽃잎(petal)에 대해 길이 및 너비(단위: 센티미터)가 나와 있다.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Iris setosa</p></th>
<th class="head text-center"><p>Iris versicolor</p></th>
<th class="head text-center"><p>Iris virginica</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><img alt="Iris setosa" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/56/Kosaciec_szczecinkowaty_Iris_setosa.jpg/330px-Kosaciec_szczecinkowaty_Iris_setosa.jpg" /></p></td>
<td class="text-center"><p><img alt="Iris versicolor" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/41/Iris_versicolor_3.jpg/330px-Iris_versicolor_3.jpg" /></p></td>
<td class="text-center"><p><img alt="Iris virginica" src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9f/Iris_virginica.jpg/330px-Iris_virginica.jpg" /></p></td>
</tr>
</tbody>
</table>
</div>
<p>출처: Wikipedia, “<a class="reference external" href="https://en.wikipedia.org/wiki/Iris_flower_data_set">Iris flower data set</a>”.</p>
<p><strong>데이터 표준화</strong></p>
<p>PCA는 척도의 영향을 받으므로 PCA를 적용하기 전에 데이터 입력변수(특성)들을 동일한 척도로 맞출 필요가 있다. 사이킷런(<code class="docutils literal notranslate"><span class="pre">sklearn</span></code>)의 <code class="docutils literal notranslate"><span class="pre">StandardScaler()</span></code> 함수를 사용하면 데이터세트의 특성을 단위 척도(즉, 평균 = 0 및 분산 = 1)로 표준화(standardization)할 수 있다.(앞에서 사용한 <code class="docutils literal notranslate"><span class="pre">scale()</span></code> 함수와 사실상 동일하다.) 우선 데이터세트의 변수들을 입력변수(<code class="docutils literal notranslate"><span class="pre">x</span></code>)와 출력변수(<code class="docutils literal notranslate"><span class="pre">y</span></code>)로 나누고 입력변수에 대해 표준화를 적용한다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sepal length&#39;</span><span class="p">,</span> <span class="s1">&#39;sepal width&#39;</span><span class="p">,</span> <span class="s1">&#39;petal length&#39;</span><span class="p">,</span> <span class="s1">&#39;petal width&#39;</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">IRIS</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">features</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">IRIS</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,[</span><span class="s1">&#39;target&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">features</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sepal length</th>
      <th>sepal width</th>
      <th>petal length</th>
      <th>petal width</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-0.900681</td>
      <td>1.032057</td>
      <td>-1.341272</td>
      <td>-1.312977</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-1.143017</td>
      <td>-0.124958</td>
      <td>-1.341272</td>
      <td>-1.312977</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-1.385353</td>
      <td>0.337848</td>
      <td>-1.398138</td>
      <td>-1.312977</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-1.506521</td>
      <td>0.106445</td>
      <td>-1.284407</td>
      <td>-1.312977</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-1.021849</td>
      <td>1.263460</td>
      <td>-1.341272</td>
      <td>-1.312977</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>145</th>
      <td>1.038005</td>
      <td>-0.124958</td>
      <td>0.819624</td>
      <td>1.447956</td>
    </tr>
    <tr>
      <th>146</th>
      <td>0.553333</td>
      <td>-1.281972</td>
      <td>0.705893</td>
      <td>0.922064</td>
    </tr>
    <tr>
      <th>147</th>
      <td>0.795669</td>
      <td>-0.124958</td>
      <td>0.819624</td>
      <td>1.053537</td>
    </tr>
    <tr>
      <th>148</th>
      <td>0.432165</td>
      <td>0.800654</td>
      <td>0.933356</td>
      <td>1.447956</td>
    </tr>
    <tr>
      <th>149</th>
      <td>0.068662</td>
      <td>-0.124958</td>
      <td>0.762759</td>
      <td>0.790591</td>
    </tr>
  </tbody>
</table>
<p>150 rows × 4 columns</p>
</div></div></div>
</div>
<p><strong>4D 데이터를 2D로 투영</strong></p>
<p>데이터세트에는 특성이 4개(<code class="docutils literal notranslate"><span class="pre">sepal</span> <span class="pre">length</span></code>, <code class="docutils literal notranslate"><span class="pre">sepal</span> <span class="pre">width</span></code>, <code class="docutils literal notranslate"><span class="pre">petal</span> <span class="pre">length</span></code>, <code class="docutils literal notranslate"><span class="pre">petal</span> <span class="pre">width</span></code>)가 있다. 아래 코드는 4차원인 데이터세트를 2차원으로 투영(projection)하는 것이다. <code class="docutils literal notranslate"><span class="pre">PCA()</span></code> 괄호안에 <code class="docutils literal notranslate"><span class="pre">n_components=2</span></code>로 기입하면 두 번째 주성분까지 계산된다. 그런 다음, <code class="docutils literal notranslate"><span class="pre">fit_transform()</span></code> 메서드를 사용하여 처음 2개 주성분 변수를 구한 것이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>

<span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">principalComponents</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">principalDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">principalComponents</span><span class="p">,</span>
                           <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;PC1&#39;</span><span class="p">,</span> <span class="s1">&#39;PC2&#39;</span><span class="p">])</span>
<span class="n">principalDf</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PC1</th>
      <th>PC2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-2.264542</td>
      <td>0.505704</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-2.086426</td>
      <td>-0.655405</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-2.367950</td>
      <td>-0.318477</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-2.304197</td>
      <td>-0.575368</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-2.388777</td>
      <td>0.674767</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>145</th>
      <td>1.870522</td>
      <td>0.382822</td>
    </tr>
    <tr>
      <th>146</th>
      <td>1.558492</td>
      <td>-0.905314</td>
    </tr>
    <tr>
      <th>147</th>
      <td>1.520845</td>
      <td>0.266795</td>
    </tr>
    <tr>
      <th>148</th>
      <td>1.376391</td>
      <td>1.016362</td>
    </tr>
    <tr>
      <th>149</th>
      <td>0.959299</td>
      <td>-0.022284</td>
    </tr>
  </tbody>
</table>
<p>150 rows × 2 columns</p>
</div></div></div>
</div>
<p><strong>데이터 시각화</strong></p>
<p>아래는 위에서 구한 주성분 점수와 함께 각 관측이 어떤 종류의 아이리스 꽃에 속하는지(<code class="docutils literal notranslate"><span class="pre">target</span></code> 변수) 구분해 놓은 것이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">finalDf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">principalDf</span><span class="p">,</span> <span class="n">IRIS</span><span class="p">[[</span><span class="s1">&#39;target&#39;</span><span class="p">]]],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">finalDf</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PC1</th>
      <th>PC2</th>
      <th>target</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-2.264542</td>
      <td>0.505704</td>
      <td>Iris-setosa</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-2.086426</td>
      <td>-0.655405</td>
      <td>Iris-setosa</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-2.367950</td>
      <td>-0.318477</td>
      <td>Iris-setosa</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-2.304197</td>
      <td>-0.575368</td>
      <td>Iris-setosa</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-2.388777</td>
      <td>0.674767</td>
      <td>Iris-setosa</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>145</th>
      <td>1.870522</td>
      <td>0.382822</td>
      <td>Iris-virginica</td>
    </tr>
    <tr>
      <th>146</th>
      <td>1.558492</td>
      <td>-0.905314</td>
      <td>Iris-virginica</td>
    </tr>
    <tr>
      <th>147</th>
      <td>1.520845</td>
      <td>0.266795</td>
      <td>Iris-virginica</td>
    </tr>
    <tr>
      <th>148</th>
      <td>1.376391</td>
      <td>1.016362</td>
      <td>Iris-virginica</td>
    </tr>
    <tr>
      <th>149</th>
      <td>0.959299</td>
      <td>-0.022284</td>
      <td>Iris-virginica</td>
    </tr>
  </tbody>
</table>
<p>150 rows × 3 columns</p>
</div></div></div>
</div>
<p>아래는 150개 관측에 대해 첫 번째 주성분 점수를 가로축으로 하고, 두 번째 주성분 점수를 세로축으로 하여 산점도를 그린 것인데, 아이리스 꽃의 3개 종류별로 데이터 포인트의 색깔을 달리했다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Principal Component 1&#39;</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Principal Component 2&#39;</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Visualization of IRIS Dataset Using PCA&#39;</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">12</span><span class="p">)</span>

<span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Iris-setosa&#39;</span><span class="p">,</span> <span class="s1">&#39;Iris-versicolor&#39;</span><span class="p">,</span> <span class="s1">&#39;Iris-virginica&#39;</span><span class="p">]</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span><span class="n">colors</span><span class="p">):</span>
    <span class="n">indicesToKeep</span> <span class="o">=</span> <span class="n">finalDf</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">finalDf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indicesToKeep</span><span class="p">,</span> <span class="s1">&#39;PC1&#39;</span><span class="p">],</span> 
               <span class="n">finalDf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indicesToKeep</span><span class="p">,</span> <span class="s1">&#39;PC2&#39;</span><span class="p">],</span> 
               <span class="n">c</span> <span class="o">=</span> <span class="n">color</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">edgecolor</span> <span class="o">=</span> <span class="s1">&#39;grey&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/5f882f80a4f97036ca19af02aaa079bcef76c92870c5571acb9197a878a92fc9.png" src="../_images/5f882f80a4f97036ca19af02aaa079bcef76c92870c5571acb9197a878a92fc9.png" />
</div>
</div>
<p>위 결과를 보면, 색깔이 같은 점들끼리 상당히 몰려 있는 것을 알 수 있다. 즉 <strong>클러스터링</strong>(clustering)돼있다. 이는 데이터세트의 원래 4개 변수가 아니라 그것들을 결합해서 만든 첫 번째 주성분과 두 번째 주성분만으로도 3종의 아이리스 꽃이 상당히 잘 분류된다는 것을 의미한다. 2개의 주성분만으로도 원래 데이터세트의 특징을 잘 나타낼 수 있다는 의미이기도 하다. 여기에서 중요한 것은 위의 분석을 비지도(unsupervised) 방식으로 수행했다는 점이다. 즉 각 관측의 아이리스 꽃 종류가 무엇인지 참조하지 않고 PCA를 수행했다.</p>
<p><strong>설명된 분산 비중</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">PCA()</span></code> 함수의 속성인 <code class="docutils literal notranslate"><span class="pre">explained_variance_ratio_</span></code>을 사용하여 각 주성분에 의해 설명된 분산의 비중을 구할 수 있다. 즉 각 주성분에 얼마나 많은 정보(분산)가 귀속되는지를 알려준다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0.72770452, 0.23030523])
</pre></div>
</div>
</div>
</div>
<p>첫 번째 주성분은 전체 분산(즉 정보)의 72.8%를 설명하고, 두 번째 주성분은 분산의 23.0%를 설명한다. 처음 두 개의 주성분에 의해 설명된 분산의 비중이 95.8%이다. 세 번째와 네 번째 주성분이 데이터세트의 나머지 분산을 설명한다.</p>
</section>
</section>
<section id="nci60">
<h2>16.6 NCI60 데이터: 시각화<a class="headerlink" href="#nci60" title="Link to this heading">#</a></h2>
<p>코드 출처: <a class="reference external" href="https://github.com/jcrouser/islr-python/blob/master/Lab%2018%20-%20PCA%20in%20Python.ipynb">PCA in Python</a></p>
<section id="id7">
<h3>유전자 데이터 분석<a class="headerlink" href="#id7" title="Link to this heading">#</a></h3>
<p>비지도학습은 유전자 데이터 분석에 자주 사용된다. 특히 PCA는 유전자 데이터 분석에서 널리 사용되는 도구 중 하나다. 우리는 64개 종류의 암세포주(cancer cell lines)에 대한 6,830개의 유전자(gene) 발현값으로 구성된 NCI60 데이터에서 이러한 PCA 기법의 활용에 대해 알아보자.</p>
<p>64개 암세포주는 NCI(National Cancer Institute)가 규정하는 암의 유형이다. 사실 PCA를 수행할 때 암 유형이 필요하지는 않다. 왜냐하면 PCA는 비지도 기법이기 때문이다. 그러나 PCA를 수행한 후 이러한 비지도 기법의 결과가 암 유형을 시각화하고 클러스터링에 효과적인지 확인해보기로 한다.</p>
<p><strong>데이터세트 로딩</strong></p>
<p>우선 데이터세트를 로딩한다. 데이터에는 64개의 행(암세포주)과 6,830개의 열(유전자 발현값)이 있다. 관측 개수(<span class="math notranslate nohighlight">\(n\)</span>)가 64개이고, 변수(또는 특성)의 개수(<span class="math notranslate nohighlight">\(p\)</span>)가 6,830개인 것이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;https://raw.githubusercontent.com/JWarmenhoven/ISLR-python/master/</span><span class="se">\</span>
<span class="s1">Notebooks/Data/NCI60_X.csv&#39;</span>
<span class="n">NCI60</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;Unnamed: 0&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">NCI60</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">NCI60</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">NCI60</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">NCI60</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(64, 6830)
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
      <th>...</th>
      <th>6820</th>
      <th>6821</th>
      <th>6822</th>
      <th>6823</th>
      <th>6824</th>
      <th>6825</th>
      <th>6826</th>
      <th>6827</th>
      <th>6828</th>
      <th>6829</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.300000</td>
      <td>1.180000</td>
      <td>0.550000</td>
      <td>1.140000</td>
      <td>-0.265000</td>
      <td>-7.000000e-02</td>
      <td>0.350000</td>
      <td>-0.315000</td>
      <td>-0.450000</td>
      <td>-0.654980</td>
      <td>...</td>
      <td>-0.990020</td>
      <td>0.000000</td>
      <td>0.030000</td>
      <td>-0.175000</td>
      <td>0.629981</td>
      <td>-0.030000</td>
      <td>0.000000</td>
      <td>0.280000</td>
      <td>-0.340000</td>
      <td>-1.930000</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.679961</td>
      <td>1.289961</td>
      <td>0.169961</td>
      <td>0.379961</td>
      <td>0.464961</td>
      <td>5.799610e-01</td>
      <td>0.699961</td>
      <td>0.724961</td>
      <td>-0.040039</td>
      <td>-0.285019</td>
      <td>...</td>
      <td>-0.270058</td>
      <td>-0.300039</td>
      <td>-0.250039</td>
      <td>-0.535039</td>
      <td>0.109941</td>
      <td>-0.860039</td>
      <td>-1.250049</td>
      <td>-0.770039</td>
      <td>-0.390039</td>
      <td>-2.000039</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.940000</td>
      <td>-0.040000</td>
      <td>-0.170000</td>
      <td>-0.040000</td>
      <td>-0.605000</td>
      <td>0.000000e+00</td>
      <td>0.090000</td>
      <td>0.645000</td>
      <td>0.430000</td>
      <td>0.475019</td>
      <td>...</td>
      <td>0.319981</td>
      <td>0.120000</td>
      <td>-0.740000</td>
      <td>-0.595000</td>
      <td>-0.270020</td>
      <td>-0.150000</td>
      <td>0.000000</td>
      <td>-0.120000</td>
      <td>-0.410000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.280000</td>
      <td>-0.310000</td>
      <td>0.680000</td>
      <td>-0.810000</td>
      <td>0.625000</td>
      <td>-1.387779e-17</td>
      <td>0.170000</td>
      <td>0.245000</td>
      <td>0.020000</td>
      <td>0.095019</td>
      <td>...</td>
      <td>-1.240020</td>
      <td>-0.110000</td>
      <td>-0.160000</td>
      <td>0.095000</td>
      <td>-0.350019</td>
      <td>-0.300000</td>
      <td>-1.150010</td>
      <td>1.090000</td>
      <td>-0.260000</td>
      <td>-1.100000</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.485000</td>
      <td>-0.465000</td>
      <td>0.395000</td>
      <td>0.905000</td>
      <td>0.200000</td>
      <td>-5.000000e-03</td>
      <td>0.085000</td>
      <td>0.110000</td>
      <td>0.235000</td>
      <td>1.490019</td>
      <td>...</td>
      <td>0.554980</td>
      <td>-0.775000</td>
      <td>-0.515000</td>
      <td>-0.320000</td>
      <td>0.634980</td>
      <td>0.605000</td>
      <td>0.000000</td>
      <td>0.745000</td>
      <td>0.425000</td>
      <td>0.145000</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 6830 columns</p>
</div></div></div>
</div>
<p>나중 작업을 위해서 64개 암세포주의 유형을 읽어 놓는다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;https://raw.githubusercontent.com/JWarmenhoven/ISLR-python/master/</span><span class="se">\</span>
<span class="s1">Notebooks/Data/NCI60_y.csv&#39;</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>
<span class="n">y</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>CNS</td>
    </tr>
    <tr>
      <th>1</th>
      <td>CNS</td>
    </tr>
    <tr>
      <th>2</th>
      <td>CNS</td>
    </tr>
    <tr>
      <th>3</th>
      <td>RENAL</td>
    </tr>
    <tr>
      <th>4</th>
      <td>BREAST</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>아래는 64개 암 유형 중에서 중복된 것을 제거했을 때 몇 개 유형이 있는지 알아본 것으로, 총 14개 암 유형이 있다는 것을 알 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s2">&quot;index&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>CNS</td>
    </tr>
    <tr>
      <th>1</th>
      <td>RENAL</td>
    </tr>
    <tr>
      <th>2</th>
      <td>BREAST</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NSCLC</td>
    </tr>
    <tr>
      <th>4</th>
      <td>UNKNOWN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>OVARIAN</td>
    </tr>
    <tr>
      <th>6</th>
      <td>MELANOMA</td>
    </tr>
    <tr>
      <th>7</th>
      <td>PROSTATE</td>
    </tr>
    <tr>
      <th>8</th>
      <td>LEUKEMIA</td>
    </tr>
    <tr>
      <th>9</th>
      <td>K562B-repro</td>
    </tr>
    <tr>
      <th>10</th>
      <td>K562A-repro</td>
    </tr>
    <tr>
      <th>11</th>
      <td>COLON</td>
    </tr>
    <tr>
      <th>12</th>
      <td>MCF7A-repro</td>
    </tr>
    <tr>
      <th>13</th>
      <td>MCF7D-repro</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
</section>
<section id="id8">
<h3>주성분 분석<a class="headerlink" href="#id8" title="Link to this heading">#</a></h3>
<p><strong>데이터 표준화</strong></p>
<p>우리는 먼저 각 변수(유전자 발현값)에 대해 평균을 0, 표준편차를 1로 표준화하여 PCA를 수행하기로 한다. 그런데 이 부분에서 각 유전자 변수들에 대해 <strong>스케일링</strong>(scaling)을 하지 않는 것이 더 낫다는 주장도 있을 수 있다. 즉 평균만 0으로 만들고, 표준편차를 통일하는 작업은 하지 않고 PCA를 수행하는 것이다. 이에 대해서는 바로 아래 참고 사항에 부연 설명이 나와 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">scale</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scale</span><span class="p">(</span><span class="n">NCI60</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<blockquote>
<div><p><strong>참고: PCA와 변수 스케일링</strong>
출처: <a class="reference external" href="https://www.statlearning.com/">ISLP</a>, pp.512-513.</p>
<p>앞에서 PCA를 수행하기 전에 각 변수의 평균을 0으로 만드는 소위 <strong>센터링</strong>(centering)을 해야 한다고 언급했다. 또한 이와 함께 표준편차를 1로 만드는 것도 필요하다고 언급했다.</p>
<p>변수 <strong>스케일링</strong>(척도화)은 변수에 어떤 상수를 곱하거나 나눠줌으로써 해당 변수가 취할 수 있는 값의 범위, 즉 척도를 변화시키는 것을 말한다. 변수를 표준화시킬 때 해당 변수를 그것의 표준편차로 나누는 것이 바로 스케일링이다. PCA를 수행할 때 각 변수를 스케일링하느냐에 따라 결과가 달라진다. 이것은 변수를 스케일링해도 결과에는 사실상 영향을 미치지 않는 선형 회귀 등 여타 지도 및 비지도학습 기법과는 대조된다.(가령 선형 회귀에서는 어떤 변수에 <span class="math notranslate nohighlight">\(c\)</span>를 곱하면 해당 계수 추정값이 원래 값의 <span class="math notranslate nohighlight">\(1/c\)</span>로 작아질 뿐 해당 변수의 통계적 유의성 등에는 전혀 영향을 미치지 않는다.)</p>
<p>앞의 <code class="docutils literal notranslate"><span class="pre">USArrest</span></code> 데이터세트 예에서 <code class="docutils literal notranslate"><span class="pre">Murder</span></code>, <code class="docutils literal notranslate"><span class="pre">Rape</span></code>, <code class="docutils literal notranslate"><span class="pre">Assault</span></code> 변수들은 단위가 100,000명당 각 범죄 발생 건수이며, <code class="docutils literal notranslate"><span class="pre">UrbanPop</span></code>은 도시 지역 거주 인구 비율(%)이다. 이들 4개 변수의 분산은 차례대로 19.0, 87.7, 6945.2, 209.5이다. 만약 모든 변수에 대해 표준편차를 1로 스케일링하지 않고 PCA를 수행하면, 첫 번째 주성분 부하량 벡터는 <code class="docutils literal notranslate"><span class="pre">Assault</span></code>에 대해 매우 큰 부하량을 부여할 것이다. 왜냐하면 그 변수의 분산이 가장 크기 때문이다. 이것은 스케일링을 통해 표준화시킨 변수들에 대해 PCA를 수행한 결과와는 크게 다르다. 우리가 앞의 5.1절에서 이미 본 것처럼 <code class="docutils literal notranslate"><span class="pre">USArrest</span></code> 데이터세트의 모든 변수를 표준화시킨 경우, 첫 번째 주성분 부하량은 <code class="docutils literal notranslate"><span class="pre">Murder</span></code>, <code class="docutils literal notranslate"><span class="pre">Rape</span></code>, <code class="docutils literal notranslate"><span class="pre">Assault</span></code> 변수에 대해 0.55 전후로 상당히 비슷하다.</p>
<p>이처럼 변수를 측정한 척도만 바꿔도 PCA 결과는 크게 달라진다. 예를 들어 폭행(<code class="docutils literal notranslate"><span class="pre">Assault</span></code>)이 100,000명당이 아니라 100명당 발생 건수로 측정됐다고 해보자. 이는 해당 변수의 모든 원소를 1,000으로 나누는 것과 같다. 당연히 해당 변수의 분산이 크게 줄어들게 된다. 이런 상황에서 표준화 없이 PCA를 수행할 경우, 첫 번째 주성분에서 <code class="docutils literal notranslate"><span class="pre">Assault</span></code> 변수의 부하량은 (이번에는 정반대로) 매우 작은 값이 될 것이다. 이처럼 척도를 어떻게 선택하느냐에 따라 PCA 결과가 크게 달라지는 것은 바람직하지 않기 때문에 일반적으로 PCA를 수행하기 전에 표준편차가 1이 되도록 각 변수를 스케일링하는 작업을 거치게 된다.</p>
<p>그러나 어떤 상황에서는 변수들이 이미 동일한 단위로 측정되었을 수도 있다. 이 경우 PCA를 수행하기 전에 표준편차를 1로 만드는 스케일링을 하지 않는 것이 더 나을 수도 있다. 가령 이 절에서 다루고 있는 NCI60 데이터세트에서 <span class="math notranslate nohighlight">\(p\)</span>개 유전자 발현 수준 변수들이 동일한 “단위(unit)”로 측정되었다고 해보자. 이런 경우라면 각 유전자 변수의 표준편차를 1로 만드는 스케일링을 하지 않는 것이 더 나은 선택일 수 있다. 요컨대 PCA를 수행하기 전, 변수의 평균을 0으로 만드는 센터링은 반드시 필요하지만, 스케일링은 상황에 따라 하지 않을 수도 있다.</p>
</div></blockquote>
<p><strong>주성분 점수</strong></p>
<p>이제 <code class="docutils literal notranslate"><span class="pre">sklearn</span></code>의 <code class="docutils literal notranslate"><span class="pre">PCA()</span></code> 함수를 <code class="docutils literal notranslate"><span class="pre">pca</span></code>이라는 이름으로 지정한 다음, 이를 바로 앞에서 표준화시킨 데이터세트 <code class="docutils literal notranslate"><span class="pre">X</span></code>에 피팅시킴과 동시에 <code class="docutils literal notranslate"><span class="pre">fit_transform()</span></code> 메서드를 사용하여 주성분 점수를 구한다. <code class="docutils literal notranslate"><span class="pre">PCA()</span></code>의 괄호안에 주성분의 개수를 따로 지정하지 않았기 때문에 63개 주성분 모두에 대해서 주성분 점수가 계산된다. 주성분의 개수는 최대 <span class="math notranslate nohighlight">\({\rm min}(n − 1, p)\)</span>로서 여기에서는 63개이다. 아래 결과에는 64개 주성분 점수 열(column)이 있는데, 마지막 열은 모든 값이 사실상 0으로서 주성분이 아니다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>

<span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">()</span>
<span class="n">pca_score</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pca_score</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">pca_score</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(64, 64)
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
      <th>...</th>
      <th>54</th>
      <th>55</th>
      <th>56</th>
      <th>57</th>
      <th>58</th>
      <th>59</th>
      <th>60</th>
      <th>61</th>
      <th>62</th>
      <th>63</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>19.838042</td>
      <td>-3.555636</td>
      <td>-9.812399</td>
      <td>-0.824246</td>
      <td>-12.609984</td>
      <td>7.471505</td>
      <td>14.190730</td>
      <td>3.197977</td>
      <td>-21.938350</td>
      <td>-20.369363</td>
      <td>...</td>
      <td>-3.571612</td>
      <td>11.111674</td>
      <td>-6.336264</td>
      <td>-9.077897</td>
      <td>3.892561</td>
      <td>3.240788</td>
      <td>-0.446627</td>
      <td>0.392266</td>
      <td>0.894904</td>
      <td>1.236942e-14</td>
    </tr>
    <tr>
      <th>1</th>
      <td>23.089215</td>
      <td>-6.441460</td>
      <td>-13.478251</td>
      <td>5.635308</td>
      <td>-8.035496</td>
      <td>3.715178</td>
      <td>10.143225</td>
      <td>7.292724</td>
      <td>-22.338284</td>
      <td>-13.119764</td>
      <td>...</td>
      <td>3.378131</td>
      <td>-5.232259</td>
      <td>6.325341</td>
      <td>7.665590</td>
      <td>-3.938798</td>
      <td>-4.018298</td>
      <td>0.617127</td>
      <td>-0.776330</td>
      <td>-0.969009</td>
      <td>1.236942e-14</td>
    </tr>
    <tr>
      <th>2</th>
      <td>27.456114</td>
      <td>-2.465143</td>
      <td>-3.533054</td>
      <td>-1.341673</td>
      <td>-12.564846</td>
      <td>17.344925</td>
      <td>10.354857</td>
      <td>2.671282</td>
      <td>0.234926</td>
      <td>-6.357967</td>
      <td>...</td>
      <td>1.299500</td>
      <td>-5.323021</td>
      <td>4.867172</td>
      <td>0.044978</td>
      <td>-2.027836</td>
      <td>1.089818</td>
      <td>1.695444</td>
      <td>0.498405</td>
      <td>0.844418</td>
      <td>1.236942e-14</td>
    </tr>
    <tr>
      <th>3</th>
      <td>42.816801</td>
      <td>9.768358</td>
      <td>-0.890073</td>
      <td>3.445043</td>
      <td>-42.269904</td>
      <td>27.238815</td>
      <td>17.520642</td>
      <td>0.554341</td>
      <td>-14.264354</td>
      <td>15.969204</td>
      <td>...</td>
      <td>-0.342635</td>
      <td>1.117879</td>
      <td>-2.511719</td>
      <td>-6.390061</td>
      <td>3.429572</td>
      <td>0.705737</td>
      <td>1.372244</td>
      <td>1.427329</td>
      <td>-0.735637</td>
      <td>1.236942e-14</td>
    </tr>
    <tr>
      <th>4</th>
      <td>55.418530</td>
      <td>5.198897</td>
      <td>-21.094558</td>
      <td>15.849712</td>
      <td>-10.443273</td>
      <td>12.991051</td>
      <td>12.597895</td>
      <td>-32.513096</td>
      <td>7.896805</td>
      <td>-10.177263</td>
      <td>...</td>
      <td>-0.264565</td>
      <td>2.311955</td>
      <td>-2.926478</td>
      <td>1.870319</td>
      <td>-2.295689</td>
      <td>-0.614378</td>
      <td>-2.577214</td>
      <td>-0.557610</td>
      <td>0.576024</td>
      <td>1.236942e-14</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 64 columns</p>
</div></div></div>
</div>
<p><strong>데이터 시각화</strong></p>
<p>이제 데이터를 시각화하기 위해 처음 3개의 주성분 점수를 그림으로 그려보자. 가로축과 세로축은 주성분 변수이고, 64개 관측의 주성분 점수를 산점도로 그린 것이다. 동일한 암 유형에 해당하는 관측을 같은 색으로 표시했다. 이렇게 함으로써 (처음 3개의) 주성분만으로 암 유형을 시각화하는 것이 가능한지 확인해보자.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>

<span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>

<span class="n">color_idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">type</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">cmap</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">hsv</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pca_score</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">pca_score</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">color_idx</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> 
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Principal Component 2&#39;</span><span class="p">)</span>

<span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pca_score</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">pca_score</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">color_idx</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> 
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Principal Component 3&#39;</span><span class="p">)</span>

<span class="c1"># 범례(legend)  </span>
<span class="n">handles</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
<span class="n">norm</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">14.0</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
    <span class="n">handles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpl</span><span class="o">.</span><span class="n">patches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">cmap</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span> <span class="n">label</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>

<span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="n">handles</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">borderaxespad</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>

<span class="c1"># x축 레이블</span>
<span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Principal Component 1&#39;</span><span class="p">)</span> 
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/7b23c893bae083bafd5290bbfbb40e9c1a1e252537498cb9698268bd6b022991.png" src="../_images/7b23c893bae083bafd5290bbfbb40e9c1a1e252537498cb9698268bd6b022991.png" />
</div>
</div>
<p>위 결과를 보면, 전체적으로 동일한 암 유형에 속하는 관측들이 (2개 주성분 변수의) 2차원 평면에서 서로 가까이 위치하는, 소위 클러스터링 경향이 있다. 이것은 동일한 암 유형의 세포주가 매우 유사한 유전자 발현 수준을 갖는 경향이 있음을 나타낸다. 단, 이때 유사한 유전자 발현이 원래 데이터의 6,830개 개별 유전자를 의미하는 것이 아니라 PCA에 의해 도출된 처음 3개의 주성분이라는 점이 중요하다. 사실 위와 같은 PCA에 의한 차원축소 방법을 사용하지 않고 데이터를 시각화하는 것은 거의 불가능하다. 왜냐하면 전체 데이터세트를 대상으로 한다면 <span class="math notranslate nohighlight">\(\binom{6,830}{2}=23,321,035\)</span>개의 산점도가 있고, 그 중 어느 것에서도 특별히 유익한 정보를 찾을 수 없을 가능성이 높기 때문이다. 우리는 이 예를 통해 PCA가 데이터세트의 중요한 정보를 주성분에 집약함으로써 데이터 시각화에 유용하게 활용될 수 있음을 알 수 있다.</p>
<p><strong>설명된 분산 비중</strong></p>
<p>다음은 처음 5개의 주성분 점수 벡터들에 대해 표준편차 및 설명된 분산 비중을 계산해 표로 만든 것이다. 여기에서 “Proportion of Variance”은 각 주성분의 개별적인 설명된 분산 비중이고, “Cumulative Proportion”은 설명된 분산 비중을 누계한 것이다. 아래 결과를 보면, 처음 5개 주성분이 데이터 전체 분산의 31.8%를 설명한다. 이 비율 자체는 그다지 크지 않지만, 원래의 변수 개수가 총 6,830개나 된다는 점을 감안해야 한다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pca_score</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
     <span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">[:</span><span class="mi">5</span><span class="p">],</span>
     <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">[:</span><span class="mi">5</span><span class="p">])],</span>
    <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Standard Deviation&#39;</span><span class="p">,</span> <span class="s1">&#39;Proportion of Variance&#39;</span><span class="p">,</span> <span class="s1">&#39;Cumulative Proportion&#39;</span><span class="p">],</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;PC1&#39;</span><span class="p">,</span> <span class="s1">&#39;PC2&#39;</span><span class="p">,</span> <span class="s1">&#39;PC3&#39;</span><span class="p">,</span> <span class="s1">&#39;PC4&#39;</span><span class="p">,</span> <span class="s1">&#39;PC5&#39;</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PC1</th>
      <th>PC2</th>
      <th>PC3</th>
      <th>PC4</th>
      <th>PC5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Standard Deviation</th>
      <td>27.853469</td>
      <td>21.481355</td>
      <td>19.820465</td>
      <td>17.032556</td>
      <td>15.971807</td>
    </tr>
    <tr>
      <th>Proportion of Variance</th>
      <td>0.113589</td>
      <td>0.067562</td>
      <td>0.057518</td>
      <td>0.042476</td>
      <td>0.037350</td>
    </tr>
    <tr>
      <th>Cumulative Proportion</th>
      <td>0.113589</td>
      <td>0.181151</td>
      <td>0.238670</td>
      <td>0.281145</td>
      <td>0.318495</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>이번에는 각 주성분의 PVE(설명된 분산 비중)를 <strong>스크리 그림</strong>(scree plot: 산비탈 그림)으로 표현한 것이 왼쪽 그림이고, 오른쪽에는 “누적 PVE”를 그린 것이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span><span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>

<span class="c1"># 왼쪽 그림</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Proportion of Variance Explained&#39;</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">12</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymin</span><span class="o">=-</span><span class="mf">0.01</span><span class="p">)</span>

<span class="c1"># 오른쪽 그림</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">),</span> <span class="s1">&#39;-ro&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Cumulative Proportion of Variance Explained&#39;</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">12</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymax</span><span class="o">=</span><span class="mf">1.05</span><span class="p">)</span>

<span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">fig</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Principal Component&#39;</span><span class="p">,</span> <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">12</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">65</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/f8cccaba8f177ce23f0036656378ed4271e6fccf2264d6e09aa6b7b031eea700.png" src="../_images/f8cccaba8f177ce23f0036656378ed4271e6fccf2264d6e09aa6b7b031eea700.png" />
</div>
</div>
<p>위 결과를 보면, 처음 7개 주성분이 데이터 전체 분산의 약 40%를 설명한다는 것을 알 수 있다. 물론 40%가 큰 값은 아니다. 그러나 원래 데이터에 6,830개의 변수가 있다는 점을 감안해야 한다. 왼쪽 스크리 그림을 보면, 처음 7개의 주성분이 상당 양의 분산을 설명하며, 그 다음부터는 추가적인 주성분에 의해 설명되는 분산이 현저하게 줄어드는 것을 알 수 있다. 즉, 그림에서 대략 7번째 주성분을 경계로 꺾이는 소위 “엘보우(elbow)” 형태를 보인다. 이것은 7개보다 많은 주성분을 활용하는 것이 거의 이익이 없을 수 있음을 시사한다(7개의 주성분을 분석하는 것조차 어려울 수 있음).</p>
</section>
</section>
<section id="id9">
<h2>16.7 손글씨 데이터: 노이즈 필터링<a class="headerlink" href="#id9" title="Link to this heading">#</a></h2>
<p>코드 출처: <a class="reference external" href="https://jakevdp.github.io/PythonDataScienceHandbook/05.09-principal-component-analysis.html">In Depth: Principal Component Analysis</a></p>
<section id="id10">
<h3>데이터세트<a class="headerlink" href="#id10" title="Link to this heading">#</a></h3>
<p>차원축소의 유용성은 고차원 데이터를 보면 훨씬 더 명확해진다. 이를 확인하기 위해 15장에서 다뤘던 것과 유사한 손글씨 숫자 데이터에 PCA를 적용해보자. 데이터는 사이킷런(Scikit-Learn) 라이브러리에 내장된 데이터를 사용한다. 우선 <code class="docutils literal notranslate"><span class="pre">load_digits</span></code> 모듈을 불러들인 다음, 이것을 <code class="docutils literal notranslate"><span class="pre">digits</span></code>라는 이름으로 지정한다. 이 상황에서 <code class="docutils literal notranslate"><span class="pre">digits</span></code> 객체에 <code class="docutils literal notranslate"><span class="pre">images</span></code> 속성(attribute)을 적용하면 이미지 데이터세트를 얻는다. 이미지 데이터는 3차원 배열로서 1,797개의 관측이 있고, 각 관측은 <span class="math notranslate nohighlight">\(8\times8\)</span> 픽셀 이미지로 구성돼있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_digits</span>

<span class="n">digits</span> <span class="o">=</span> <span class="n">load_digits</span><span class="p">()</span>
<span class="n">digits</span><span class="o">.</span><span class="n">images</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1797, 8, 8)
</pre></div>
</div>
</div>
</div>
<p>우선 데이터세트에서 처음 100개의 손글씨를 시각화해보자. 각 이미지마다 왼쪽 하단에 초록색의 작은 숫자가 있는데 이것이 해당 손글씨가 의미하는 숫자이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                         <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:[],</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:[]},</span>
                         <span class="n">gridspec_kw</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/2e312ee308bd48d3f97eba3abd99938f67d3ffdb2a7d3509e5f738a081fca106.png" src="../_images/2e312ee308bd48d3f97eba3abd99938f67d3ffdb2a7d3509e5f738a081fca106.png" />
</div>
</div>
<p>Scikit-Learn 내에서 이 데이터로 작업하려면 각 이미지의 픽셀 배열을 <span class="math notranslate nohighlight">\(8\times8\)</span>의 2차원 형태가 아니라 첫 번째 행부터 차례대로 붙여나감으로써 전체 8개 행을 하나의 벡터로 만드는 소위 평면화(flattening)를 하여 64개의 픽셀 별로 값을 갖도록 배치하는 것이 필요하다. 또한 각 이미지에 대해 그것이 어떤 숫자에 속하는지 레이블을 제공하는 목표(target) 변수가 필요하다. 우리가 사용하고 있는 <code class="docutils literal notranslate"><span class="pre">load_digits</span></code> 모듈의 경우, 이 두 가지 작업을 따로 코딩할 필요없이 해당 모듈의 <code class="docutils literal notranslate"><span class="pre">data</span></code> 및 <code class="docutils literal notranslate"><span class="pre">target</span></code>이라는 속성을 사용하면 된다. 즉 <code class="docutils literal notranslate"><span class="pre">digits.data</span></code>는 픽셀 배열이 평면화된 64개 변수를 가진 데이터이고, <code class="docutils literal notranslate"><span class="pre">digits.target</span></code>은 각 손글씨 관측이 어떤 숫자에 속하는지를 알려주는 데이터이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>((1797, 64), (1797,))
</pre></div>
</div>
</div>
</div>
</section>
<section id="pca">
<h3>노이즈 필터링 PCA<a class="headerlink" href="#pca" title="Link to this heading">#</a></h3>
<p>PCA는 노이즈가 있는 데이터에 대한 필터링 도구로도 사용할 수 있다. 아이디어는 다음과 같다. 큰 변동을 가진 주성분일수록 노이즈의 영향을 훨씬 덜 받게 된다. 따라서 처음 몇 개의 주요 주성분만 사용하여 데이터를 재구성하는 경우, 노이즈를 제거하면서도 보유 정보를 상당 부분 보존할 수 있을 것이다.</p>
<p>먼저 픽셀 정보를 이미지로 바꿔주는 함수(<code class="docutils literal notranslate"><span class="pre">plot_digits</span></code>)를 만든다. 그런 다음, 노이즈가 없는 입력 데이터 중 처음 20개의 이미지를 봐보자.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_digits</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                             <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:[],</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:[]},</span>
                             <span class="n">gridspec_kw</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">0.1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                  <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                  <span class="n">clim</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
        <span class="n">transform</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">)</span>
<span class="n">plot_digits</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/4df260825e3bbb0e29ad6ec23199b65907145fc7685991b9f8043c47d5d32a81.png" src="../_images/4df260825e3bbb0e29ad6ec23199b65907145fc7685991b9f8043c47d5d32a81.png" />
</div>
</div>
<p>이제 주어진 데이터세트에 무작위 노이즈를 추가해보자. 아래 코딩에서 <code class="docutils literal notranslate"><span class="pre">np.random.normal(digits.data,</span> <span class="pre">4)</span></code>은 노이즈가 없는 원래의 데이터에 평균이 0이고 표준편차가 4인 정규분포에서 무작위 숫자를 발생시켜 더한 것이다. 그렇게 하여 만든 데이터세트를 <code class="docutils literal notranslate"><span class="pre">noisy</span></code>란 이름으로 지정하고 이를 다시 그림으로 그린다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="n">noisy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">plot_digits</span><span class="p">(</span><span class="n">noisy</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/bb1b59c58178796290b44266b85aa1fd7d507def473563315c7d4afa456c5088.png" src="../_images/bb1b59c58178796290b44266b85aa1fd7d507def473563315c7d4afa456c5088.png" />
</div>
</div>
<p>결과를 보면, 이미지에 가짜 픽셀이 포함되어 노이즈가 생긴 것을 확인할 수 있다.</p>
<p>이제 <code class="docutils literal notranslate"><span class="pre">PCA(0.50)</span></code>으로 지정함으로써 주성분이 분산의 50%를 설명하도록 설정했다.(50% 수준은 대략적으로 정한 것임.) 주성분이 분산의 50%를 설명하도록 하기 위해서는 몇 개의 주성분이 필요한지 <code class="docutils literal notranslate"><span class="pre">n_components_</span></code> 속성을 이용해 알아보자.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="mf">0.50</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">noisy</span><span class="p">)</span>
<span class="n">pca</span><span class="o">.</span><span class="n">n_components_</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>12
</pre></div>
</div>
</div>
</div>
<p>위 결과는 데이터세트 분산의 50%를 설명하기 위해서는 12개의 주성분이 필요하다는 것을 말해준다. 따라서 먼저 <code class="docutils literal notranslate"><span class="pre">fit_transform</span></code> 메서드를 이용해 처음 12개 주성분 점수를 계산한다. 그런 다음 <code class="docutils literal notranslate"><span class="pre">inverse_transform</span></code> 메서드를 사용해 계산된 주성분 점수를 원래의 차원으로 역변환함으로써 필터링된 숫자를 재구성하여 이를 그림으로 그린다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">components</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">noisy</span><span class="p">)</span>
<span class="n">filtered</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
<span class="n">plot_digits</span><span class="p">(</span><span class="n">filtered</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/d1c35c769b83755e61a0ec0dc48fc3ecf4a169cbd36b81a861447b7df3addd3e.png" src="../_images/d1c35c769b83755e61a0ec0dc48fc3ecf4a169cbd36b81a861447b7df3addd3e.png" />
</div>
</div>
<p>위 결과를 보면, PCA의 노이즈 필터링(신호 보존) 기능이 상당히 잘 작동한 것으로 여겨진다. 즉, 주성분을 이용해 데이터세트의 노이즈를 잘 제거한 것이다.</p>
<p>위 예를 통해, PCA가 매우 유용한 변수 선택 루틴으로 활용될 수 있을 것으로 짐작할 수 있다. 예를 들어, 분류기(classifier)를 매우 고차원 데이터에 대해 훈련시키는 대신, PCA로 노이즈를 필터링하는 단계를 자동으로 거치게 함으로써 분류기를 저차원 표현에 대해 훈련시키는 것이다.</p>
</section>
</section>
<section id="mnist">
<h2>16.8 MNIST 데이터: 주성분 회귀<a class="headerlink" href="#mnist" title="Link to this heading">#</a></h2>
<p>코드 출처: <a class="reference external" href="https://towardsdatascience.com/pca-using-python-scikit-learn-e653f8989e60">PCA using Python (scikit-learn)</a></p>
<p>지금까지는 비지도학습으로서의 PCA 기법에 대해 살펴보았다. 그런데 맨 앞에서도 언급했듯이 PCA는 지도학습에서도 유용하게 활용될 수 있다. 대표적으로 입력변수가 너무 많아 학습 알고리즘이 너무 느린 경우, PCA를 사용하여 차원을 축소함으로써 학습 속도를 높이는 방법을 생각해볼 수 있다. 여기에서는 이것을 15장 딥러닝에서 다루었던 MNIST 데이터세트에 대해 PCA를 적용해보기로 한다.</p>
<p>15장에서 우리는 MNIST 손글씨 분류를 로지스틱 회귀 모델로 수행한 적이 있다. 그런데 모델은 로지스틱 회귀였지만, 효율적인 추정을 위해 신경망 추정 기법을 이용했다. 원래 다항(multinomial) 로지스틱 모델은 사이킷런의 <code class="docutils literal notranslate"><span class="pre">LogisticRegression</span></code> 함수를 사용해서 추정하나, 15장에서는 그 대신 <code class="docutils literal notranslate"><span class="pre">keras</span></code>의 신경망 추정 기법으로 로지스틱 모델을 피팅했다. 그렇게 했던 이유는 추정해야 하는 계수가 너무 많기 때문이다. MNIST 손글씨 분류 문제의 경우, 입력변수가 784개(상수항까지 포함하면 785개)나 되고, 출력변수의 클래스도 10개나 되기 때문에 추정 계수의 숫자가 총 7,850개나 된다. 이런 경우에 PCA를 활용하여 입력변수의 차원을 대폭 줄일 수 있다면, (<code class="docutils literal notranslate"><span class="pre">LogisticRegression</span></code> 함수를 사용하더라도) 모델 피팅에 걸리는 시간을 대폭 줄일 수 있을 것이다. 메모리 공간에 제약이 있을 경우, PCA는 데이터 정보의 일부 손실을 감수하는 대신 메모리 공간과 실행 시간을 절약할 수 있는 합리적인 절충안이 될 수 있다.</p>
<section id="id11">
<h3>주성분 회귀<a class="headerlink" href="#id11" title="Link to this heading">#</a></h3>
<p>앞에서 여러 차례 보았듯이, 회귀 분석에서 반응변수 <span class="math notranslate nohighlight">\(Y\)</span>와 예측변수 <span class="math notranslate nohighlight">\(X_1,X_2,...,X_p\)</span>가 주어졌을 때, 이들의 관계를 설명하는 표준적인 선형 모델은 다음과 같다.</p>
<div class="math notranslate nohighlight">
\[
Y = \beta_0 + \beta_{1}X_1 + \dots + \beta_{p}X_p  + \epsilon \tag{16.6}
\]</div>
<p>우리는 9장(선형모형 변수선택 및 정규화)에서 원래(original) 변수의 부분집합을 사용하는 방법, 그리고 계수를 0으로 줄이는 소위 “정규화”의 방법으로 추정 계수의 분산을 제어하고자 했다. 부분집합 선택이든 정규화 기법이든 이러한 방법들은 원래의 예측변수 <span class="math notranslate nohighlight">\(X_1,X_2,...,X_p\)</span>를 변환시키지 않고 그대로 사용하는 접근법이라는 점에서는 동일하다.</p>
<p>반면, 여기에서 다룰 PCA에 의한 <strong>차원축소</strong>(dimension reduction) 기법은 원래의 예측변수를 그대로 사용하는 것이 아니라 이들 예측변수를 주성분 변수로 <strong>변환</strong>(transform)한 다음, 그중 일부 주요 주성분 변수를 사용하여 최소제곱 모델을 피팅하는 접근 방식이다. 이를 식으로 표현해보면, 우선 <span class="math notranslate nohighlight">\(Z_1,Z_2,...,Z_m\)</span>은 다음과 같이 <span class="math notranslate nohighlight">\(p\)</span>개 예측변수의 선형결합으로 만든 <span class="math notranslate nohighlight">\(m(&lt; p)\)</span>개의 (선택된) 주요 주성분 변수이다.</p>
<div class="math notranslate nohighlight">
\[
Z_j = \phi_{1j}X_1 + \phi_{2j}X_2 + \dots + \phi_{pj}X_p \tag{16.7}
\]</div>
<p>여기에서 <span class="math notranslate nohighlight">\(j = 1,...,m\)</span>이고, <span class="math notranslate nohighlight">\(\phi_{1j},\phi_{2j},...,\phi_{pj}\)</span>은 상수이다. <strong>주성분 회귀</strong>(PCR: principal components regression)는 주성분 변수 <span class="math notranslate nohighlight">\(Z_1,Z_2,...,Z_m\)</span>을 구한 후, 다음과 같은 선형 회귀 모델을 최소제곱으로 피팅한다.</p>
<div class="math notranslate nohighlight">
\[
Y = \theta_0 + \theta_{1}Z_1 + \theta_{2}Z_2 + \dots + \theta_{m}Z_m  + \epsilon \tag{16.8}
\]</div>
<p>주요 주성분이 잘 도출되면, 위와 같은 차원축소 접근 방식이 원래의 최소제곱 회귀보다 더 좋은 성과를 제공할 수도 있다. 즉, 식 16.6 대신 식 16.8을 최소제곱으로 피팅함으로써 메모리나 시간을 절약하는 것은 물론이고, <span class="math notranslate nohighlight">\(Y\)</span>를 예측하는 데 있어서도 오히려 더 나은 결과를 가져다 주기도 한다.</p>
<p>차원축소라는 용어는 이 접근 방식이 <span class="math notranslate nohighlight">\(\beta_{0},\beta_{1},...,\beta_{p}\)</span>를 추정하는 문제를 <span class="math notranslate nohighlight">\(\theta_1,\theta_2,...,\theta_m\)</span>을 추정하는 더 간단한 문제로 축소시킨다는 사실에서 비롯된 것이다. 즉 <span class="math notranslate nohighlight">\(m &lt; p\)</span>으로서 계수의 차원이 <span class="math notranslate nohighlight">\(p + 1\)</span>에서 <span class="math notranslate nohighlight">\(m + 1\)</span>로 축소되었다.</p>
</section>
<section id="keras">
<h3>Keras 및 데이터세트 불러들이기<a class="headerlink" href="#keras" title="Link to this heading">#</a></h3>
<p>MNIST 데이터베이스에는 60,000개의 훈련 이미지와 10,000개의 테스트 이미지가 들어있다. 데이터베이스에 총 70,000개의 손글씨 숫자들이 들어있다. 여기에서 우리의 목표는 다항 로지스틱 모델로 손글씨 숫자 이미지를 올바르게 분류하는 모델을 구축하는 것이다.</p>
<p>파이썬에 텐서플로(TensorFlow)가 설치돼 있지 않으면 아나콘다 프롬프트 창에서 다음 명령문을 실행하여 텐서플로를 설치한다. 텐서플로는 구글에서 개발한 기계학습 및 인공지능을 위한 무료 오픈 소스 소프트웨어 라이브러리이다.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(base) C:\Users\pilsu&gt;pip install tensorflow
</pre></div>
</div>
<p>설치가 끝났으면 주피터 노트북에서 아래와 같이 <code class="docutils literal notranslate"><span class="pre">mnist</span></code>를 불러들인다. <code class="docutils literal notranslate"><span class="pre">keras</span></code> 패키지에는 여러 예제 데이터세트가 들어있는데, MNIST 데이터베이스도 <code class="docutils literal notranslate"><span class="pre">mnist</span></code>라는 이름으로 들어있다. 아래 코드로 데이터세트를 로드하면, <code class="docutils literal notranslate"><span class="pre">train_img</span></code>, <code class="docutils literal notranslate"><span class="pre">train_lbl</span></code>, <code class="docutils literal notranslate"><span class="pre">test_img</span></code>, <code class="docutils literal notranslate"><span class="pre">test_lbl</span></code>라는 4개의 변수가 생긴다. 여기서 <code class="docutils literal notranslate"><span class="pre">img</span></code>는 손글씨 이미지 데이터이고 <code class="docutils literal notranslate"><span class="pre">lbl</span></code>은 출력변수로서 각 숫자 이미지가 어떤 숫자를 나타내는지를 분류해놓은 클래스(레이블)이다. <code class="docutils literal notranslate"><span class="pre">img</span></code> 변수의 훈련 데이터(<code class="docutils literal notranslate"><span class="pre">train_img</span></code>)와 테스트 데이터(<code class="docutils literal notranslate"><span class="pre">test_img</span></code>)는 각각 60,000개와 10,000개 이미지에 대한 픽셀 정보이며, 모든 이미지는 동일한 크기(<span class="math notranslate nohighlight">\(28\times28\)</span> 픽셀)로 돼있다. 즉 <code class="docutils literal notranslate"><span class="pre">img</span></code> 데이터세트는 훈련 세트와 테스트 세트 모두 3차원 배열(array)로서 훈련 세트의 형태는 <span class="math notranslate nohighlight">\(60,000\times28\times28\)</span>이고, 테스트 세트는 <span class="math notranslate nohighlight">\(10,000\times28\times28\)</span>이다. 이에 반해 <code class="docutils literal notranslate"><span class="pre">lbl</span></code> 데이터세트는 훈련 세트와 테스트 세트 모두 관측별로 클래스 레이블(target label)만 들어있는 1차원 배열이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">keras.datasets</span> <span class="kn">import</span> <span class="n">mnist</span>
<span class="p">(</span><span class="n">train_img</span><span class="p">,</span> <span class="n">train_lbl</span><span class="p">),(</span><span class="n">test_img</span><span class="p">,</span> <span class="n">test_lbl</span><span class="p">)</span> <span class="o">=</span> <span class="n">mnist</span><span class="o">.</span><span class="n">load_data</span><span class="p">()</span>
<span class="n">train_img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">train_lbl</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">test_img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">test_lbl</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>((60000, 28, 28), (60000,), (10000, 28, 28), (10000,))
</pre></div>
</div>
</div>
</div>
<p><strong>픽셀 정보 평면화</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">img</span></code> 데이터세트의 각 숫자 이미지는 <span class="math notranslate nohighlight">\(28\times28=784\)</span> 픽셀에 대해 회색조 스케일 값을 지니고 있다. 이렇게 각 숫자 이미지에 대해 2차원으로 기록된 픽셀 데이터를 첫 번째 행부터 차례대로 붙여나감으로써 전체 28개 행을 하나의 벡터로 만드는 소위 평면화를 실행한다. 이 작업은 아래와 같이 <code class="docutils literal notranslate"><span class="pre">numpy</span></code>의 <code class="docutils literal notranslate"><span class="pre">reshape</span></code> 함수를 사용하면 된다. <code class="docutils literal notranslate"><span class="pre">np.reshape(train_img,</span> <span class="pre">(60000,</span> <span class="pre">784))</span></code>은 <code class="docutils literal notranslate"><span class="pre">train_img</span></code> 데이터세트의 60,000개 관측 각각의 픽셀 정보 형태(shape)를 784개 원소를 가진 배열로 평면화하라는 것이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">train_img</span><span class="p">,</span> <span class="p">(</span><span class="mi">60000</span><span class="p">,</span> <span class="mi">784</span><span class="p">))</span>
<span class="n">test_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">test_img</span><span class="p">,</span> <span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">784</span><span class="p">))</span>
<span class="n">train_img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">train_lbl</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">test_img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">test_lbl</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>((60000, 784), (60000,), (10000, 784), (10000,))
</pre></div>
</div>
</div>
</div>
</section>
<section id="id12">
<h3>다항 로지스틱 회귀<a class="headerlink" href="#id12" title="Link to this heading">#</a></h3>
<p>아래 명령문은 먼저 사이킷런에서 <code class="docutils literal notranslate"><span class="pre">LogisticRegression</span></code> 함수를 불러들여 최적화 관련 옵션을 설정하고, 모델명을 <code class="docutils literal notranslate"><span class="pre">logisticRegr</span></code>으로 지정했다. 우선 피팅의 최적화 알고리즘으로서 (기본 알고리즘으로 설정돼 있는) <code class="docutils literal notranslate"><span class="pre">lbfgs</span></code>를 선택했다. 이는 quasi-Newton 방법에 속하는 Broyden-Fletcher-Goldfarb-Shanno 알고리즘을 사용하는 최적화 알고리즘이다. 최적화는 반복적 수치최적화(iterative numerical optimization) 방법으로 진행되는데, 우리는 최대반복횟수(<code class="docutils literal notranslate"><span class="pre">max_iter</span></code>)를 10,000번으로 설정했다. 그렇게 하여 로지스틱 모델(<code class="docutils literal notranslate"><span class="pre">logisticRegr</span></code>)을 MNIST 훈련 세트(<code class="docutils literal notranslate"><span class="pre">train_img</span></code> 및 <code class="docutils literal notranslate"><span class="pre">train_lbl</span></code>)에 피팅시켰다.</p>
<p>한편 피팅에 걸리는 시간을 재기 위해 <code class="docutils literal notranslate"><span class="pre">time</span></code> 모듈을 불러들여 로지스틱 회귀의 시작 시점과 끝나는 시점의 시간을 측정했다. <code class="docutils literal notranslate"><span class="pre">time.time()</span></code>은 인터프리터가 실행되는 시점을 소수점 숫자로 반환한다.</p>
<p><img alt="다항 로지스틱 회귀" src="https://raw.githubusercontent.com/pilsunchoi/images/main/16-5.png" /></p>
<p>위 결과를 보면, 피팅 작업을 25분가량 수행했지만, 정해진 최적화 기준에 도달하지 못한 채, 최대반복횟수(<code class="docutils literal notranslate"><span class="pre">max_iter</span></code>) 10,000번을 초과함으로써 최적화 작업이 중단된 것을 알 수 있다. 경고 문구인 “ConvergenceWarning: lbfgs failed to converge (status=1): STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.”이 그것을 의미한다. <code class="docutils literal notranslate"><span class="pre">LogisticRegression</span></code> 함수의 최대반복횟수의 기본값(default)이 100인데, 우리는 그것을 10,000으로 늘렸음에도 불구하고 최적화에 도달하지 못한 것이다. 이는 추정해야 하는 변수의 개수가 너무 많기 때문일 것이다. 이 점에서 PCA에 의해 변수 개수를 축소할 필요성이 제기된다.</p>
<p><strong>모델 정확도</strong></p>
<p>최적화가 도중에 중단됐음에도 불구하고, 어찌됐든 위의 피팅 결과를 바탕으로 테스트 세트의 처음 10개 손글씨에 대해 모델의 정확도를 체크해보았다. 각 손글씨 이미지가 0에서 9까지의 숫자 중 어디에 속하는지 <code class="docutils literal notranslate"><span class="pre">LogisticRegression</span></code>의 <code class="docutils literal notranslate"><span class="pre">predict</span></code> 메서드로 예측한 다음, 그것을 실제값과 비교했다. 아래 결과를 보면 10개 이미지 중 아홉 번째를 제외하고는 모두 올바르게 예측됐음을 알 수 있다.</p>
<p><img alt="모델 정확도" src="https://raw.githubusercontent.com/pilsunchoi/images/main/16-6.png" /></p>
<p>이번에는 <code class="docutils literal notranslate"><span class="pre">LogisticRegression</span></code>의 <code class="docutils literal notranslate"><span class="pre">score</span></code> 메서드를 이용해 테스트 세트의 10,000개 손글씨 전체에 대해 예측 정확도를 구한 결과, 92.08%가 나왔다. 즉 오류율이 7.92%이다.</p>
<p><img alt="예측 정확도" src="https://raw.githubusercontent.com/pilsunchoi/images/main/16-7.png" /></p>
</section>
<section id="id13">
<h3>다항 로지스틱 주성분 회귀<a class="headerlink" href="#id13" title="Link to this heading">#</a></h3>
<p>동일한 MNIST 데이터세트 손글씨 인식 작업을 이번에는 로지스틱 <strong>주성분 회귀</strong>로 시도해보자. 다른 부분은 앞의 일반적인 로지스틱 회귀와 모두 동일하고, 입력변수를 원래의 784개 픽셀 정보 대신 PCA를 통해 도출한 주요 주성분 변수를 사용한다는 점만 다르다.</p>
<p><strong>데이터 표준화</strong></p>
<p>우리는 PCA를 입력변수 세트인 이미지(<code class="docutils literal notranslate"><span class="pre">img</span></code>) 데이터세트에 대해 적용하기 때문에, <code class="docutils literal notranslate"><span class="pre">train_img</span></code>와 <code class="docutils literal notranslate"><span class="pre">test_img</span></code>의 두 가지 데이터세트를 표준화시킨다(출력변수는 표준화시키지 않음). 단, 이때 (테스트 세트는 사전에 주어지지 않는 것으로 간주해야 하기 때문에) 훈련 세트에 대한 표준화 피팅을 테스트 세트에도 그대로 적용한다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
<span class="c1"># 훈련 세트에만 피팅을 하고</span>
<span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_img</span><span class="p">)</span>
<span class="c1"># 그것을 훈련 세트 및 테스트 세트에 동일하게 적용함</span>
<span class="n">train_img</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">train_img</span><span class="p">)</span>
<span class="n">test_img</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">test_img</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>설명된 분산 비중 80%로 설정</strong></p>
<p>이제 <code class="docutils literal notranslate"><span class="pre">PCA(0.80)</span></code>로 지정함으로써 주성분이 분산의 80%를 설명하도록 주성분을 선택한다(80% 수준은 대략적으로 정한 것임). 아래 결과를 보면, 이 경우 149개의 주성분이 필요한 것으로 나타났다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="mf">0.80</span><span class="p">)</span>
<span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_img</span><span class="p">)</span>
<span class="n">pca</span><span class="o">.</span><span class="n">n_components_</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>149
</pre></div>
</div>
</div>
</div>
<p><strong>이미지 데이터세트를 주성분 변수로 대체</strong></p>
<p>이제 훈련 이미지(<code class="docutils literal notranslate"><span class="pre">train_img</span></code>) 세트로부터 도출한 PCA 정보를 바탕으로 이미지 데이터세트의 훈련 세트(<code class="docutils literal notranslate"><span class="pre">train_img</span></code>)와 테스트 세트(<code class="docutils literal notranslate"><span class="pre">test_img</span></code>) 모두에 대해 <code class="docutils literal notranslate"><span class="pre">transform</span></code> 메서드를 이용해 처음 149개 주성분 점수를 계산한다. 훈련 이미지 세트의 주성분 점수(<code class="docutils literal notranslate"><span class="pre">train_pca_img</span></code>)는 곧이어 실행할 로지스틱 주성분 회귀에 필요한 것이고, 테스트 이미지 세트의 주성분 점수(<code class="docutils literal notranslate"><span class="pre">test_pca_img</span></code>)는 모델의 정확도를 평가하는 데 필요하다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train_pca_img</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">train_img</span><span class="p">)</span>
<span class="n">test_pca_img</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">test_img</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>로지스틱 주성분 회귀 실행</strong></p>
<p>앞에서와 마찬가지로 <code class="docutils literal notranslate"><span class="pre">LogisticRegression</span></code> 함수를 사용하는데, 최적화 관련 옵션을 앞에서와 동일하게 설정했다. 즉 피팅의 최적화 알고리즘으로서 <code class="docutils literal notranslate"><span class="pre">lbfgs</span></code>를 선택하고, 최대반복횟수(<code class="docutils literal notranslate"><span class="pre">max_iter</span></code>)를 10,000번으로 설정했다. 그렇게 하여 로지스틱 모델(<code class="docutils literal notranslate"><span class="pre">logisticRegr</span></code>)을 훈련 세트(<code class="docutils literal notranslate"><span class="pre">train_pca_img</span></code> 및 <code class="docutils literal notranslate"><span class="pre">train_lbl</span></code>)에 피팅시켰다. 이때 훈련 세트 중 이미지 세트는 주성분 변수로 변형시킨 데이터세트를 사용한다는 점이 앞의 일반적인 로지스틱 회귀와 다른 점이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="n">logisticRegr</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">solver</span> <span class="o">=</span> <span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">logisticRegr</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_pca_img</span><span class="p">,</span> <span class="n">train_lbl</span><span class="p">)</span>

<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">m</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">((</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">),</span> <span class="mi">60</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;minute(s) &quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="s2">&quot;seconds&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.0 minute(s)  9.88 seconds
</pre></div>
</div>
</div>
</div>
<p>위 결과를 보면, 최적화에 걸린 시간이 매우 짧다. 앞에서 PCA를 사용하지 않고 로지스틱 회귀를 실행한 것과는 실행 시간 면에서 크게 비교가 된다. PCA를 통해 추정 계수의 개수를 크게 줄인 것이 이러한 차이를 낳는 가장 큰 요인일 것이다. 그렇다면 이처럼 추정에 있어서의 효율성을 얻는 대신, 예측의 정확도 면에서 얼마만큼의 손실이 발생했는지 확인해볼 필요가 있다.</p>
<p><strong>모델 정확도</strong></p>
<p>앞에서와 마찬가지로 (주성분 회귀) 피팅 결과를 바탕으로 테스트 세트의 처음 10개 손글씨에 대해 모델의 정확도를 체크해보았다. 각 손글씨 이미지가 0에서 9까지의 숫자 중 어디에 속하는지 <code class="docutils literal notranslate"><span class="pre">predict</span></code> 메서드로 예측한 다음, 그것을 실제값과 비교해보자. 이때 앞에서 만들어 놓은 <code class="docutils literal notranslate"><span class="pre">test_pca_img</span></code> 데이터세트를 사용해야 한다. 즉 테스트 이미지 세트를 그대로 사용하는 것이 아니라 훈련 이미지 세트에 대한 주성분 분석을 바탕으로 테스트 이미지 세트를 주성분 점수로 변형시킨 데이터세트이다.</p>
<p>아래 결과를 보면 10개 이미지 중 아홉 번째를 제외하고는 모두 올바르게 예측됐음을 알 수 있다. 이는 앞에서 PCA를 사용하지 않은 로지스틱 회귀 모델과 동일한 결과이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Predict:&quot;</span><span class="p">,</span> <span class="n">logisticRegr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_pca_img</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;True   :&quot;</span><span class="p">,</span> <span class="n">test_lbl</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Predict: [7 2 1 0 4 1 4 9 6 9]
True   : [7 2 1 0 4 1 4 9 5 9]
</pre></div>
</div>
</div>
</div>
<p>이번에는 <code class="docutils literal notranslate"><span class="pre">score</span></code> 메서드를 이용해 테스트 세트의 10,000개 손글씨 전체에 대해 예측 정확도를 구했다. 아래 결과를 보면 92.55%이다. 즉 오류율이 7.45%로서 앞의 PCA를 사용하지 않은 로지스틱 회귀 모델(오류율 7.92%)보다 오히려 약간 낮은 수준이다. 즉 PCA를 통해 입력변수의 차원을 대폭 줄임으로써 피팅의 속도를 대폭 단축했음에도 불구하고, 모델의 정확성 손실은 발생하지 않은 것이다. 주성분 회귀 모델의 오류율이 오히려 낮아진 것은 아마도 PCA를 사용하지 않은 로지스틱 회귀 모델의 경우 최적화 작업이 최대반복횟수 제한에 걸려 끝까지 수행되지 않았기 때문일 것이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">score</span> <span class="o">=</span> <span class="n">logisticRegr</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">test_pca_img</span><span class="p">,</span> <span class="n">test_lbl</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.9257
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="id14">
<h2>참고: PCA의 한계<a class="headerlink" href="#id14" title="Link to this heading">#</a></h2>
<p>출처: <a class="reference external" href="https://ekamperi.github.io/mathematics/2021/02/23/pca-limitations.html">Principal Component Analysis limitations and how to overcome them</a></p>
<p>빅데이터 시대에 PCA는 분명 널리 사용되는 유용한 차원축소 기법이지만, 몇 가지 한계점도 지니고 있다. 마지막으로 이를 간단히 정리했다.</p>
<ul class="simple">
<li><p>PCA를 적용하고 의미 있는 결과를 생성하려면 변수간 <strong>선형 상관관계</strong>(linear correlation)가 존재해야 한다.</p></li>
<li><p>PCA는 데이터세트 변수 간의 선형 관계에 의존한다. 그런데 상관성은 있지만 선형이 아니라 <strong>비선형 상관성</strong>이 존재하면 주성분 분석에서 얻는 이익에 한계가 있다.</p></li>
<li><p>PCA에서 주성분들은 서로 <strong>직교</strong>하는데, 상황에 따라서는 직교하지 않은 축이 오히려 데이터 요약에 훨씬 더 나을 수도 있다.</p></li>
<li><p>PCA에서는 <strong>분산</strong>이 데이터의 정보 존재에 대한 기준으로 사용된다. 하지만 때로는 분산이 낮은 곳에서 정보가 발견될 수도 있다.</p></li>
<li><p>PCA는 변수의 <strong>척도</strong>(scale)에 따라 결과가 달라진다. 큰 값을 가진 변수일수록 전체 분산에 더 많이 기여하는 방식으로 작동하기 때문이다.</p></li>
<li><p>PCA의 핵심은 데이터세트의 차원을 줄이는 것이다. 그런데 전체 주성분 중 <strong>몇 개의 주성분</strong>을 사용하는 것이 좋은지 기준을 정하기 어렵다. 자주 사용되는 접근 방식에는 스크리 그림에서 소위 “엘보우”를 찾는 시각적 검사, 그리고 주성분이 전체 분산의 가령 70%나 80% 이상을 설명하도록 하는 방법, 고유값이 1보다 큰 주성분을 선택하는 방법들이 있지만 어떤 기준이든 자의적인 측면이 존재할 수밖에 없다.</p></li>
<li><p>PCA의 또 다른 중요한 한계는 <strong>해석가능성</strong>(interpretability)이다. 원래 변수를 주성분으로 교체한 후에는 결과를 해석하는 것이 쉽지 않다. 주성분이 원래 변수의 선형결합으로 만든 것이기 때문이다. 때로는 주성분의 해석을 단순화하기 위해 PCA 후에 회전(rotation)을 적용할 수 있다. Varimax 회전이나 사각(oblique) 회전 등이 있지만, 이러한 회전에도 나름의 제한 사항이 있다.</p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./notebooks"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="15_%EB%94%A5%EB%9F%AC%EB%8B%9D_%EC%9E%85%EB%AC%B8.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">15장 딥러닝 입문</p>
      </div>
    </a>
    <a class="right-next"
       href="17_%EC%83%9D%EC%A1%B4%EB%B6%84%EC%84%9D.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">17장 생존분석</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">16.1 개요</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">16.2 주성분의 개념</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#chatgpt-q-a">ChatGPT Q&amp;A</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">16.3 주성분 도출</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">16.4 주성분 계산 단계별 설명</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-1">STEP 1:  표준화</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-2">STEP 2: 공분산 행렬</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-3">STEP 3: 공분산 행렬의 고유벡터와 고유값으로 주성분 식별</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-4">STEP 4: 주성분 선택</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#step-5">STEP 5: 주성분 축을 따라 데이터를 변환</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">16.5 파이썬으로 주성분 계산하기</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#usarrest">USArrest 데이터세트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iris">IRIS 데이터세트</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nci60">16.6 NCI60 데이터: 시각화</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">유전자 데이터 분석</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">주성분 분석</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">16.7 손글씨 데이터: 노이즈 필터링</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">데이터세트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pca">노이즈 필터링 PCA</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mnist">16.8 MNIST 데이터: 주성분 회귀</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">주성분 회귀</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#keras">Keras 및 데이터세트 불러들이기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">다항 로지스틱 회귀</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">다항 로지스틱 주성분 회귀</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">참고: PCA의 한계</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By 최필선 민인식
</p>

  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>