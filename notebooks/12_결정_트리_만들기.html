
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>12장 결정 트리 만들기 &#8212; 데이터과학의 첫걸음</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b76e3c8a" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/12_결정_트리_만들기';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="13장 트리 기반 모형" href="13_%ED%8A%B8%EB%A6%AC_%EA%B8%B0%EB%B0%98_%EB%AA%A8%ED%98%95.html" />
    <link rel="prev" title="11장 추천 시스템" href="11_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="00_%EC%84%9C%EB%AC%B8.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="데이터과학의 첫걸음 - Home"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="데이터과학의 첫걸음 - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="00_%EC%84%9C%EB%AC%B8.html">
                    데이터과학의 첫걸음: 시작하며
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="01_%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0.html">1장 파이썬 시작하기</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EC%BD%94%EB%94%A9_%EA%B8%B0%EC%B4%88.html">2장 파이썬 코딩 기초</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_%EC%9D%80%ED%96%89_%ED%85%94%EB%A0%88%EB%A7%88%EC%BC%80%ED%8C%85_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B6%84%EC%84%9D.html">3장 은행 텔레마케팅 데이터 분석</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_%EC%A0%84%EC%9E%90%EC%83%81%EA%B1%B0%EB%9E%98_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B6%84%EC%84%9D.html">4장 전자상거래 데이터 분석</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_%ED%86%B5%EA%B3%84%EC%A0%81_%ED%95%99%EC%8A%B5.html">5장 통계적 학습</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_%EC%84%A0%ED%98%95_%ED%9A%8C%EA%B7%80.html">6장 선형 회귀</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_%EB%A1%9C%EC%A7%80%EC%8A%A4%ED%8B%B1_%ED%9A%8C%EA%B7%80%EB%A5%BC_%EC%9D%B4%EC%9A%A9%ED%95%9C_%EB%B6%84%EB%A5%98.html">7장 로지스틱 회귀를 이용한 분류</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_KNN%EC%9D%84_%EC%9D%B4%EC%9A%A9%ED%95%9C_%EB%B6%84%EB%A5%98.html">8장 KNN 분류</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_%EB%82%98%EC%9D%B4%EB%B8%8C_%EB%B2%A0%EC%9D%B4%EC%A6%88_%EB%B6%84%EB%A5%98.html">9장 나이브 베이즈 분류</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_%EB%B3%80%EC%88%98%EC%84%A0%ED%83%9D_%EB%B0%8F_%EC%A0%95%EA%B7%9C%ED%99%94.html">10장 변수선택 및 정규화</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C.html">11장 추천 시스템</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">12장 결정 트리 만들기</a></li>
<li class="toctree-l1"><a class="reference internal" href="13_%ED%8A%B8%EB%A6%AC_%EA%B8%B0%EB%B0%98_%EB%AA%A8%ED%98%95.html">13장 트리 기반 모형</a></li>
<li class="toctree-l1"><a class="reference internal" href="14_%EC%84%9C%ED%8F%AC%ED%8A%B8_%EB%B2%A1%ED%84%B0_%EB%A8%B8%EC%8B%A0.html">14장 서포트 벡터 머신</a></li>
<li class="toctree-l1"><a class="reference internal" href="15_%EB%94%A5%EB%9F%AC%EB%8B%9D_%EC%9E%85%EB%AC%B8.html">15장 딥러닝 입문</a></li>
<li class="toctree-l1"><a class="reference internal" href="16_%EB%B9%84%EC%A7%80%EB%8F%84%ED%95%99%EC%8A%B5%EA%B3%BC_%EC%A3%BC%EC%84%B1%EB%B6%84_%EB%B6%84%EC%84%9D.html">16장 비지도학습과 주성분 분석</a></li>
<li class="toctree-l1"><a class="reference internal" href="17_%EC%83%9D%EC%A1%B4%EB%B6%84%EC%84%9D.html">17장 생존분석</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/pilsunchoi/book1" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/pilsunchoi/book1/issues/new?title=Issue%20on%20page%20%2Fnotebooks/12_결정_트리_만들기.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/notebooks/12_결정_트리_만들기.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>12장 결정 트리 만들기</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">12.1 결정 트리 소개</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">트리 기반 접근</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">12.2 회귀 트리 만들기</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">특성 공간의 계층화를 통한 예측</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">회귀 트리 만들기 간단한 예</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">회귀 트리 코딩</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">반복 이항 분할로 회귀 트리 만들기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tree-pruning">트리 가지치기(Tree Pruning)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">회귀 트리 예제</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">12.3 분류 트리 만들기</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">분류 트리 만들기 간단한 예</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">분류 트리 코딩</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">불순도 측정 도구</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">분류 트리 예제</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">트리의 장점과 단점</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">12.4 결정 트리 예제</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hitters">회귀 트리: Hitters 데이터세트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#heart">분류 트리: Heart 데이터세트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#chatgpt-q-a">ChatGPT Q&amp;A</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#carseats">분류 트리: Carseats 데이터세트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">가지치기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">가지치기 전후의 테스트 오류 비교</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>12장 결정 트리 만들기<a class="headerlink" href="#id1" title="Link to this heading">#</a></h1>
<p>자료 출처: <a class="reference external" href="https://www.statlearning.com/">ISLP (An Introduction to Statistical Learning with Applications in Python)</a></p>
<p>이 장에서는 <strong>(의사)결정 트리</strong>(decision tree)와 관련된 통계적 학습 기법을 설명한다. 결정 트리는 회귀(regression)와 분류(classification) 모두에 사용될 수 있다. 트리 기법은 선형 회귀나 로지스틱 회귀 등 전통적인 회귀 및 분류 기법과는 접근법이 약간 다르다. 사실 (트리를 어떻게 만드는지를 논외로 한다면) 트리를 이용한 회귀나 분류가 전통적 기법에 비해 훨씬 직관적이고 이해하기 쉽다.</p>
<section id="id2">
<h2>12.1 결정 트리 소개<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<p>우선 <strong>회귀 트리</strong>(regression tree)를 사용한 데이터 분석 사례를 통해 트리가 무엇인지, 그리고 몇 가지 관련 용어들을 익히기로 하자.</p>
<p><code class="docutils literal notranslate"><span class="pre">Hitters</span></code> 데이터세트에는 미국 메이저리그 프로야구 선수 263명의 연봉과 관련된 정보들이 들어있다. 여러 변수 중 <code class="docutils literal notranslate"><span class="pre">Years</span></code>(메이저리그 연차)와 <code class="docutils literal notranslate"><span class="pre">Hits</span></code>(전년도 안타 개수) 두 개만 사용하여 <strong>선수들의 연봉을 예측</strong>하는 모델을 만들고자 한다. 연봉 변수는 <code class="docutils literal notranslate"><span class="pre">Salary</span></code>인데, 여기에서는 원래의 연봉(단위: 1,000달러)에 자연로그를 취한 값을 사용한다.</p>
<p>만약 <strong>선형 회귀</strong> 모델로 선수들의 연봉을 예측한다면, 그 결과는 다음과 같은 형태일 것이다.</p>
<div class="math notranslate nohighlight">
\[\widehat{\text{Salary}} = \hat \beta_0 + \hat \beta_1 \text{Years}+ \hat \beta_2 \text{Hits}\]</div>
<p>그런데 <strong>회귀 트리</strong>에 의한 예측은 일단 표현 방식이 위의 선형 회귀와는 많이 다르다. 아래 그림 12.1이 본 예제에 대한 회귀 트리의 결과를 보여준다. 주어진 데이터(즉 <code class="docutils literal notranslate"><span class="pre">Years</span></code>, <code class="docutils literal notranslate"><span class="pre">Hits</span></code>, <code class="docutils literal notranslate"><span class="pre">Salary</span></code> 변수)를 사용해 선수들의 연봉을 예측하는 간단한 결정 트리를 도출한 것으로서 추정 결과가 식(equation)이 아니라 그림, 즉 트리의 형태로 주어진다는 점이 특징이다.</p>
<p>우선 그림 12.1에 나와 있는 트리의 의미를 생각해보면, 맨 위에 나와 있는 <code class="docutils literal notranslate"><span class="pre">Years&lt;4.5</span></code>는 결정 경계를 나타내는데, 메이저리그에서 뛴 연차가 4.5년 미만이면 왼쪽 가지(branch)이고, 4.5년 이상이면 오른쪽 가지에 해당한다는 의미이다. 마찬가지로 그 아래 있는 <code class="docutils literal notranslate"><span class="pre">Hits&lt;117.5</span></code> 역시 결정 경계로서 전년도 안타수가 117.5개 미만이면 왼쪽이고, 117.5개 이상이면 오른쪽이다. 그리고 맨 끝에 나와 있는 세 개의 숫자, 즉 <code class="docutils literal notranslate"><span class="pre">5.11</span></code>, <code class="docutils literal notranslate"><span class="pre">6.00</span></code>, <code class="docutils literal notranslate"><span class="pre">6.74</span></code>는 주어진 각 영역에 속했을 때의 <code class="docutils literal notranslate"><span class="pre">Salary</span></code> 예측값이다.(소위 “사다리타기” 게임에서 맨 마지막 도착지인 셈이다.)</p>
<p>이 회귀 트리에 따르면, 예를 들어 어떤 선수가 메이저리그 경력 8년차이고, 전년도 안타수가 100개인 경우, 이 선수의 연봉(로그)은 6.0으로 예측된다. 이 로그값을 달러 금액으로 환산하면 <span class="math notranslate nohighlight">\(e^{6.0}=403.429\)</span>(천달러), 즉 40만 3,429달러이다. 이 선수의 연봉(로그)이 6.0으로 예측되는 이유는 자명하다. 이 선수가 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(=8\)</span>이기 때문에 트리 맨 위의 갈림길에서 오른쪽에 해당하고, 그 다음 갈림길에서는 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(=100\)</span>이기 때문에 왼쪽 가지에 해당해 연봉 예측값 6.0에 도달하게 된다.</p>
<p><strong>그림 12.1.</strong> <code class="docutils literal notranslate"><span class="pre">Hitters</span></code> 데이터세트에서 메이저리그 연차(<code class="docutils literal notranslate"><span class="pre">Years</span></code>)와 전년도 안타수(<code class="docutils literal notranslate"><span class="pre">Hits</span></code>)를 기반으로 선수들의 로그 연봉(<code class="docutils literal notranslate"><span class="pre">Salary</span></code>)을 예측하는 회귀 트리 결과이다. 내부마디에 있는 레이블(<span class="math notranslate nohighlight">\(X_j &lt; t_k\)</span> 형식)은 해당 분할에서 나오는 왼쪽 가지 영역을 나타내고, 오른쪽 가지는 <span class="math notranslate nohighlight">\(X_j ≥ t_k\)</span>에 해당한다. 예를 들어, 트리 상단의 분할은 두 개의 가지를 생성하는데, 왼쪽 가지는 <code class="docutils literal notranslate"><span class="pre">Years&lt;4.5</span></code>에 해당하고 오른쪽 가지는 <code class="docutils literal notranslate"><span class="pre">Years&gt;=4.5</span></code>에 해당한다. 이 트리에는 2개의 내부마디와 3개의 끝마디(또는 잎)가 있다. 각 끝마디에 적혀 있는 숫자는 해당 영역에 속하는 관측들의 평균 반응값(여기서는 평균 <code class="docutils literal notranslate"><span class="pre">Salary</span></code>)으로서 이를 해당 영역의 예측값으로 삼는다.</p>
<p><img alt="회귀 트리 예" src="https://raw.githubusercontent.com/pilsunchoi/images/main/12-1.png" /></p>
<ul class="simple">
<li><p>그림 출처: ISLP, FIGURE 8.1</p></li>
</ul>
<p>트리 기반(tree-based) 접근에서는 위 그림 12.1에 나와 있는 것을 하나의 트리(나무)로 본다. 단, 트리가 거꾸로 돼있는 것으로 보는데, 맨 위가 뿌리이며, 거기에서 아래쪽으로 가지가 뻗어 나간다. 맨 아래에는 <strong>잎</strong>(leaf)이 있고, 각 잎에는 연봉 예측값 숫자가 적혀 있다.</p>
<p>위 그림에서 가지가 분리되는 부분, 즉 <code class="docutils literal notranslate"><span class="pre">Years&lt;4.5</span></code> 및 <code class="docutils literal notranslate"><span class="pre">Hits&lt;117.5</span></code>로 적혀 있는 부분을 <strong>내부마디</strong>(internal node)라고 부른다. 여기에 적혀 있는 레이블(<span class="math notranslate nohighlight">\(X_j &lt; t_k\)</span> 형식)은 해당 분할에서 나오는 왼쪽 가지 영역을 나타내고, 오른쪽 가지는 <span class="math notranslate nohighlight">\(X_j ≥ t_k\)</span> 영역을 의미한다. 내부마디 중 맨 위쪽에 있는 (즉, 트리가 처음 시작하는) 마디를 <strong>뿌리마디</strong>(root node)라고 한다. 우리 예에서는 <code class="docutils literal notranslate"><span class="pre">Years&lt;4.5</span></code>가 뿌리마디에 해당한다. 앞에서 언급했듯이 트리의 맨 아래쪽을 잎이라고 하는데, 이를 <strong>끝마디</strong>(terminal node)라고도 부른다.</p>
<p>각 끝마디는 영역(region)을 의미하는데, 위 트리에는 3개의 영역이 있다. 이것을 왼쪽부터 <span class="math notranslate nohighlight">\(R_1\)</span>, <span class="math notranslate nohighlight">\(R_2\)</span>, <span class="math notranslate nohighlight">\(R_3\)</span>라 하면,  <span class="math notranslate nohighlight">\(R_1 =\{X |\)</span> <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(&lt;4.5\}\)</span>, <span class="math notranslate nohighlight">\(R_2 =\{X |\)</span> <code class="docutils literal notranslate"><span class="pre">Years</span></code> <span class="math notranslate nohighlight">\(\ge 4.5,\)</span> <code class="docutils literal notranslate"><span class="pre">Hits</span></code> <span class="math notranslate nohighlight">\(&lt;117.5\}\)</span>, <span class="math notranslate nohighlight">\(R_3 =\{X |\)</span> <code class="docutils literal notranslate"><span class="pre">Years</span></code> <span class="math notranslate nohighlight">\(\ge 4.5,\)</span> <code class="docutils literal notranslate"><span class="pre">Hits</span></code> <span class="math notranslate nohighlight">\(\ge 117.5\}\)</span>이다. 아래 그림 12.2는 이들 3개의 영역을 <code class="docutils literal notranslate"><span class="pre">Years</span></code> 및 <code class="docutils literal notranslate"><span class="pre">Hits</span></code>를 축으로 하여 그린 것이다.</p>
<p><strong>그림 12.2.</strong> 그림 12.1에 나온 회귀 트리의 3개 영역을 <code class="docutils literal notranslate"><span class="pre">Years</span></code> 및 <code class="docutils literal notranslate"><span class="pre">Hits</span></code>를 축으로 하여 그린 것이다.</p>
<p><img alt="회귀 트리 3개 영역" src="https://raw.githubusercontent.com/pilsunchoi/images/main/12-2.png" /></p>
<ul class="simple">
<li><p>그림 출처: ISLP, FIGURE 8.2</p></li>
</ul>
<p>결국 결정 트리는 예측변수들을 여러 영역으로 나눈 다음, 각 영역 별로 반응변수에 대한 예측값을 제시하는 것이다. 그렇다면 위 그림 12.1에 있는 예측값 <code class="docutils literal notranslate"><span class="pre">5.11</span></code>, <code class="docutils literal notranslate"><span class="pre">6.00</span></code>, <code class="docutils literal notranslate"><span class="pre">6.74</span></code>는 어디에서 나온 것일까? 그것은 각 영역에 속하는 선수들의 <strong>평균</strong> <code class="docutils literal notranslate"><span class="pre">Salary</span></code>이다. 즉, 각 영역의 반응변수 평균값을 해당 영역의 예측값으로 삼는다.</p>
<p>그림 12.1에 표시된 회귀 트리를 다음과 같이 해석할 수 있다. <code class="docutils literal notranslate"><span class="pre">Salary</span></code>를 결정하는 가장 중요한 요소는 (뿌리마디 변수인) <code class="docutils literal notranslate"><span class="pre">Years</span></code>로서, 메이저리그 연차가 낮은 선수는 연차가 높은 선수보다 연봉이 적다. 연차가 낮은 신인급 선수에게는 전년도 타격 기록, 즉 안타수(<code class="docutils literal notranslate"><span class="pre">Hits</span></code>)가 더 이상 연봉에 영향을 미치지 않는다. 하지만 메이저리그에서 4.5년 이상 활약한 비교적 베테랑 선수들에게는 전년도 안타수가 연봉에 영향을 미치며, 안타수가 많은 선수가 연봉을 더 많이 받는 경향이 있다.</p>
<p>그림 12.1에 표시된 회귀 트리는 <code class="docutils literal notranslate"><span class="pre">Hits</span></code>, <code class="docutils literal notranslate"><span class="pre">Years</span></code>, <code class="docutils literal notranslate"><span class="pre">Salary</span></code> 간의 실제 관계를 지나치게 단순화한 것일 수 있다. 그러나 다른 유형의 회귀 모델에 비해 장점이 있다. 무엇보다도 트리라는 것이 무엇을 의미하는지 조금만 설명을 들으면 이해할 수 있고, 그래픽 표현이 가능하다는 점이다.(가령 회귀 분석 결과에 비해 트리 결과를 이해하는 것이 훨씬 쉽다!)</p>
<section id="id3">
<h3>트리 기반 접근<a class="headerlink" href="#id3" title="Link to this heading">#</a></h3>
<p>위에서 소개한 결정 트리를 만드는 방법을 개략적으로 소개하면, 예측변수(predictor) 공간을 여러 개의 단순 영역으로 계층화(stratifying) 하거나 분할하는(segmenting) 작업을 진행한다. 그런 다음, 각 영역별로 주어진 관측의 반응을 예측하는데, 일반적으로 해당 영역에 속한 훈련 관측 반응변수의 평균값이나 최빈값(mode)을 사용한다.</p>
<p>트리 기반 기법은 이해와 해석이 용이하다는 장점을 지닌다. 그러나 예측 정확도 면에서는 일반적으로 앞에서 살펴본 전통적인 선형 회귀나 로지스틱 회귀에 뒤지는 경우가 많다. 따라서 이런 단점을 보완하기 위해 배깅(bagging), 랜덤 포레스트(random forest), 부스팅(boosting) 기법들이 등장했다. 이들은 트리를 <strong>하나가 아니라 여러 개</strong> 생성하여 이것들을 <strong>결합</strong>시키는 방식으로 최종적인 예측을 도출하는 방법들로서 이에 대해서는 다음 장에서 다룬다. 많은 수의 트리를 결합하면, 해석 상의 손실은 어느 정도 감수해야 하지만, 예측 정확도가 획기적으로 높아지는 경우가 많다는 것을 알게 될 것이다.</p>
</section>
</section>
<section id="id4">
<h2>12.2 회귀 트리 만들기<a class="headerlink" href="#id4" title="Link to this heading">#</a></h2>
<section id="id5">
<h3>특성 공간의 계층화를 통한 예측<a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
<p>결정 트리는 회귀 및 분류 문제 모두에 적용할 수 있는데, 먼저 회귀 문제를 생각해보자. 회귀 트리는 앞에서도 언급했듯이 예측변수 공간의 계층화(stratification)를 통한 예측 기법으로서 이를 구축하는 과정은 크게 다음 두 단계로 나눌 수 있다.</p>
<ul class="simple">
<li><p><strong>STEP 1</strong> : 예측변수(<span class="math notranslate nohighlight">\(X_1,X_2,...,X_p\)</span>) 공간을 <span class="math notranslate nohighlight">\(J\)</span>개의 서로 겹치지 않는 영역 <span class="math notranslate nohighlight">\(R_1,R_2,...,R_J\)</span>로 나눈다.</p></li>
<li><p><strong>STEP 2</strong> : <span class="math notranslate nohighlight">\(R_j\)</span> 영역에 속하는 훈련 관측들의 반응변수 평균값을 예측값(즉, 예상 반응값)으로 삼는다. 이는 <span class="math notranslate nohighlight">\(R_j\)</span> 영역에 속하는 모든 관측에 대해 동일하게 적용된다.</p></li>
</ul>
<p>두 번째 단계부터 먼저 설명하면, 예를 들어 첫 번째 단계에서 <span class="math notranslate nohighlight">\(R_1\)</span>과 <span class="math notranslate nohighlight">\(R_2\)</span>라는 두 영역으로 분할이 이루어졌다고 해보자. 이 중 <span class="math notranslate nohighlight">\(R_1\)</span> 영역에 속하는 훈련 관측의 반응값 평균이 10이고, <span class="math notranslate nohighlight">\(R_2\)</span> 영역은 반응값 평균이 20이라고 하자. 이런 경우, 주어진 관측 <span class="math notranslate nohighlight">\(X = x\)</span>에 대해, 만약 <span class="math notranslate nohighlight">\(x\)</span>가 <span class="math notranslate nohighlight">\(R_1\)</span>에 속하면 10으로 예측하고, <span class="math notranslate nohighlight">\(R_2\)</span>에 속하면 20으로 예측한다는 것이다.</p>
<p>이제 위 첫 번째 단계에 대해 구체적으로 살펴 보자. 핵심은 <span class="math notranslate nohighlight">\(R_1,...,R_J\)</span> 영역을 어떻게 만드느냐이다. 이론적으로는 각 영역이 어떤 모양도 될 수 있다. 그러나 모형을 단순하게 하고, 해석을 용이하게 하기 위해 우리는 예측변수 공간을 직사각형 또는 상자 형태로 나눈다. 가령 2차원 공간이라면, 앞의 그림 12.2에 나와 있는 것처럼 두 변수로 이루어진 평면 공간에서 <span class="math notranslate nohighlight">\(R_1\)</span>, <span class="math notranslate nohighlight">\(R_2\)</span>, <span class="math notranslate nohighlight">\(R_3\)</span>의 형태로서 직사각형 형태만 고려할 뿐, 원이나 다항식 형태는 고려하지 않는다는 것이다.</p>
<p>이런 식으로 영역을 나누되, 우리의 목표는 다음의 <strong>RSS</strong>(residual sum of squares: 잔차제곱합)을 최소화하는 <span class="math notranslate nohighlight">\(R_1,...,R_J\)</span>를 찾는 것이다.</p>
<div class="math notranslate nohighlight">
\[
\text{RSS}=\sum_{j=1}^{J}\sum_{i \in R_j}(y_i - \hat y_{R_j} )^2 \tag{12.1}
\]</div>
<p>여기서 <span class="math notranslate nohighlight">\(\hat y_{R_j}\)</span>는 <span class="math notranslate nohighlight">\(j\)</span>번째 영역에 속하는 훈련 관측들의 평균 반응값이다.</p>
<p>그런데 관측 개수와 예측변수(즉 특성)의 개수가 많아지면 특성 공간을 분할하는 모든 가능한 영역을 고려하는 것은 사실상 불가능하다. 이 때문에 우리는 특성 공간의 영역 분할에 있어서 <strong>반복 이항 분할</strong>(recursive binary splitting)로 불리는 방식을 취한다. 이를 다음과 같은 예를 통해 설명한다.</p>
</section>
<section id="id6">
<h3>회귀 트리 만들기 간단한 예<a class="headerlink" href="#id6" title="Link to this heading">#</a></h3>
<p>먼저 가장 간단한 예를 사용하여 직접 반복 이항 분할을 실행해보자. 사용할 데이터는 앞 절에서 소개한 <code class="docutils literal notranslate"><span class="pre">Hitters</span></code> 데이터로서 원래는 관측 개수가 263개인데 여기에서는 단 3개의 관측만 사용하여 회귀 트리를 만들어 보자. 예제 데이터세트는 다음과 같고, 각 변수의 의미는 앞 절에서 설명한 대로이다.(<code class="docutils literal notranslate"><span class="pre">Salary</span></code>는 로그를 취한 값이다.)</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{c|cccc}
\text{No.} &amp; \text{Years} &amp; \text{Hits} &amp; \text{Salary} \\
\hline
1 &amp; 10 &amp; 100 &amp; 8.0 \\
2 &amp; 2 &amp; 140 &amp; 4.0 \\
3 &amp; 10 &amp; 170 &amp; 10.0 \\
\end{array}
\end{split}\]</div>
<p><strong>뿌리마디</strong></p>
<ul class="simple">
<li><p>트리를 만들기 위해서는 우선 아래 그림처럼 뿌리마디부터 정해야 한다. 마디를 정한다는 것은 <strong>어떤 변수</strong>, 그리고 <strong>어떤 절단점</strong>(cutpoint)을 사용할 것인지를 정한다는 것으로서 그 기준은 <strong>잔차제곱합</strong>(RSS: residual sum of squares)을 <strong>최소화</strong>하는 것이다.(이를 잔차제곱합의 “감소를 최대화”한다고 표현할 수도 있다.)</p></li>
</ul>
<p><img alt="회귀 트리 만들기 1" src="https://raw.githubusercontent.com/pilsunchoi/images/main/12-3.png" /></p>
<ul class="simple">
<li><p>우선 <code class="docutils literal notranslate"><span class="pre">Years</span></code>부터 시작해보면, 위 표에서 보듯이 관측값이 2와 10 두 개뿐이고, 그 중간점(midpoint)은 6이다.(관행상 2개 관측값의 절단점으로 중간점을 사용한다.) 따라서 6을 기준으로 그 미만과 그 이상으로 나눈다.</p></li>
<li><p>먼저 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(&lt;6\)</span> 영역에는 2번 선수 한 명밖에 없기 때문에 그의 연봉이 곧 이 영역의 평균 <code class="docutils literal notranslate"><span class="pre">Salary</span></code>이고, 그 값은 4.0이다. 반대 영역인 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(\ge6\)</span>에는 1번과 3번 선수가 해당하며, 둘의 평균 <code class="docutils literal notranslate"><span class="pre">Salary</span></code>는 9.0이다.</p></li>
<li><p>이렇게 분할이 이루어졌을 때, RSS를 계산해보자. 1번 선수의 잔차(residual)는 <span class="math notranslate nohighlight">\(8-9=-1\)</span>이고, 2번 선수는 <span class="math notranslate nohighlight">\(4-4=0\)</span>이며, 3번 선수는 <span class="math notranslate nohighlight">\(10-9=1\)</span>이다. 따라서 <span class="math notranslate nohighlight">\(\text{RSS}=(-1)^2+0^2+(1)^2=2\)</span>이다. 이것을 기록해두고 다음으로 넘어 간다.</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>이번에는 또 다른 입력변수인 <code class="docutils literal notranslate"><span class="pre">Hits</span></code>를 기준으로 분할해보자. <code class="docutils literal notranslate"><span class="pre">Hits</span></code>는 값이 100, 140, 170 세 개이기 때문에 100과 140의 중간점(즉 120), 그리고 140과 170의 중간점(즉 155) 등 두 곳을 절단점으로 고려해야 한다.</p></li>
<li><p>먼저 첫 번째 절단점 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(=120\)</span>을 기준으로 그 미만과 그 이상으로 나눈다. 먼저 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(&lt;120\)</span> 영역에는 1번 선수 한 명밖에 없기 때문에 그의 연봉이 곧 이 영역의 평균 <code class="docutils literal notranslate"><span class="pre">Salary</span></code>이고, 그 값은 8.0이다. 반대 영역인 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(\ge120\)</span>에는 2번과 3번 선수가 여기에 속하며, 이 두 선수의 평균 <code class="docutils literal notranslate"><span class="pre">Salary</span></code>는 7.0이다.</p></li>
<li><p>이렇게 분할이 이루어졌을 때 RSS를 계산하면, 1번 선수의 잔차는 <span class="math notranslate nohighlight">\(8-8=0\)</span>이고, 2번 선수는 <span class="math notranslate nohighlight">\(4-7=-3\)</span>이며, 3번 선수는 <span class="math notranslate nohighlight">\(10-7=3\)</span>이다. 따라서 <span class="math notranslate nohighlight">\(\text{RSS}=(0)^2+(-3)^2+(3)^2=18\)</span>이다. 이것을 기록해두고 다음으로 넘어 간다.</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>마지막으로 두 번째 절단점 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(=155\)</span>를 기준으로 그 미만과 그 이상으로 나눠 RSS를 구해보자. 먼저 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(&lt;155\)</span> 영역에는 1번과 2번 선수가 여기에 해당하며, 이 두 선수의 평균 <code class="docutils literal notranslate"><span class="pre">Salary</span></code>는 6.0이다. 그리고 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(\ge155\)</span> 영역에는 3번 선수 한 명밖에 없기 때문에 그의 연봉이 곧 이 영역의 평균 <code class="docutils literal notranslate"><span class="pre">Salary</span></code>이고 그 값은 10.0이다.</p></li>
<li><p>이렇게 분할이 이루어졌을 때 RSS를 계산하면, 1번 선수의 잔차는 <span class="math notranslate nohighlight">\(8-6=2\)</span>이고, 2번 선수는 <span class="math notranslate nohighlight">\(4-6=-2\)</span>이며, 3번 선수는 <span class="math notranslate nohighlight">\(10-10=0\)</span>이다. 따라서 <span class="math notranslate nohighlight">\(\text{RSS}=(2)^2+(-2)^2+(0)^2=8\)</span>이다.</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>위에서 살펴 본 세 가지 분할의 RSS 값인 (<span class="math notranslate nohighlight">\(2, 18, 8\)</span>) 중에서 가장 작은 것은 첫 번째 경우, 즉 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(=6\)</span>을 기준으로 분할했을 때이다. 따라서 이것이 트리의 시작점인 뿌리마디가 된다. 즉 이제 트리는 다음과 같은 모습을 갖췄다.</p></li>
</ul>
<p><img alt="회귀 트리 만들기 2" src="https://raw.githubusercontent.com/pilsunchoi/images/main/12-4.png" /></p>
<p><strong>중간마디 및 끝마디</strong></p>
<ul class="simple">
<li><p>앞에서 뿌리마디를 정했는데, 여기에서 왼쪽 가지는 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(&lt;6\)</span>이고, 오른쪽 가지는 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(\ge 6\)</span>을 의미한다. 이제는 이들 각 가지에서 다시 이항 분할을 따져봐야 한다. 그 기준과 절차는 뿌리마디를 찾을 때와 전적으로 동일하다.</p></li>
<li><p>먼저 뿌리마디의 왼쪽 가지 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(&lt;6\)</span>의 경우에는 여기에 속하는 관측이 한 개(즉 2번 선수)밖에 없기 때문에 더 이상 분할을 할 수 없다. 즉 왼쪽 가지는 그것이 끝마디가 된다. 그리고 이 끝마디에 속할 경우, <code class="docutils literal notranslate"><span class="pre">Salary</span></code> 예측값은 2번 선수의 연봉인 4.0이 된다. 따라서 이제 트리는 다음과 같이 된다.</p></li>
</ul>
<p><img alt="회귀 트리 만들기 3" src="https://raw.githubusercontent.com/pilsunchoi/images/main/12-5.png" /></p>
<ul class="simple">
<li><p>이번에는 뿌리마디의 오른쪽 가지인 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(\ge 6\)</span>을 보면, 여기에 속하는 관측이 1번과 3번 선수 두 명이다. 이 상황에서 뿌리마디를 찾을 때 행했던 절차를 똑같이 적용하면 된다. 즉 <code class="docutils literal notranslate"><span class="pre">Years</span></code>와 <code class="docutils literal notranslate"><span class="pre">Hits</span></code> 두 변수 중 어떤 것에 대해 어떤 절단점을 사용할지를 찾는 것이다.</p></li>
<li><p>그런데 우리 예에서는 일단 1번과 3번 선수 모두 <code class="docutils literal notranslate"><span class="pre">Years</span></code>가 10.0으로 동일하다. 즉 <code class="docutils literal notranslate"><span class="pre">Years</span></code>에 대해서는 더 이상 이항 분할이 되지 않는다.</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>따라서 <code class="docutils literal notranslate"><span class="pre">Hits</span></code>에 대해서만 생각하면 되는데, 이 경우 가능한 이항 분할은 이들 두 명의 <code class="docutils literal notranslate"><span class="pre">Hits</span></code> 값(즉, 100 및 170)의 중간점인 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(=135\)</span>밖에 없다. 따라서 이것이 오른쪽 가지에 새로 생기는 중간마디가 된다.</p></li>
<li><p>이 중간마디의 왼쪽 가지와 오른쪽 가지에는 각각 1번과 3번 한 명의 선수만 포함되기 때문에, 두 갈래 가지 자체가 끝마디가 되고, 각 끝마디의 <code class="docutils literal notranslate"><span class="pre">Salary</span></code> 예측값은 8.0과 10.0이 된다.</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>이것으로 트리 작성은 끝났으며, 지금까지의 결과를 종합하면 트리의 최종적인 모습은 다음과 같다.</p></li>
</ul>
<p><img alt="회귀 트리 만들기 4" src="https://raw.githubusercontent.com/pilsunchoi/images/main/12-6.png" /></p>
<ul class="simple">
<li><p>가령 어떤 선수가 메이저리그 경력 8년차이고, 전년도 안타수가 120개라면, 우리는 이 선수의 연봉(로그)을 8.0으로 예측하게 된다. 로그값이 아니라 금액으로 환산하면 <span class="math notranslate nohighlight">\(e^{8.0}=2,981\)</span>(천달러)이다.</p></li>
<li><p>지금까지 트리를 만드는 과정에서 짐작할 수 있듯이, 관측의 개수와 예측변수의 개수가 많아지면 트리가 엄청나게 커지게 될 것이다. 따라서 어느 수준에서 트리의 성장을 중지시킬 필요가 있는데, 예를 들어 어떤 영역이든 해당 영역에 속한 관측의 개수가 5개에 이를 때까지라든지, 또는 트리의 깊이를 지정한다든지(그림 12.1에 나온 트리의 경우 “깊이”가 2임), 또는 끝마디의 개수를 최대 몇 개까지로 하는 것 등이 방법이 될 수 있다.</p></li>
</ul>
</section>
<section id="id7">
<h3>회귀 트리 코딩<a class="headerlink" href="#id7" title="Link to this heading">#</a></h3>
<p>지금까지 수작업으로 작성한 결정 트리를 파이썬 코딩으로 실행해보자. 트리 모델을 피팅하기 위해서는 사이킷런(<code class="docutils literal notranslate"><span class="pre">sklearn</span></code>)의 <code class="docutils literal notranslate"><span class="pre">tree</span></code> 모듈이 필요하다. 거기에서 회귀 트리를 위해서는 <code class="docutils literal notranslate"><span class="pre">DecisionTreeRegressor()</span></code> 함수가 필요하고, 분류 트리를  위해서는 <code class="docutils literal notranslate"><span class="pre">DecisionTreeClassifier()</span></code> 함수가 필요하다. 먼저 주요 모듈과 함수들을 불러 들인다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">tree</span>
<span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeRegressor</span><span class="p">,</span> <span class="n">DecisionTreeClassifier</span>
</pre></div>
</div>
</div>
</div>
<p><strong>예제 데이터세트 입력</strong></p>
<p>위에서 예시로 사용한 데이터를 입력한 다음, 예측변수를 <code class="docutils literal notranslate"><span class="pre">X</span></code>라는 이름으로, 그리고 반응변수를 <code class="docutils literal notranslate"><span class="pre">y</span></code>로 각각 지정한다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Years</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">Hits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">140</span><span class="p">,</span> <span class="mi">170</span><span class="p">]</span>
<span class="n">Salary</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>

<span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Years&#39;</span><span class="p">:</span> <span class="n">Years</span><span class="p">,</span> <span class="s1">&#39;Hits&#39;</span><span class="p">:</span> <span class="n">Hits</span><span class="p">}</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Salary</span>
</pre></div>
</div>
</div>
</div>
<p><strong>회귀 트리 피팅 실행</strong></p>
<p>회귀 트리는 <code class="docutils literal notranslate"><span class="pre">DecisionTreeRegressor()</span></code> 함수를 사용해 만든다. 이 함수의 주요 파라미터 값을 지정해야 하는데, 여기에서는 모두 기본값(default)을 사용하기로 하고, 인수를 전혀 입력하지 않기로 한다. 이럴 경우 트리가 제약 없이 최대한으로 성장하게 된다. 이 모형을 <code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드를 사용해 데이터(<code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>)에 피팅시킨다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">regr</span> <span class="o">=</span> <span class="n">DecisionTreeRegressor</span><span class="p">()</span>
<span class="n">regr</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><style>#sk-container-id-1 {
  /* Definition of color scheme common for light and dark mode */
  --sklearn-color-text: black;
  --sklearn-color-line: gray;
  /* Definition of color scheme for unfitted estimators */
  --sklearn-color-unfitted-level-0: #fff5e6;
  --sklearn-color-unfitted-level-1: #f6e4d2;
  --sklearn-color-unfitted-level-2: #ffe0b3;
  --sklearn-color-unfitted-level-3: chocolate;
  /* Definition of color scheme for fitted estimators */
  --sklearn-color-fitted-level-0: #f0f8ff;
  --sklearn-color-fitted-level-1: #d4ebff;
  --sklearn-color-fitted-level-2: #b3dbfd;
  --sklearn-color-fitted-level-3: cornflowerblue;

  /* Specific color for light theme */
  --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
  --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, white)));
  --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
  --sklearn-color-icon: #696969;

  @media (prefers-color-scheme: dark) {
    /* Redefinition of color scheme for dark theme */
    --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
    --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, #111)));
    --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
    --sklearn-color-icon: #878787;
  }
}

#sk-container-id-1 {
  color: var(--sklearn-color-text);
}

#sk-container-id-1 pre {
  padding: 0;
}

#sk-container-id-1 input.sk-hidden--visually {
  border: 0;
  clip: rect(1px 1px 1px 1px);
  clip: rect(1px, 1px, 1px, 1px);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}

#sk-container-id-1 div.sk-dashed-wrapped {
  border: 1px dashed var(--sklearn-color-line);
  margin: 0 0.4em 0.5em 0.4em;
  box-sizing: border-box;
  padding-bottom: 0.4em;
  background-color: var(--sklearn-color-background);
}

#sk-container-id-1 div.sk-container {
  /* jupyter's `normalize.less` sets `[hidden] { display: none; }`
     but bootstrap.min.css set `[hidden] { display: none !important; }`
     so we also need the `!important` here to be able to override the
     default hidden behavior on the sphinx rendered scikit-learn.org.
     See: https://github.com/scikit-learn/scikit-learn/issues/21755 */
  display: inline-block !important;
  position: relative;
}

#sk-container-id-1 div.sk-text-repr-fallback {
  display: none;
}

div.sk-parallel-item,
div.sk-serial,
div.sk-item {
  /* draw centered vertical line to link estimators */
  background-image: linear-gradient(var(--sklearn-color-text-on-default-background), var(--sklearn-color-text-on-default-background));
  background-size: 2px 100%;
  background-repeat: no-repeat;
  background-position: center center;
}

/* Parallel-specific style estimator block */

#sk-container-id-1 div.sk-parallel-item::after {
  content: "";
  width: 100%;
  border-bottom: 2px solid var(--sklearn-color-text-on-default-background);
  flex-grow: 1;
}

#sk-container-id-1 div.sk-parallel {
  display: flex;
  align-items: stretch;
  justify-content: center;
  background-color: var(--sklearn-color-background);
  position: relative;
}

#sk-container-id-1 div.sk-parallel-item {
  display: flex;
  flex-direction: column;
}

#sk-container-id-1 div.sk-parallel-item:first-child::after {
  align-self: flex-end;
  width: 50%;
}

#sk-container-id-1 div.sk-parallel-item:last-child::after {
  align-self: flex-start;
  width: 50%;
}

#sk-container-id-1 div.sk-parallel-item:only-child::after {
  width: 0;
}

/* Serial-specific style estimator block */

#sk-container-id-1 div.sk-serial {
  display: flex;
  flex-direction: column;
  align-items: center;
  background-color: var(--sklearn-color-background);
  padding-right: 1em;
  padding-left: 1em;
}


/* Toggleable style: style used for estimator/Pipeline/ColumnTransformer box that is
clickable and can be expanded/collapsed.
- Pipeline and ColumnTransformer use this feature and define the default style
- Estimators will overwrite some part of the style using the `sk-estimator` class
*/

/* Pipeline and ColumnTransformer style (default) */

#sk-container-id-1 div.sk-toggleable {
  /* Default theme specific background. It is overwritten whether we have a
  specific estimator or a Pipeline/ColumnTransformer */
  background-color: var(--sklearn-color-background);
}

/* Toggleable label */
#sk-container-id-1 label.sk-toggleable__label {
  cursor: pointer;
  display: block;
  width: 100%;
  margin-bottom: 0;
  padding: 0.5em;
  box-sizing: border-box;
  text-align: center;
}

#sk-container-id-1 label.sk-toggleable__label-arrow:before {
  /* Arrow on the left of the label */
  content: "▸";
  float: left;
  margin-right: 0.25em;
  color: var(--sklearn-color-icon);
}

#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {
  color: var(--sklearn-color-text);
}

/* Toggleable content - dropdown */

#sk-container-id-1 div.sk-toggleable__content {
  max-height: 0;
  max-width: 0;
  overflow: hidden;
  text-align: left;
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-1 div.sk-toggleable__content.fitted {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

#sk-container-id-1 div.sk-toggleable__content pre {
  margin: 0.2em;
  border-radius: 0.25em;
  color: var(--sklearn-color-text);
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-1 div.sk-toggleable__content.fitted pre {
  /* unfitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {
  /* Expand drop-down */
  max-height: 200px;
  max-width: 100%;
  overflow: auto;
}

#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {
  content: "▾";
}

/* Pipeline/ColumnTransformer-specific style */

#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-1 div.sk-label.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Estimator-specific style */

/* Colorize estimator box */
#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-1 div.sk-estimator.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-2);
}

#sk-container-id-1 div.sk-label label.sk-toggleable__label,
#sk-container-id-1 div.sk-label label {
  /* The background is the default theme color */
  color: var(--sklearn-color-text-on-default-background);
}

/* On hover, darken the color of the background */
#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-unfitted-level-2);
}

/* Label box, darken color on hover, fitted */
#sk-container-id-1 div.sk-label.fitted:hover label.sk-toggleable__label.fitted {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Estimator label */

#sk-container-id-1 div.sk-label label {
  font-family: monospace;
  font-weight: bold;
  display: inline-block;
  line-height: 1.2em;
}

#sk-container-id-1 div.sk-label-container {
  text-align: center;
}

/* Estimator-specific */
#sk-container-id-1 div.sk-estimator {
  font-family: monospace;
  border: 1px dotted var(--sklearn-color-border-box);
  border-radius: 0.25em;
  box-sizing: border-box;
  margin-bottom: 0.5em;
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-1 div.sk-estimator.fitted {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

/* on hover */
#sk-container-id-1 div.sk-estimator:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-1 div.sk-estimator.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Specification for estimator info (e.g. "i" and "?") */

/* Common style for "i" and "?" */

.sk-estimator-doc-link,
a:link.sk-estimator-doc-link,
a:visited.sk-estimator-doc-link {
  float: right;
  font-size: smaller;
  line-height: 1em;
  font-family: monospace;
  background-color: var(--sklearn-color-background);
  border-radius: 1em;
  height: 1em;
  width: 1em;
  text-decoration: none !important;
  margin-left: 1ex;
  /* unfitted */
  border: var(--sklearn-color-unfitted-level-1) 1pt solid;
  color: var(--sklearn-color-unfitted-level-1);
}

.sk-estimator-doc-link.fitted,
a:link.sk-estimator-doc-link.fitted,
a:visited.sk-estimator-doc-link.fitted {
  /* fitted */
  border: var(--sklearn-color-fitted-level-1) 1pt solid;
  color: var(--sklearn-color-fitted-level-1);
}

/* On hover */
div.sk-estimator:hover .sk-estimator-doc-link:hover,
.sk-estimator-doc-link:hover,
div.sk-label-container:hover .sk-estimator-doc-link:hover,
.sk-estimator-doc-link:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

div.sk-estimator.fitted:hover .sk-estimator-doc-link.fitted:hover,
.sk-estimator-doc-link.fitted:hover,
div.sk-label-container:hover .sk-estimator-doc-link.fitted:hover,
.sk-estimator-doc-link.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

/* Span, style for the box shown on hovering the info icon */
.sk-estimator-doc-link span {
  display: none;
  z-index: 9999;
  position: relative;
  font-weight: normal;
  right: .2ex;
  padding: .5ex;
  margin: .5ex;
  width: min-content;
  min-width: 20ex;
  max-width: 50ex;
  color: var(--sklearn-color-text);
  box-shadow: 2pt 2pt 4pt #999;
  /* unfitted */
  background: var(--sklearn-color-unfitted-level-0);
  border: .5pt solid var(--sklearn-color-unfitted-level-3);
}

.sk-estimator-doc-link.fitted span {
  /* fitted */
  background: var(--sklearn-color-fitted-level-0);
  border: var(--sklearn-color-fitted-level-3);
}

.sk-estimator-doc-link:hover span {
  display: block;
}

/* "?"-specific style due to the `<a>` HTML tag */

#sk-container-id-1 a.estimator_doc_link {
  float: right;
  font-size: 1rem;
  line-height: 1em;
  font-family: monospace;
  background-color: var(--sklearn-color-background);
  border-radius: 1rem;
  height: 1rem;
  width: 1rem;
  text-decoration: none;
  /* unfitted */
  color: var(--sklearn-color-unfitted-level-1);
  border: var(--sklearn-color-unfitted-level-1) 1pt solid;
}

#sk-container-id-1 a.estimator_doc_link.fitted {
  /* fitted */
  border: var(--sklearn-color-fitted-level-1) 1pt solid;
  color: var(--sklearn-color-fitted-level-1);
}

/* On hover */
#sk-container-id-1 a.estimator_doc_link:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

#sk-container-id-1 a.estimator_doc_link.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-3);
}
</style><div id="sk-container-id-1" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>DecisionTreeRegressor()</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item"><div class="sk-estimator fitted sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-1" type="checkbox" checked><label for="sk-estimator-id-1" class="sk-toggleable__label fitted sk-toggleable__label-arrow fitted">&nbsp;&nbsp;DecisionTreeRegressor<a class="sk-estimator-doc-link fitted" rel="noreferrer" target="_blank" href="https://scikit-learn.org/1.5/modules/generated/sklearn.tree.DecisionTreeRegressor.html">?<span>Documentation for DecisionTreeRegressor</span></a><span class="sk-estimator-doc-link fitted">i<span>Fitted</span></span></label><div class="sk-toggleable__content fitted"><pre>DecisionTreeRegressor()</pre></div> </div></div></div></div></div></div>
</div>
<p><strong>회귀 트리 모델에 사용된 파라미터 값</strong></p>
<p>이로써 트리 피팅은 끝났다. 여기에서는 우선 트리 모델에 사용된 파라미터 값을 확인해보자. 피팅이 끝난 우리 모델(앞에서 <code class="docutils literal notranslate"><span class="pre">regr</span></code>라는 이름으로 지정했음)에 <code class="docutils literal notranslate"><span class="pre">get_params()</span></code> 메서드를 적용하면, 모델 피팅에 사용된 파라미터 값들이 나온다. 우리 경우는 아무런 인수를 입력하지 않았기 때문에  파라미터 기본값들을 얻게 된다.</p>
<p>아래 결과를 보면, 먼저 <code class="docutils literal notranslate"><span class="pre">'criterion':</span> <span class="pre">'squared_error'</span></code>로 돼있다. 이는 이항 분할을 할 때, 평균제곱오차(MSE: mean squared error)를 기준으로 변수와 절단점을 선택하는 것으로, 앞에서 설명한 잔차제곱합(RSS)을 기준으로 한 것과 사실상 동일하다. <code class="docutils literal notranslate"><span class="pre">squared_error</span></code> 대신 가령 평균절대오차(<code class="docutils literal notranslate"><span class="pre">absolute_error</span></code>)를 사용할 수도 있다.</p>
<p>그 밖에는 트리의 크기에 제약을 가하는 파라미터들이 대부분인데 <code class="docutils literal notranslate"><span class="pre">max_depth</span></code>는 트리의 최대 깊이, <code class="docutils literal notranslate"><span class="pre">max_leaf_nodes</span></code>는 잎(끝마디)의 최대 개수, <code class="docutils literal notranslate"><span class="pre">min_samples_leaf</span></code>는 잎(끝마디)에 속한 최소 관측수, <code class="docutils literal notranslate"><span class="pre">min_samples_split</span></code>는 이항 분할이 실행되는 최소 관측수이다. 필요에 따라 이런 파라미터 값을 입력해 트리의 크기를 조정할 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">regr</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;ccp_alpha&#39;: 0.0,
 &#39;criterion&#39;: &#39;squared_error&#39;,
 &#39;max_depth&#39;: None,
 &#39;max_features&#39;: None,
 &#39;max_leaf_nodes&#39;: None,
 &#39;min_impurity_decrease&#39;: 0.0,
 &#39;min_samples_leaf&#39;: 1,
 &#39;min_samples_split&#39;: 2,
 &#39;min_weight_fraction_leaf&#39;: 0.0,
 &#39;monotonic_cst&#39;: None,
 &#39;random_state&#39;: None,
 &#39;splitter&#39;: &#39;best&#39;}
</pre></div>
</div>
</div>
</div>
<p><strong>트리 그림 그리기</strong></p>
<p>피팅이 끝난 트리를 그림으로 그리는 몇 가지 방법들이 있다. 이에 대해서는 가령 <a class="reference external" href="https://mljar.com/blog/visualize-decision-tree/">Visualize a Decision Tree in 4 Ways with Scikit-Learn and Python</a>을 참조할 수 있다.</p>
<p>여기에서는 <code class="docutils literal notranslate"><span class="pre">tree</span></code> 모듈의 <code class="docutils literal notranslate"><span class="pre">plot_tree()</span></code> 함수를 사용하기로 한다. 함수의 괄호 안에는 피팅된 모델 이름(이 예에서는 <code class="docutils literal notranslate"><span class="pre">regr</span></code>)과 예측변수 이름(<code class="docutils literal notranslate"><span class="pre">feature_names</span></code>)을 적으면 된다. <code class="docutils literal notranslate"><span class="pre">filled=True</span></code>는 트리 박스에 색깔을 집어넣는 옵션이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">plot_tree</span><span class="p">(</span><span class="n">regr</span><span class="p">,</span>
                   <span class="n">feature_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Years&#39;</span><span class="p">,</span> <span class="s1">&#39;Hits&#39;</span><span class="p">],</span>
                   <span class="n">filled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">fontsize</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>위 결과를 보면, 트리 모양은 달라도 내용에 있어서는 앞에서 우리가 수작업으로 도출한 트리와 완전히 동일한 것을 확인할 수 있다.</p>
<ul class="simple">
<li><p>위 그림에서 트리의 모든 마디 상자에 <code class="docutils literal notranslate"><span class="pre">squared_error</span></code>값이 적혀 있는데, 이것은 (이항 분할 하기 전) 해당 마디에 있어서의 평균제곱오차(MSE)를 의미한다. 여기에서 MSE는 RSS를 관측수로 나눈 것이다. RSS는 잔자제곱의 “합”이고, <code class="docutils literal notranslate"><span class="pre">squared_error</span></code>는 잔차제곱의 “평균”으로서 사실상 두 기준이 동일한 셈이다.
</br></p></li>
<li><p>위 결과에서 끝마디의 경우에는 관측이 하나씩밖에 없기 때문에 당연히 RSS가 0이고, <code class="docutils literal notranslate"><span class="pre">squared_error</span></code> 역시 0이다. 가령 뿌리마디의 경우, <code class="docutils literal notranslate"><span class="pre">squared_error=6.222</span></code>로 돼있는데, 확인 겸해서 이것을 계산해보면 다음과 같다. 우선 뿌리마디에서 이항 분할이 이루어지기 전단계에서의 평균 반응값은 <span class="math notranslate nohighlight">\((8+4+10)/3=7.333\)</span>이다. 따라서 뿌리마디에서 이것을 예측값으로 하여 RSS를 계산하면, <span class="math notranslate nohighlight">\(\text{RSS}=(8-7.333)^2+(4-7.333)^2+(10-7.333)^2=18.666\)</span>이다. 이것을 관측수 3으로 나누면 위 그림처럼 <code class="docutils literal notranslate"><span class="pre">squared_error=6.222</span></code>가 나온다.
</br></p></li>
<li><p>위 결과에서 각 마디의 마지막 줄에 <code class="docutils literal notranslate"><span class="pre">value</span></code>가 적혀 있는데, 이것은 해당 마디에 속한 관측들의 평균 반응값이다. 따라서 해당 마디가 끝마디일 경우에는 <code class="docutils literal notranslate"><span class="pre">value</span></code>가 예상 반응값(expected response value)이 된다.</p></li>
</ul>
<p>위에서 우리가 사용한 데이터세트는 관측이 겨우 3개이고, 예측변수는 2개에 불과하다. 만약 데이터세트의 관측수 및 예측변수의 개수가 많아지면 트리 규모가 커지게 됨을 쉽게 짐작할 수 있다. 즉 <code class="docutils literal notranslate"><span class="pre">DecisionTreeRegressor()</span></code> 함수를 아무 제약없이 사용하면 트리가 무한정 커질 수 있기 때문에 앞에서 소개했듯이 트리 크기를 제어하는 파라미터(<code class="docutils literal notranslate"><span class="pre">max_depth</span></code>, <code class="docutils literal notranslate"><span class="pre">min_samples_leaf</span></code>, <code class="docutils literal notranslate"><span class="pre">max_leaf_nodes</span></code> 등)를 사용해 트리의 복잡성과 크기를 제어해야 한다. 또는 아래에서 설명할 <strong>가지치기</strong>(pruning)를 하는 것도 좋은 방법이다.</p>
</section>
<section id="id8">
<h3>반복 이항 분할로 회귀 트리 만들기<a class="headerlink" href="#id8" title="Link to this heading">#</a></h3>
<p>앞에서 회귀 트리 만드는 방법을 간단한 예를 통해 설명했는데, 이를 일반화시켜 정리하면 다음과 같다.</p>
<p>결정 트리는 (회귀 트리든 분류 트리든) <strong>반복 이항 분할</strong>(recursive binary splitting)로 알려진 <strong>하향식 탐욕적 접근</strong>(top-down, greedy approach) 방식으로 만든다. 우선 “<strong>하향식</strong>”이라는 것은 트리의 상단(즉 뿌리)에서 시작하여 마치 나무 가지가 뻗어 나가듯이 예측변수 공간을 점차 세부적으로 분할해 나가는 방식을 취한다는 것이다. 그리고 “<strong>탐욕적</strong>”이라는 것은 이런 식의 각 분할이 이루어질 때, 트리의 미래(즉 전체 형태)를 내다보고 최상의 분할을 선택하는 것이 아니라 오직 그 해당 마디에서 평가한 최상의 분할을 선택한다는 의미이다.</p>
<ul class="simple">
<li><p><strong>반복 이항 분할</strong>을 좀 더 정교하게 표현하면, 모든 예측변수 <span class="math notranslate nohighlight">\(X_1,X_2,...,X_p\)</span> 및 각 예측변수에 대한 모든 가능한 절단점 중에서 <span class="math notranslate nohighlight">\(\{X \mid X_j &lt; s\}\)</span> 및 <span class="math notranslate nohighlight">\(\{X \mid X_j ≥ s\}\)</span> 영역으로 이항 분할했을 때, RSS가 가장 작아지도록(달리 표현하면, RSS의 감소가 가장 커지도록) 예측변수 <span class="math notranslate nohighlight">\(X_j\)</span>와 절단점 <span class="math notranslate nohighlight">\(s\)</span>를 선택하는 방식이다. 구체적으로는, 먼저 <span class="math notranslate nohighlight">\(j\)</span>와 <span class="math notranslate nohighlight">\(s\)</span>에 대해 우리는 다음과 같은 한 쌍으로 된 영역을 정의한다.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
R_1(j,s) = \{X \mid X_j &lt; s\}~~~\text{and}~~~R_2(j,s) = \{X \mid X_j \ge s\}\tag{12.2}
\]</div>
<ul class="simple">
<li><p>그래서 다음 식으로 표현된 RSS를 최소화하는 <span class="math notranslate nohighlight">\(j\)</span>와 <span class="math notranslate nohighlight">\(s\)</span>값을 찾는다.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\text{RSS}=\sum_{i:~x_i \in R_1(j,s)}(y_i - \hat y_{R_1} )^2 + \sum_{i:~x_i \in R_2(j,s)}(y_i - \hat y_{R_2} )^2 \tag{12.3}
\]</div>
<ul class="simple">
<li><p>여기서 <span class="math notranslate nohighlight">\(\hat y_{R_1}\)</span>은 <span class="math notranslate nohighlight">\(R_1(j,s)\)</span>에 속하는 모든 훈련 관측의 평균 반응값이고, <span class="math notranslate nohighlight">\(\hat y_{R_2}\)</span>는 <span class="math notranslate nohighlight">\(R_2(j,s)\)</span>에 속하는 모든 훈련 관측의 평균 반응값이다. 즉 위 식은 <span class="math notranslate nohighlight">\(R_1\)</span>과 <span class="math notranslate nohighlight">\(R_2\)</span>의 각 영역에 속한 모든 관측값과 해당 영역에 속했을 때의 예상 반응값의 차이, 즉 잔차(residual)를 제곱하여 모두 합친 것으로, 이를 최소화 하는 <span class="math notranslate nohighlight">\(j\)</span>와 <span class="math notranslate nohighlight">\(s\)</span>값을 찾는다는 것이다.</p></li>
<li><p>일단 뿌리마디의 분할이 이루어지면, 이번에는 <strong>나뉜 각 영역을 대상으로</strong> 또 다시 최상의 예측변수와 최상의 절단점을 찾는 작업을 반복하여 트리를 성장시켜 나간다. 이 과정을 어떤 정해진 기준에 도달할 때까지 계속한다.</p></li>
<li><p>이런 절차를 거쳐 모든 영역 <span class="math notranslate nohighlight">\(R_1, . . . ,R_J\)</span>가 생성되면, 각 영역에 속한 훈련 관측의 평균 반응값을 사용하여 주어진 테스트 관측에 대한 반응을 예측한다.</p></li>
</ul>
<p>이상 회귀 트리를 만드는 방법에 대한 설명을 앞에서 이미 살펴본 간단한 예와 비교하면서 생각하면 이해가 더 쉬울 것이다.</p>
</section>
<section id="tree-pruning">
<h3>트리 가지치기(Tree Pruning)<a class="headerlink" href="#tree-pruning" title="Link to this heading">#</a></h3>
<p>앞에서도 언급했듯이 위와 같은 방식으로 트리를 만들면 한 가지 문제가 생기는데, 트리가 너무 복잡해지고 커질 수 있다는 점이다. 그렇게 되면 훈련 세트에 대해서는 예측 성능이 좋을 수 있지만 데이터에 <strong>과적합</strong>(overfit)될 가능성이 있어 테스트 세트에 대해 성과가 나쁠 수 있다. 이를 해결하는 방법으로 분할을 더 적게 하는 것을 생각해 볼 수 있다. 즉, 영역 <span class="math notranslate nohighlight">\(R_1, ... ,R_J\)</span>의 개수를 줄이는 것이다. 이처럼 트리의 규모를 줄이면, 약간의 편향(bias)은 발생하겠지만, 분산(variance)이 줄어들고 해석도 더 용이해질 것이다.</p>
<p>분할 영역을 줄이는 데는 다양한 방법이 있을 수 있다. 가령 분할 시 RSS의 감소가 어떤 분계점(threshold)에 못 미치면 더 이상 분할을 하지 않는 것도 하나의 방법이다. 그러나 이 전략은 더 작은 트리를 만들기는 하겠지만, 근시안적인 결과를 낳을 위험이 있다. 왜냐하면 트리를 만드는 초기 단계에서는 RSS가 별로 감소하지 않다가 한참 뒤에야 RSS가 크게 감소하는 경우도 있을 수 있기 때문이다.</p>
<p>따라서 더 나은 전략은 매우 큰 트리 <span class="math notranslate nohighlight">\(T_0\)</span>를 만든 다음, 일부 가지를 쳐내는 소위 <strong>가지치기</strong>(pruning)를 통해 그것의 부분트리(subtree)를 얻는 것이다. 트리를 가지치기하는 가장 좋은 방법은 무엇일까? 우리의 목표는 명확하다. 즉 테스트 오류율 또는 오차가 가장 작은 부분트리를 선택하는 것이다. 일단 부분트리가 주어지면 교차검증(cross-validation) 또는 검증 세트(validation set)로 테스트 오차를 추정할 수 있다. 그렇다고 모든 가능한 부분트리들을 다 고려하는 것은 너무 경우의 수가 많기 때문에 보다 작은 부분트리 집합을 선택하는 방법이 필요하다.</p>
<p><strong>비용-복잡성 가지치기</strong></p>
<p>이런 목적에 부합하는 것이 <strong>비용-복잡성 가지치기</strong>(cost-complexity pruning)이다. 주어진 최초의 큰 트리를 <span class="math notranslate nohighlight">\(T_0\)</span>라 하고, 이것의 부분트리를 <span class="math notranslate nohighlight">\(T\)</span>라 하자. 즉 <span class="math notranslate nohighlight">\(T \subset T_0\)</span>이다. 트리 <span class="math notranslate nohighlight">\(T\)</span>의 끝마디 개수를 <span class="math notranslate nohighlight">\(|T|\)</span>로 표시하기로 하자. 비용-복잡성 가지치기는 0 또는 플러스 값을 갖는 조정 파라미터(tuning parameter) <span class="math notranslate nohighlight">\(\alpha\)</span>가 주어질 때, 다음 식을 최소화하는 <span class="math notranslate nohighlight">\(|T|\)</span>를 찾는 기법이다.</p>
<div class="math notranslate nohighlight">
\[
\sum_{m=1}^{|T|}\sum_{i:~ x_i\in R_m} \left( y_i - \hat y_{R_m} \right)^2 + \alpha|T| \tag{12.4}
\]</div>
<p>여기서 <span class="math notranslate nohighlight">\(R_m\)</span>은 <span class="math notranslate nohighlight">\(m\)</span>번째 끝마디 영역을 가리키며, <span class="math notranslate nohighlight">\(\hat y_{R_m}\)</span>은 <span class="math notranslate nohighlight">\(R_m\)</span> 영역의 예상 반응값, 즉 <span class="math notranslate nohighlight">\(R_m\)</span>에 속한 훈련 관측의 평균 반응값이다.</p>
<p>위 식을 최소화하는 방식으로 가지치기를 할 경우, 조정 파라미터 <span class="math notranslate nohighlight">\(\alpha\)</span>는 부분트리의 복잡성과 훈련 데이터에 대한 적합성 간의 균형을 잡는 역할을 한다. 가령 <span class="math notranslate nohighlight">\(\alpha=0\)</span>인 경우에 최적의 부분트리 <span class="math notranslate nohighlight">\(T\)</span>는 다름 아닌 <span class="math notranslate nohighlight">\(T_0\)</span>가 된다. 왜냐하면 위 식에서 <span class="math notranslate nohighlight">\(\alpha|T|\)</span> 부분이 사라지면 훈련 오차, 즉 RSS 부분만 남기 때문이다. 그렇게 되면 최초의 트리인 <span class="math notranslate nohighlight">\(T_0\)</span>가 어떤 부분트리에 비해서도 RSS가 작다. 가령 <span class="math notranslate nohighlight">\(T_0\)</span>의 모든 끝마디에 하나의 관측만 속하게 될 정도로 트리가 크고 복잡해지면, RSS는 0이 된다.</p>
<p>그런데 <span class="math notranslate nohighlight">\(\alpha\)</span>가 0이 아니고, 가령 1과 같은 플러스 값을 갖는다면, 끝마디 개수가 많을수록 <span class="math notranslate nohighlight">\(\alpha|T|\)</span>의 값이 커진다. 즉 끝마디 개수가 많은 복잡한 트리일수록 <span class="math notranslate nohighlight">\(\alpha|T|\)</span>만큼의 댓가를 지불해야 한다. 이 부분이 비용 항목으로 작용하는 것이다. 이 항목 때문에 가지치기된 더 작은 부분트리가 선택된다. 사실 식 12.4는 이전 장에서 다룬 <strong>라쏘</strong>(lasso)를 연상시킨다. 라쏘도 선형 모델의 복잡성을 통제하기 위해 유사한 식을 사용한다.</p>
<p>문제는 <span class="math notranslate nohighlight">\(\alpha\)</span>값을 어떻게 정하느냐인데, 교차검증 방식으로 최적의 <span class="math notranslate nohighlight">\(\alpha\)</span>값을 선택할 수 있다. 즉 다양한 <span class="math notranslate nohighlight">\(\alpha\)</span>값 후보에 대해 식 12.4를 최소화하는 최적의 부분트리를 구한 다음, 검증 세트를 사용해 예측오차(mean squared prediction error)를 계산한다. 교차검증의 경우 폴드를 교차해 가면서 이 작업을 반복하면, 각 폴드마다 <span class="math notranslate nohighlight">\(\alpha\)</span>값 별로 여러 개의 예측오차가 나오기 때문에, 최종적으로는 전체 폴드에 걸쳐 예측오차를 평균하여 그 값이 가장 작은 <span class="math notranslate nohighlight">\(\alpha\)</span>값을 선택하는 것이다. 그런 다음 다시 전체 데이터 세트로 돌아가서 선택된 <span class="math notranslate nohighlight">\(\alpha\)</span>에 해당하는 부분트리를 구하면 된다.</p>
</section>
<section id="id9">
<h3>회귀 트리 예제<a class="headerlink" href="#id9" title="Link to this heading">#</a></h3>
<p>출처: <a class="reference external" href="https://www.statlearning.com/">ISLP</a>, pp.336-339.</p>
<p>아래 그림 12.3과 12.4는 <code class="docutils literal notranslate"><span class="pre">Hitters</span></code> 데이터세트에 들어있는 총 19개 예측변수 중 9개 특성을 사용하여 회귀 트리를 피팅한 결과이다. 관측이 총 263개인데, 이를 무작위로 반으로 나누어 훈련 세트 관측이 132개이고, 테스트 세트 관측이 131개이다.</p>
<p>먼저 훈련 데이터를 사용해 일차적으로 큰 트리를 만들었다. 그 결과가 그림 12.3에 나와 있는 트리이다. 그런 다음 가지치기를 통해 끝마디 개수를 하나씩 줄여가면서 부분트리들을 생성하였다.(이는 식 12.4의 <span class="math notranslate nohighlight">\(\alpha\)</span>값을 변경함으로써 수행된다.)</p>
<p>가지치기를 하지 않은 그림 12.3의 트리를 보면, 끝마디가 총 12개이다. 이 트리에 대해 가지치기를 통해 끝마디 개수를 하나씩 줄여나가 최종적으로는 끝마디 개수가 1개인 트리에 이르기까지 가지치기를 진행했다.(끝마디가 1개인 트리는 사실상 분할이 전혀 이루어지지 않은 상태를 말함.) 이 과정에서 훈련 세트 및 테스트 세트에 대해 예측 오차인 MSE를 계속 측정한다. 그 결과가 그림 12.4에 나와 있는데, 검은색이 훈련 세트에 대한 MSE이고, 오렌지색이 테스트 세트에 대한 MSE이다.(가로축 “Tree Size”는 끝마디 개수를 나타냄.) 전체적으로 테스트 세트 오류가 훈련 세트 오류보다 큰 것을 알 수 있다. 각 MSE 값의 위아래로는 그것의 표준편차 추정치, 즉 표준오차도 표시돼 있다.</p>
<p>한편, 위 작업과 함께 교차검증도 진행했다. 훈련 세트의 일부를 검증 세트로 남겨 놓는 식으로 서로 교차해가면서 트리를 만들고 그것을 검증 세트에 적용해 MSE를 계산한 다음, 그것들을 평균화하는 작업이다.(훈련 관측 개수 132가 6의 배수라서 6중 교차검증을 수행함.) 이 교차검증 역시 가장 큰 트리에서 시작해 가지치기를 통해 끝마디 개수를 하나씩 줄여가면서 검증 세트에 대해 MSE를 계산했다. 그 결과가 그림 12.4에서 녹색으로 표시돼 있다. 교차검증 오차는 테스트 오차의 합리적 근사값이다. 그림을 보면, 교차검증 오차는 끝마디가 3개인 트리에서 최소값을 취하는 반면, 테스트 오차는 끝마디가 3개인 트리에서도 감소하며, 끝마디가 10개인 트리에서 최소화된다. 교차검증 오차가 끝마디 3개 트리에서 최소화되기 때문에 그림 12.3의 큰 트리에 대해 3개의 끝마디를 갖도록 가지치기된 트리가 이 장의 맨 앞 그림 12.1에 나와 있다.</p>
<p><strong>그림 12.3.</strong> <code class="docutils literal notranslate"><span class="pre">Hitters</span></code> 데이터에 대한 회귀 트리 분석. 훈련 데이터에 대해 하향식 탐욕적 분할로 트리를 만든 것으로 가지치기를 하지 않은 상태이다.</p>
<p><img alt="Hitters 회귀 트리 분석 1" src="https://raw.githubusercontent.com/pilsunchoi/images/main/12-7.png" /></p>
<ul class="simple">
<li><p>그림 출처: ISLP, FIGURE 8.4</p></li>
</ul>
<p><strong>그림 12.4.</strong> <code class="docutils literal notranslate"><span class="pre">Hitters</span></code> 데이터에 대한 회귀 트리 분석. 가지치기를 통해 끝마디 개수의 함수로 MSE를 구했다. 훈련 MSE(검은색), 교차검증 MSE(녹색), 테스트 MSE(오렌지색)가 동그라미 점으로 표시돼 있다. 각 MSE 값 위아래로는 표준오차 밴드가 표시돼 있다. 끝마디가 3개일 때, 교차검증 오류가 가장 작다.</p>
<p><img alt="Hitters 회귀 트리 분석 2" src="https://raw.githubusercontent.com/pilsunchoi/images/main/12-8.png" /></p>
<ul class="simple">
<li><p>그림 출처: ISLP, FIGURE 8.5</p></li>
</ul>
</section>
</section>
<section id="id10">
<h2>12.3 분류 트리 만들기<a class="headerlink" href="#id10" title="Link to this heading">#</a></h2>
<p>분류 트리(classification tree)는 반응변수가 정량적이 아니라 정성적이라는 점만 빼면 회귀 트리와 매우 유사하다. 회귀 트리의 경우 어떤 관측에 대한 예측은 그 관측이 속한 영역(즉 끝마디)에 해당하는 <strong>훈련 관측의 평균 반응값</strong>이다. 분류 트리의 경우에도 이와 비슷한데, 단지 반응변수가 정량적 변수가 아니어서 평균값이 의미가 없기 때문에 그 대신 각 관측이 속한 영역(즉 끝마디)에서 가장 빈도수가 높은 훈련 관측 범주로 예측한다. 즉 범주별로 훈련 관측 개수를 세어 <strong>다수결의 원칙에 따라 해당 영역의 범주를 예측</strong>한다.</p>
<p>분류 트리를 만드는 작업은 회귀 트리를 만드는 작업과 매우 유사하다. 즉 회귀와 마찬가지로 반복 이항 분할을 사용하여 분류 트리를 만들어 나간다. 그런데 분류가 회귀와 다른 점 한 가지는 이항 분할을 할 때 잔차제곱합(RSS)을 사용할 수 없다는 점이다. 왜냐하면 반응변수가 숫자가 아니라 범주이기 때문에 RSS를 계산할 수도 없고 굳이 계산하더라도 적절한 평가도구가 아니다.</p>
<p>분류 문제에 있어서 RSS의 자연스러운 대안은 <strong>불순도</strong>(impurity)이다. 불순도 개념을 이해하기 위해 RSS를 다시 한 번 생각해보자. 회귀 트리처럼 반응변수가 숫자형인 경우에는 예측값과 실제값의 차이, 즉 오차(error) 또는 잔차(residual)로 모형의 적합성을 평가할 수 있다. 오차가 클수록 모형의 적합성이 떨어지는 것을 의미하기 때문에 우리는 RSS를 최소화하는 방식으로 반복 이항 분할을 해나간다.</p>
<p>이와 유사하게, 분류 트리에 있어서는 예측 범주와 실제 범주의 차이, 즉 오분류(classification error)와 관련된 지표를 사용하여 모형의 적합성을 평가하는 것이 적절하며, 그것을 “불순도”라고 표현할 수 있다. 가령 이항 분할의 결과, 모든 (훈련) 관측들에 대해 예측 범주와 실제 범주가 동일하다면 오분류가 하나도 없기 때문에 “완전히 깨끗한”(pure) 상태라고 표현할 수 있고, 반대로 오분류된 케이스들이 있는 것을 “오염된” 상태로 표현하는 것이다. 이런 맥락에서 “불순도”라는 표현을 사용하는 것이다. 그렇다면 불순도를 어떻게 측정하는 것이 좋을까? 몇 가지 방법들이 있는데, 아래 예를 통해 설명하기로 한다.</p>
<section id="id11">
<h3>분류 트리 만들기 간단한 예<a class="headerlink" href="#id11" title="Link to this heading">#</a></h3>
<p>가장 간단한 데이터를 사용하여 직접 분류 트리를 만들어 보자. 사용할 데이터세트는 관측이 단 3개인 <code class="docutils literal notranslate"><span class="pre">Hitters</span></code> 데이터세트이다. 예제 데이터세트는 다음과 같다.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{c|cccc}
n &amp; \text{Years} &amp; \text{Hits} &amp; \text{Salary} \\
\hline
1 &amp; 10 &amp; 100 &amp; \text{High} \\
2 &amp; 2 &amp; 140 &amp; \text{Low} \\
3 &amp; 10 &amp; 170 &amp; \text{High} \\
\end{array}
\end{split}\]</div>
<p>각 변수의 의미는 앞 절에서 설명한 대로이다. 단, 연봉을 의미하는 <code class="docutils literal notranslate"><span class="pre">Salary</span></code> 변수가 이번에는 숫자형 변수가 아니라 <code class="docutils literal notranslate"><span class="pre">High</span></code>와 <code class="docutils literal notranslate"><span class="pre">Low</span></code>의 두 개 범주를 가진 정성적 변수라는 점이 앞 절과 다르다. 앞의 회귀 트리 사례와 모두 동일하고, 단지 Salary(로그) 값이 7.0 이상이면 <code class="docutils literal notranslate"><span class="pre">High</span></code> 범주로 분류했고, 7.0 미만이면 <code class="docutils literal notranslate"><span class="pre">Low</span></code> 범주로 분류했다는 점만 다르다. 반응변수가 범주로 주어졌다는 점만 다르고 나머지는 똑같기 때문에 이를 이용하여 만든 분류 트리도 앞의 회귀 트리와 크게 봐서는 비슷할 것으로 짐작할 수 있다. 이하 분류 트리 작성에 대한 설명은 앞의 회귀 트리 사례와 거의 동일해서 다소 지루할 수 있지만 생략 없이 다시 한 번 반복하기로 한다.</p>
<p><strong>뿌리마디</strong></p>
<ul class="simple">
<li><p>트리를 만들기 위해서는 우선 아래 그림처럼 뿌리마디부터 정해야 한다. 즉 “어떤 변수”에 대해 “어떤 절단점”을 사용할 것인지를 정해야 한다.</p></li>
</ul>
<p><img alt="분류 트리 만들기 1" src="https://raw.githubusercontent.com/pilsunchoi/images/main/12-9.png" /></p>
<ul class="simple">
<li><p>우리는 앞의 회귀 트리에서는 “RSS 최소화”를 기준으로 변수와 절단점을 구했는데, 분류 트리에서는 “불순도 최소화”를 기준으로 한다.</p></li>
<li><p>우선 <code class="docutils literal notranslate"><span class="pre">Years</span></code>부터 시작해보면, 관측값이 2와 10 두 개뿐이고, 그 중간점은 6이다. 따라서 6을 기준으로 그 미만과 그 이상으로 나눈다.</p></li>
<li><p>먼저 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(&lt;6\)</span> 영역에는 2번 선수 한 명밖에 없기 때문에 그의 연봉 범주가 곧 이 영역의 <code class="docutils literal notranslate"><span class="pre">Salary</span></code> 범주가 되고, 그것은 <code class="docutils literal notranslate"><span class="pre">Low</span></code>이다. 반대 영역인 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(\ge6\)</span>에는 1번과 3번 선수가 해당하며, 이 두 선수 모두 <code class="docutils literal notranslate"><span class="pre">Salary</span></code> 범주가 <code class="docutils literal notranslate"><span class="pre">High</span></code>이기 때문에 다수결의 원칙에 따라 이 영역의 <code class="docutils literal notranslate"><span class="pre">Salary</span></code> 범주는 <code class="docutils literal notranslate"><span class="pre">High</span></code>가 된다.</p></li>
<li><p>이렇게 분할이 이루어졌을 때, 소위 불순도를 생각해보자. 이 경우는 깊이 생각할 것도 없이 불순도는 0이 되어야 할 것이다. 왜냐하면 모든 관측이 예측 범주와 실제 범주가 일치하기 때문이다. 완전히 깨끗한(pure) 분할인 것이다. 불순도를 측정하는 지표는 이런 경우 0의 값을 반환해야 할 것이다. 불순도를 측정하는 대표적 도구인 <strong>지니 지수</strong>(Gini index)를 사용해 불순도를 측정해보자. 이 경우 지니 지수는 다음과 같다.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
G = \hat p_{H}\left(1-\hat p_{H} \right) + \hat p_{L}\left(1-\hat p_{L} \right)
\]</div>
<ul class="simple">
<li><p>여기서 <span class="math notranslate nohighlight">\(\hat p_{H}\)</span>는 주어진 영역에서 <code class="docutils literal notranslate"><span class="pre">Salary</span></code>가 <code class="docutils literal notranslate"><span class="pre">High</span></code>인 훈련 관측 비율이고, <span class="math notranslate nohighlight">\(\hat p_{L}\)</span>은 <code class="docutils literal notranslate"><span class="pre">Salary</span></code>가 <code class="docutils literal notranslate"><span class="pre">Low</span></code>인 훈련 관측 비율을 나타낸다. 이 식을 이용해 앞서 설명한 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(=6\)</span>을 경계로 한 이항 분할의 지니 지수를 계산하면, 우선 왼쪽 가지(즉 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(&lt;6\)</span> 영역)에서는 모든 관측의 <code class="docutils literal notranslate"><span class="pre">Salary</span></code>가 <code class="docutils literal notranslate"><span class="pre">Low</span></code>이기 때문에 <span class="math notranslate nohighlight">\(\hat p_{L}=1\)</span>이고, <span class="math notranslate nohighlight">\(\hat p_{H}=0\)</span>이다. 따라서 왼쪽 가지의 지니 지수는 <span class="math notranslate nohighlight">\(G_{\text{Left}}=0\times(1-0)+1\times(1-1)=0\)</span>이다. 마찬가지 방식으로 오른쪽 가지(즉 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(\ge 6\)</span> 영역)의 지니 지수를 구하면, 여기에서는 모든 관측의 <code class="docutils literal notranslate"><span class="pre">Salary</span></code>가 <code class="docutils literal notranslate"><span class="pre">High</span></code>이기 때문에 <span class="math notranslate nohighlight">\(\hat p_{L}=0\)</span>이고, <span class="math notranslate nohighlight">\(\hat p_{H}=1\)</span>이다. 따라서 오른쪽 가지의 지니 지수는 <span class="math notranslate nohighlight">\(G_{\text{Right}}=1\times(1-1)+0\times(1-0)=0\)</span>이다. 결국 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(=6\)</span>을 경계로 한 이항 분할의 지니 지수는 이들 두 개의 지니 지수를 평균하면 된다. 마치 회귀 트리에서 RSS를 계산할 때, 왼쪽 가지와 오른쪽 가지의 RSS를 합친 것과 같은 맥락이다. 단, 두 개 지니 지수를 평균할 때, 단순 평균보다는 영역별 관측 개수를 가중치로 하여 가중 평균을 구하는 것이 더 적절할 것이다. 따라서 우리 경우에 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(=6\)</span>을 경계로 한 이항 분할의 지니 지수는 다음 계산에 의해 0이 된다.(오분류가 전혀 없는 완전히 깨끗한 분할이다.)</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\left( \frac{1}{1+2} \right) \times G_{\text{Left}} + \left( \frac{2}{1+2} \right) \times G_{\text{Right}} = 0
\]</div>
<hr class="docutils" />
<ul class="simple">
<li><p>이번에는 또 다른 입력변수인 <code class="docutils literal notranslate"><span class="pre">Hits</span></code>를 기준으로 분할해보자. <code class="docutils literal notranslate"><span class="pre">Hits</span></code>는 값이 100, 140, 170 세 개이기 때문에 100과 140의 중간점(즉 120), 그리고 140과 170의 중간점(즉 155) 등 두 곳을 절단점으로 고려해야 한다.</p></li>
<li><p>우선 첫 번째 절단점 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(=120\)</span>을 기준으로 그 미만과 그 이상으로 나눈다. 먼저 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(&lt;120\)</span> 영역에는 1번 선수 한 명밖에 없기 때문에 그의 연봉 범주가 곧 이 영역의 <code class="docutils literal notranslate"><span class="pre">Salary</span></code> 범주가 되고, 그것은 <code class="docutils literal notranslate"><span class="pre">High</span></code>이다. 반대 영역인 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(\ge120\)</span>에는 2번과 3번 선수가 여기에 해당하는데, 이들의 범주가 <code class="docutils literal notranslate"><span class="pre">Low</span></code>와 <code class="docutils literal notranslate"><span class="pre">High</span></code>로 엇갈려 다수결로 정할 수 없기 때문에, 여기에서 우리는 어떤 원칙을 정해야 한다. 이런 경우 무작위로 분류하는 등의 방법을 생각해볼 수 있지만, 여기에서는 두 범주의 빈도수가 동일할 때는 범주를 예측하지 않기로 하고 논의를 진행해보자.</p></li>
<li><p>이 상황에서 앞에서와 마찬가지 방식으로 지니 지수를 계산하면, 우선 이항 분할의 왼쪽 가지(즉 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(&lt;120\)</span> 영역)에서는 모든 관측의 <code class="docutils literal notranslate"><span class="pre">Salary</span></code>가 <code class="docutils literal notranslate"><span class="pre">High</span></code>이기 때문에 <span class="math notranslate nohighlight">\(\hat p_{H}=1\)</span>이고, <span class="math notranslate nohighlight">\(\hat p_{L}=0\)</span>이다. 따라서 왼쪽 가지의 지니 지수는 <span class="math notranslate nohighlight">\(G_{\text{Left}}=1\times(1-1)+0\times(1-0)=0\)</span>이다. 이번에는 오른쪽 가지(즉 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(\ge120\)</span> 영역)의 지니 지수를 구하면, 여기에서는 두 관측의 범주가 서로 엇갈려 <span class="math notranslate nohighlight">\(\hat p_{H}=0.5\)</span>이고, <span class="math notranslate nohighlight">\(\hat p_{L}=0.5\)</span>이다. 따라서 오른쪽 가지의 지니 지수는 <span class="math notranslate nohighlight">\(G_{\text{Right}}=0.5\times(1-0.5)+0.5\times(1-0.5)=0.5\)</span>이다. 결국 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(=120\)</span>을 경계로 한 이항 분할의 지니 지수는 이들 두 값을 가중평균하면 <span class="math notranslate nohighlight">\(
\left( \frac{1}{1+2} \right) \times G_{\text{Left}} + \left( \frac{2}{1+2} \right) \times G_{\text{Right}} = 0.333\)</span>이 된다. 우리는 이 경우 불순도가 0이 아니라 플러스 값을 갖는 것을 확인할 수 있다. 즉 분류 결과가 완전히 깨끗하지 않고 불순도가 섞여 있으며, 지니 지수로 평가한 불순도는 0.333으로 나왔다.</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>마지막으로 두 번째 절단점 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(=155\)</span>를 기준으로 그 미만과 그 이상으로 나눠 지니 지수를 구해보자. 먼저 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(&lt;155\)</span> 영역에는 1번과 2번 선수가 여기에 해당하는데, 이들의 범주가 <code class="docutils literal notranslate"><span class="pre">High</span></code>와 <code class="docutils literal notranslate"><span class="pre">Low</span></code>로 엇갈리기 때문에 이 경우에는 범주를 예측하지 않기로 한다. 그리고 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(\ge155\)</span> 영역에는 3번 선수 한 명밖에 없기 때문에 그의 연봉 범주가 곧 이 영역의 <code class="docutils literal notranslate"><span class="pre">Salary</span></code> 범주가 되고, 그것은 <code class="docutils literal notranslate"><span class="pre">High</span></code>이다.</p></li>
<li><p>이렇게 분할이 이뤄졌을 때의 지니 지수를 계산하면, 우선 이항 분할의 왼쪽 가지(즉 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(&lt;155\)</span> 영역)에서는 두 관측의 범주가 서로 엇갈려 <span class="math notranslate nohighlight">\(\hat p_{H}=0.5\)</span>이고, <span class="math notranslate nohighlight">\(\hat p_{L}=0.5\)</span>이다. 따라서 왼쪽 가지의 지니 지수는 <span class="math notranslate nohighlight">\(G_{\text{Left}}=0.5\times(1-0.5)+0.5\times(1-0.5)=0.5\)</span>이다. 이번에는 오른쪽 가지(즉 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(\ge155\)</span> 영역)의 지니 지수를 구하면, 모든 관측의 <code class="docutils literal notranslate"><span class="pre">Salary</span></code>가 <code class="docutils literal notranslate"><span class="pre">High</span></code>이기 때문에 <span class="math notranslate nohighlight">\(\hat p_{H}=1\)</span>이고, <span class="math notranslate nohighlight">\(\hat p_{L}=0\)</span>이다. 따라서 오른쪽 가지의 지니 지수는 <span class="math notranslate nohighlight">\(G_{\text{Right}}=1\times(1-1)+0\times(1-0)=0\)</span>이다. 결국 <code class="docutils literal notranslate"><span class="pre">Hits</span></code><span class="math notranslate nohighlight">\(=155\)</span>를 경계로 한 이항 분할의 지니 지수는 이들 두 값을 가중평균하면 <span class="math notranslate nohighlight">\(
\left( \frac{2}{1+2} \right) \times G_{\text{Left}} + \left( \frac{1}{1+2} \right) \times G_{\text{Right}} = 0.333\)</span>이 된다.</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>위에서 살펴 본 세 분할의 지니 지수 (<span class="math notranslate nohighlight">\(0\)</span>, <span class="math notranslate nohighlight">\(0.333\)</span>, <span class="math notranslate nohighlight">\(0.333\)</span>) 중에서 가장 작은 것은 당연히 첫 번째인 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(=6\)</span>을 기준으로 분할했을 때이다. 따라서 이것이 트리의 시작점인 뿌리마디가 된다. 즉 이제 트리는 다음과 같은 모습을 갖췄다.</p></li>
</ul>
<p><img alt="분류 트리 만들기 2" src="https://raw.githubusercontent.com/pilsunchoi/images/main/12-10.png" /></p>
<p><strong>중간마디 및 끝마디</strong></p>
<ul class="simple">
<li><p>앞에서 뿌리마디를 정했는데, 여기에서 왼쪽 가지는 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(&lt;6\)</span>이고, 오른쪽 가지는 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(\ge 6\)</span>을 의미한다. 이제는 이들 각 가지에서 다시 이항 분할을 따져봐야 한다. 그 기준과 절차는 뿌리마디를 찾을 때와 전적으로 동일하다.</p></li>
<li><p>먼저 뿌리마디의 왼쪽 가지 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(&lt;6\)</span>의 경우에는 여기에 속하는 관측이 한 개(즉 2번 선수)밖에 없기 때문에 더 이상 분할을 할 수 없다. 즉 왼쪽 가지는 그것이 끝마디가 된다. 그리고 이 끝마디에 속할 경우, <code class="docutils literal notranslate"><span class="pre">Salary</span></code> 예측 범주는 2번 선수의 연봉 범주인 <code class="docutils literal notranslate"><span class="pre">Low</span></code>가 된다. 따라서 트리는 다음과 같이 된다.</p></li>
</ul>
<p><img alt="분류 트리 만들기 3" src="https://raw.githubusercontent.com/pilsunchoi/images/main/12-11.png" /></p>
<ul class="simple">
<li><p>이번에는 뿌리마디의 오른쪽 가지인 <code class="docutils literal notranslate"><span class="pre">Years</span></code><span class="math notranslate nohighlight">\(\ge 6\)</span>을 보면, 여기에 속하는 관측이 1번과 3번 선수 두 명이다. 두 명이 속해 있기는 하지만 이 경우에도 더 이상 이항 분할을 할 필요가 없다. 왜냐하면 오른쪽 가지에 속한 두 명 모두의 연봉 범주가 <code class="docutils literal notranslate"><span class="pre">High</span></code>로 동일해 이미 불순도가 0에 도달해서 더 이상 분할해봐야 불순도가 개선될 수 없기 때문이다. 결국 오른쪽 가지 자체가 끝마디가 되고, <code class="docutils literal notranslate"><span class="pre">Salary</span></code> 예측 범주는 (1번과 3번 선수의 연봉 범주가 모두 <code class="docutils literal notranslate"><span class="pre">High</span></code>이기 때문에) <code class="docutils literal notranslate"><span class="pre">High</span></code>가 된다.</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>이것으로 트리 작성은 끝났으며, 지금까지의 결과를 종합하면 트리의 최종적인 모습은 다음과 같다.</p></li>
</ul>
<p><img alt="분류 트리 만들기 4" src="https://raw.githubusercontent.com/pilsunchoi/images/main/12-12.png" /></p>
<ul class="simple">
<li><p>가령 어떤 선수가 메이저리그 경력 8년차이고, 전년도 안타수가 120개라면, 이 선수의 연봉 범주는 <code class="docutils literal notranslate"><span class="pre">High</span></code>로 예측된다.</p></li>
<li><p>회귀 트리에서와 마찬가지로, 관측 개수와 예측변수 개수가 많아지면 트리가 엄청나게 커지게 될 것이다. 따라서 어느 단계에서 트리의 성장을 중단시킬 필요가 있다.</p></li>
</ul>
</section>
<section id="id12">
<h3>분류 트리 코딩<a class="headerlink" href="#id12" title="Link to this heading">#</a></h3>
<p>지금까지 수작업으로 작성한 결정 트리를 파이썬 코딩으로 실행해보자. 분류 트리 모델 피팅은 사이킷런(<code class="docutils literal notranslate"><span class="pre">sklearn</span></code>)의 <code class="docutils literal notranslate"><span class="pre">tree</span></code> 모듈에 들어있는 <code class="docutils literal notranslate"><span class="pre">DecisionTreeClassifier()</span></code> 함수를 이용하면 된다.</p>
<p><strong>예제 데이터세트 입력</strong></p>
<p>위에서 예시로 사용한 데이터를 입력한다. 여기에서는 <code class="docutils literal notranslate"><span class="pre">Salary1</span></code>이라는 더미변수를 만들어 <code class="docutils literal notranslate"><span class="pre">Salary</span></code>가 7 미만이면 0을 부여하고, 7 이상이면 1을 부여했다. 즉 <code class="docutils literal notranslate"><span class="pre">Salary1</span></code>은 고연봉 더미변수이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Years</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">Hits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">140</span><span class="p">,</span> <span class="mi">170</span><span class="p">]</span>
<span class="n">Salary</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>

<span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Years&#39;</span><span class="p">:</span> <span class="n">Years</span><span class="p">,</span> <span class="s1">&#39;Hits&#39;</span><span class="p">:</span> <span class="n">Hits</span><span class="p">,</span> <span class="s1">&#39;Salary&#39;</span><span class="p">:</span> <span class="n">Salary</span><span class="p">}</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;Salary1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">Salary</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">7</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">df</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Years</th>
      <th>Hits</th>
      <th>Salary</th>
      <th>Salary1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>10</td>
      <td>100</td>
      <td>8</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>140</td>
      <td>4</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10</td>
      <td>170</td>
      <td>10</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p><strong>분류 트리 피팅 실행</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">Years</span></code>와 <code class="docutils literal notranslate"><span class="pre">Hits</span></code>을 예측변수 <code class="docutils literal notranslate"><span class="pre">X</span></code>로 하고, <code class="docutils literal notranslate"><span class="pre">Salary1</span></code>을 반응변수 <code class="docutils literal notranslate"><span class="pre">y</span></code>로 지정한 다음, <code class="docutils literal notranslate"><span class="pre">DecisionTreeClassifier()</span></code> 함수를 사용하여 분류 트리 모델의 내용을 정한다. 주요 파라미터 값을 지정해야 하는데, 여기에서는 모두 기본값(default)을 사용하기 위해 인수를 전혀 입력하지 않았다.</p>
<p>분류 트리의 이항 분할을 할 때, 불순도 측정 도구로서 지니 지수 외에 엔트로피 등이 있다. <code class="docutils literal notranslate"><span class="pre">DecisionTreeClassifier()</span></code> 함수의 경우, 지니 지수가 기본값(즉, <code class="docutils literal notranslate"><span class="pre">criterion='gini'</span></code>)이다. 이를 엔트로피로 바꾸고 싶으면, <code class="docutils literal notranslate"><span class="pre">criterion='entropy'</span></code>로 하면 된다.</p>
<p>이 모형을 <code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드를 사용해 데이터(<code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>)에 피팅시킨다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;Years&#39;</span><span class="p">,</span> <span class="s1">&#39;Hits&#39;</span><span class="p">]]</span> 
<span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">Salary1</span>

<span class="n">clf</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">()</span>
<span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><style>#sk-container-id-2 {
  /* Definition of color scheme common for light and dark mode */
  --sklearn-color-text: black;
  --sklearn-color-line: gray;
  /* Definition of color scheme for unfitted estimators */
  --sklearn-color-unfitted-level-0: #fff5e6;
  --sklearn-color-unfitted-level-1: #f6e4d2;
  --sklearn-color-unfitted-level-2: #ffe0b3;
  --sklearn-color-unfitted-level-3: chocolate;
  /* Definition of color scheme for fitted estimators */
  --sklearn-color-fitted-level-0: #f0f8ff;
  --sklearn-color-fitted-level-1: #d4ebff;
  --sklearn-color-fitted-level-2: #b3dbfd;
  --sklearn-color-fitted-level-3: cornflowerblue;

  /* Specific color for light theme */
  --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
  --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, white)));
  --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
  --sklearn-color-icon: #696969;

  @media (prefers-color-scheme: dark) {
    /* Redefinition of color scheme for dark theme */
    --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
    --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, #111)));
    --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
    --sklearn-color-icon: #878787;
  }
}

#sk-container-id-2 {
  color: var(--sklearn-color-text);
}

#sk-container-id-2 pre {
  padding: 0;
}

#sk-container-id-2 input.sk-hidden--visually {
  border: 0;
  clip: rect(1px 1px 1px 1px);
  clip: rect(1px, 1px, 1px, 1px);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}

#sk-container-id-2 div.sk-dashed-wrapped {
  border: 1px dashed var(--sklearn-color-line);
  margin: 0 0.4em 0.5em 0.4em;
  box-sizing: border-box;
  padding-bottom: 0.4em;
  background-color: var(--sklearn-color-background);
}

#sk-container-id-2 div.sk-container {
  /* jupyter's `normalize.less` sets `[hidden] { display: none; }`
     but bootstrap.min.css set `[hidden] { display: none !important; }`
     so we also need the `!important` here to be able to override the
     default hidden behavior on the sphinx rendered scikit-learn.org.
     See: https://github.com/scikit-learn/scikit-learn/issues/21755 */
  display: inline-block !important;
  position: relative;
}

#sk-container-id-2 div.sk-text-repr-fallback {
  display: none;
}

div.sk-parallel-item,
div.sk-serial,
div.sk-item {
  /* draw centered vertical line to link estimators */
  background-image: linear-gradient(var(--sklearn-color-text-on-default-background), var(--sklearn-color-text-on-default-background));
  background-size: 2px 100%;
  background-repeat: no-repeat;
  background-position: center center;
}

/* Parallel-specific style estimator block */

#sk-container-id-2 div.sk-parallel-item::after {
  content: "";
  width: 100%;
  border-bottom: 2px solid var(--sklearn-color-text-on-default-background);
  flex-grow: 1;
}

#sk-container-id-2 div.sk-parallel {
  display: flex;
  align-items: stretch;
  justify-content: center;
  background-color: var(--sklearn-color-background);
  position: relative;
}

#sk-container-id-2 div.sk-parallel-item {
  display: flex;
  flex-direction: column;
}

#sk-container-id-2 div.sk-parallel-item:first-child::after {
  align-self: flex-end;
  width: 50%;
}

#sk-container-id-2 div.sk-parallel-item:last-child::after {
  align-self: flex-start;
  width: 50%;
}

#sk-container-id-2 div.sk-parallel-item:only-child::after {
  width: 0;
}

/* Serial-specific style estimator block */

#sk-container-id-2 div.sk-serial {
  display: flex;
  flex-direction: column;
  align-items: center;
  background-color: var(--sklearn-color-background);
  padding-right: 1em;
  padding-left: 1em;
}


/* Toggleable style: style used for estimator/Pipeline/ColumnTransformer box that is
clickable and can be expanded/collapsed.
- Pipeline and ColumnTransformer use this feature and define the default style
- Estimators will overwrite some part of the style using the `sk-estimator` class
*/

/* Pipeline and ColumnTransformer style (default) */

#sk-container-id-2 div.sk-toggleable {
  /* Default theme specific background. It is overwritten whether we have a
  specific estimator or a Pipeline/ColumnTransformer */
  background-color: var(--sklearn-color-background);
}

/* Toggleable label */
#sk-container-id-2 label.sk-toggleable__label {
  cursor: pointer;
  display: block;
  width: 100%;
  margin-bottom: 0;
  padding: 0.5em;
  box-sizing: border-box;
  text-align: center;
}

#sk-container-id-2 label.sk-toggleable__label-arrow:before {
  /* Arrow on the left of the label */
  content: "▸";
  float: left;
  margin-right: 0.25em;
  color: var(--sklearn-color-icon);
}

#sk-container-id-2 label.sk-toggleable__label-arrow:hover:before {
  color: var(--sklearn-color-text);
}

/* Toggleable content - dropdown */

#sk-container-id-2 div.sk-toggleable__content {
  max-height: 0;
  max-width: 0;
  overflow: hidden;
  text-align: left;
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-2 div.sk-toggleable__content.fitted {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

#sk-container-id-2 div.sk-toggleable__content pre {
  margin: 0.2em;
  border-radius: 0.25em;
  color: var(--sklearn-color-text);
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-2 div.sk-toggleable__content.fitted pre {
  /* unfitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

#sk-container-id-2 input.sk-toggleable__control:checked~div.sk-toggleable__content {
  /* Expand drop-down */
  max-height: 200px;
  max-width: 100%;
  overflow: auto;
}

#sk-container-id-2 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {
  content: "▾";
}

/* Pipeline/ColumnTransformer-specific style */

#sk-container-id-2 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-2 div.sk-label.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Estimator-specific style */

/* Colorize estimator box */
#sk-container-id-2 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-2 div.sk-estimator.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-2);
}

#sk-container-id-2 div.sk-label label.sk-toggleable__label,
#sk-container-id-2 div.sk-label label {
  /* The background is the default theme color */
  color: var(--sklearn-color-text-on-default-background);
}

/* On hover, darken the color of the background */
#sk-container-id-2 div.sk-label:hover label.sk-toggleable__label {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-unfitted-level-2);
}

/* Label box, darken color on hover, fitted */
#sk-container-id-2 div.sk-label.fitted:hover label.sk-toggleable__label.fitted {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Estimator label */

#sk-container-id-2 div.sk-label label {
  font-family: monospace;
  font-weight: bold;
  display: inline-block;
  line-height: 1.2em;
}

#sk-container-id-2 div.sk-label-container {
  text-align: center;
}

/* Estimator-specific */
#sk-container-id-2 div.sk-estimator {
  font-family: monospace;
  border: 1px dotted var(--sklearn-color-border-box);
  border-radius: 0.25em;
  box-sizing: border-box;
  margin-bottom: 0.5em;
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-2 div.sk-estimator.fitted {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

/* on hover */
#sk-container-id-2 div.sk-estimator:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-2 div.sk-estimator.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Specification for estimator info (e.g. "i" and "?") */

/* Common style for "i" and "?" */

.sk-estimator-doc-link,
a:link.sk-estimator-doc-link,
a:visited.sk-estimator-doc-link {
  float: right;
  font-size: smaller;
  line-height: 1em;
  font-family: monospace;
  background-color: var(--sklearn-color-background);
  border-radius: 1em;
  height: 1em;
  width: 1em;
  text-decoration: none !important;
  margin-left: 1ex;
  /* unfitted */
  border: var(--sklearn-color-unfitted-level-1) 1pt solid;
  color: var(--sklearn-color-unfitted-level-1);
}

.sk-estimator-doc-link.fitted,
a:link.sk-estimator-doc-link.fitted,
a:visited.sk-estimator-doc-link.fitted {
  /* fitted */
  border: var(--sklearn-color-fitted-level-1) 1pt solid;
  color: var(--sklearn-color-fitted-level-1);
}

/* On hover */
div.sk-estimator:hover .sk-estimator-doc-link:hover,
.sk-estimator-doc-link:hover,
div.sk-label-container:hover .sk-estimator-doc-link:hover,
.sk-estimator-doc-link:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

div.sk-estimator.fitted:hover .sk-estimator-doc-link.fitted:hover,
.sk-estimator-doc-link.fitted:hover,
div.sk-label-container:hover .sk-estimator-doc-link.fitted:hover,
.sk-estimator-doc-link.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

/* Span, style for the box shown on hovering the info icon */
.sk-estimator-doc-link span {
  display: none;
  z-index: 9999;
  position: relative;
  font-weight: normal;
  right: .2ex;
  padding: .5ex;
  margin: .5ex;
  width: min-content;
  min-width: 20ex;
  max-width: 50ex;
  color: var(--sklearn-color-text);
  box-shadow: 2pt 2pt 4pt #999;
  /* unfitted */
  background: var(--sklearn-color-unfitted-level-0);
  border: .5pt solid var(--sklearn-color-unfitted-level-3);
}

.sk-estimator-doc-link.fitted span {
  /* fitted */
  background: var(--sklearn-color-fitted-level-0);
  border: var(--sklearn-color-fitted-level-3);
}

.sk-estimator-doc-link:hover span {
  display: block;
}

/* "?"-specific style due to the `<a>` HTML tag */

#sk-container-id-2 a.estimator_doc_link {
  float: right;
  font-size: 1rem;
  line-height: 1em;
  font-family: monospace;
  background-color: var(--sklearn-color-background);
  border-radius: 1rem;
  height: 1rem;
  width: 1rem;
  text-decoration: none;
  /* unfitted */
  color: var(--sklearn-color-unfitted-level-1);
  border: var(--sklearn-color-unfitted-level-1) 1pt solid;
}

#sk-container-id-2 a.estimator_doc_link.fitted {
  /* fitted */
  border: var(--sklearn-color-fitted-level-1) 1pt solid;
  color: var(--sklearn-color-fitted-level-1);
}

/* On hover */
#sk-container-id-2 a.estimator_doc_link:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

#sk-container-id-2 a.estimator_doc_link.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-3);
}
</style><div id="sk-container-id-2" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>DecisionTreeClassifier()</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item"><div class="sk-estimator fitted sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-2" type="checkbox" checked><label for="sk-estimator-id-2" class="sk-toggleable__label fitted sk-toggleable__label-arrow fitted">&nbsp;&nbsp;DecisionTreeClassifier<a class="sk-estimator-doc-link fitted" rel="noreferrer" target="_blank" href="https://scikit-learn.org/1.5/modules/generated/sklearn.tree.DecisionTreeClassifier.html">?<span>Documentation for DecisionTreeClassifier</span></a><span class="sk-estimator-doc-link fitted">i<span>Fitted</span></span></label><div class="sk-toggleable__content fitted"><pre>DecisionTreeClassifier()</pre></div> </div></div></div></div></div></div>
</div>
<p><strong>트리 그림 그리기</strong></p>
<p>피팅이 끝난 트리(”<code class="docutils literal notranslate"><span class="pre">clf</span></code>”)를 <code class="docutils literal notranslate"><span class="pre">plot_tree()</span></code> 함수를 사용해 그림으로 그린다. <code class="docutils literal notranslate"><span class="pre">class_names</span></code> 파라미터를 사용해 반응변수의 범주 이름을 입력하면 트리 결과를 이해하는 데 도움이 된다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;Years&#39;</span><span class="p">,</span> <span class="s1">&#39;Hits&#39;</span><span class="p">]]</span> 
<span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">Salary1</span>

<span class="n">clf</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">()</span>
<span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">plot_tree</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span>
                   <span class="n">feature_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Years&#39;</span><span class="p">,</span> <span class="s1">&#39;Hits&#39;</span><span class="p">],</span>
                   <span class="n">class_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Low&#39;</span><span class="p">,</span> <span class="s1">&#39;High&#39;</span><span class="p">],</span>
                   <span class="n">filled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">fontsize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>위 결과를 보면, 내용이 앞에서 우리가 수작업으로 도출한 트리와 동일한 것을 확인할 수 있다.</p>
<p>위 트리 그림의 모든 마디에 지니 지수(<code class="docutils literal notranslate"><span class="pre">gini</span></code>)가 적혀 있는데, 이것은 (이항 분할 하기 전) 해당 마디에 있어서의 지니 지수를 계산한 것이다. 끝마디의 경우에는 모든 관측의 범주가 동일하기 때문에 당연히 불순도(즉 지니 지수)가 0이다. 위 결과에서 뿌리마디의 경우, <code class="docutils literal notranslate"><span class="pre">gini=0.444</span></code>로 돼있는데, 확인 차원에서 이것을 계산해보자. 우선 세 개 관측의 범주를 보면, <code class="docutils literal notranslate"><span class="pre">High</span></code>가 2개이고, <code class="docutils literal notranslate"><span class="pre">Low</span></code>가 1개이기 때문에 <span class="math notranslate nohighlight">\(\hat p_{H}=\frac{2}{3}\)</span>이고, <span class="math notranslate nohighlight">\(\hat p_{L}=\frac{1}{3}\)</span>이다. 따라서 <span class="math notranslate nohighlight">\(G=\frac{2}{3} \left( 1-\frac{2}{3} \right)+\frac{1}{3} \left( 1-\frac{1}{3} \right)=\frac{4}{9}=0.444\)</span>가 된다.</p>
<p>위 트리 결과에서 각 마디의 세 번째 줄에 <code class="docutils literal notranslate"><span class="pre">value</span></code>가 적혀 있는데, 이것은 해당 마디에 속한 관측들이 범주별로 각각 몇 개씩인지를 의미한다. 가령 뿌리마디의 경우, <code class="docutils literal notranslate"><span class="pre">value[1,2]</span></code>로 나와 있는데, 이는 0의 범주(즉 <code class="docutils literal notranslate"><span class="pre">Low</span></code>)가 1개이고, 1의 범주(즉 <code class="docutils literal notranslate"><span class="pre">High</span></code>)가 2개라는 것이다.</p>
<p>각 마디 상자의 마지막 줄에 <code class="docutils literal notranslate"><span class="pre">class</span></code>가 적혀 있는데, 이것은 해당 마디에 속한 관측들의 범주 중 가장 다수를 차지하는 범주를 의미한다. 따라서 끝마디의 경우, 이는 예상 범주를 의미한다.</p>
</section>
<section id="id13">
<h3>불순도 측정 도구<a class="headerlink" href="#id13" title="Link to this heading">#</a></h3>
<p><strong>지니 지수</strong></p>
<p>앞에서 우리는 분류 트리를 만들 때, 불순도를 평가하는 측정 도구로서 <strong>지니 지수</strong>를 사용했는데, 이를 일반적인 형태로 표현하면 다음과 같다. <span class="math notranslate nohighlight">\(m\)</span>번째 영역의 불순도를 측정한다고 하고, 이 영역에 속한 훈련 관측들의 범주가 총 <span class="math notranslate nohighlight">\(K\)</span>개이며, <span class="math notranslate nohighlight">\(\hat p_{mk}\)</span>는 <span class="math notranslate nohighlight">\(m\)</span>번째 영역에 있어서 <span class="math notranslate nohighlight">\(k\)</span>번째 범주에 속한 훈련 관측의 비율을 나타낸다고 하자. 이 경우, 지니 지수는 다음과 같이 정의된다.</p>
<div class="math notranslate nohighlight">
\[
G = \sum_{k=1}^{K} \hat p_{mk}\left(1-\hat p_{mk} \right) \tag{12.5}
\]</div>
<p>이 식의 특징은 모든 <span class="math notranslate nohighlight">\(\hat p_{mk}\)</span>가 0 또는 1에 가까울 때, 지니 지수 값이 작아지도록 고안됐다는 점이다. 앞의 우리 예처럼 범주가 2개만 있는 상황에서, 만약 <span class="math notranslate nohighlight">\(\hat p_{m1}=\hat p_{m2}=0.5\)</span>이면, 지니 지수는 다음과 같이 0.5가 된다.(범주가 2개일 때, 지니 지수가 도달할 수 있는 최대값이 0.5이다.)</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{aligned}
G &amp; = \hat p_{m1}\left(1-\hat p_{m1}\right) + p_{m2}\left(1-\hat p_{m2}\right)\\
&amp; = 0.5\left(1-0.5\right) + 0.5\left(1-0.5\right)\\
&amp; = 0.5\times0.5 + 0.5\times0.5=0.5
\end{aligned} \end{split}\]</div>
<p>이와 달리, 가령 <span class="math notranslate nohighlight">\(\hat p_{m1}=0.9\)</span>이고 <span class="math notranslate nohighlight">\(\hat p_{m2}=0.1\)</span>이면, 지니 지수는 다음과 같이 0.18로서 0.5보다 훨씬 작아진다.</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{aligned}
G &amp; = \hat p_{m1}\left(1-\hat p_{m1}\right) + p_{m2}\left(1-\hat p_{m2}\right)\\
&amp; = 0.9\left(1-0.9\right) + 0.1\left(1-0.1\right)\\
&amp; = 0.9\times0.1 + 0.1\times0.9=0.18
\end{aligned} \end{split}\]</div>
<p>결국 주어진 영역에서 훈련 관측들이 어느 하나의 범주에 몰려 있을수록(즉 불순도가 낮을수록), 지니 지수가 작아지며, 모든 관측이 어느 하나의 범수에 속할 경우에는 0으로서 최소값에 도달한다.</p>
<p><strong>엔트로피</strong></p>
<p>불순도를 측정하는 또 다른 도구로서 다음과 같은 <strong>엔트로피</strong>(entropy)가 있다.</p>
<div class="math notranslate nohighlight">
\[
D = -\sum_{k=1}^{K} \hat p_{mk} \log_2 \left(\hat p_{mk} \right) \tag{12.6}
\]</div>
<p>여기에서 <span class="math notranslate nohighlight">\(0 ≤ \hat p_{mk} ≤ 1\)</span>이므로 <span class="math notranslate nohighlight">\( -\hat p_{mk} \log \left(\hat p_{mk} \right) \ge 0\)</span>가 된다. 지니 지수와 마찬가지로 엔트로피 역시 <span class="math notranslate nohighlight">\(\hat p_{mk}\)</span>가 모두 0에 가깝거나 1에 가까우면 엔트로피가 0에 가까워진다. 따라서 지니 지수와 마찬가지로 <span class="math notranslate nohighlight">\(m\)</span>번째 영역이 완전히 깨끗할수록(pure) 해당 영역의 엔트로피는 작아지고, 반대로 관측들이 다양한 범주에 속해 불순도가 높아질수록 엔트로피는 커진다. 실제로 지니 지수와 엔트로피는 수치적으로 상당히 유사한 것으로 밝혀졌다. 둘 다 회귀 트리에 있어서의 RSS와 마찬가지로 그 값을 최소화하는 방식으로 이항 분할이 진행된다.</p>
</section>
<section id="id14">
<h3>분류 트리 예제<a class="headerlink" href="#id14" title="Link to this heading">#</a></h3>
<p>출처: <a class="reference external" href="https://www.statlearning.com/">ISLP</a>, pp.339-341.</p>
<p><strong>심장질환 데이터세트</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">Heart</span></code> 데이터세트는 가슴통증을 호소한 303명의 환자에 대해 조사한 것이다. 반응변수 <code class="docutils literal notranslate"><span class="pre">AHD</span></code>는 이항 변수로서 두 개의 범주가 있는데, <code class="docutils literal notranslate"><span class="pre">Yes</span></code>는 혈관 조영 검사 결과 심장질환이 있음을 나타내고, <code class="docutils literal notranslate"><span class="pre">No</span></code>는 심장질환이 없음을 나타낸다. <code class="docutils literal notranslate"><span class="pre">Age</span></code>, <code class="docutils literal notranslate"><span class="pre">Sex</span></code>, <code class="docutils literal notranslate"><span class="pre">Chol</span></code>을 비롯해 기타 심장 및 폐 기능 측정을 포함한 13개의 예측변수가 있다. 몇몇 주요 변수는 다음과 같다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Age</span></code> : 나이(년)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Sex</span></code> : 성별 (1 = 남성; 0 = 여성)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Chol</span></code> : 혈청 콜레스테롤(mg/dl)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ChestPain</span></code> : 가슴 통증 유형 (<code class="docutils literal notranslate"><span class="pre">typical</span></code> = 전형적 협심증; <code class="docutils literal notranslate"><span class="pre">nontypical</span></code> = 비전형적 협심증; <code class="docutils literal notranslate"><span class="pre">nonanginal</span></code> = 비협심증 통증; <code class="docutils literal notranslate"><span class="pre">asymptomatic</span></code> = 무증상)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RestECG</span></code> : 휴식 중 심전도 측정 결과 (0 = 정상; 1 = ST-T파 이상; 2 = Estes 기준에 의해 좌심실 비대가 의심되거나 확실함)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AHD</span></code>: 혈관 조영 검사에 의한 심장질환 여부 (<code class="docutils literal notranslate"><span class="pre">Yes</span></code>, <code class="docutils literal notranslate"><span class="pre">No</span></code>)</p></li>
</ul>
<p><strong>모델 설정 및 결과</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">Heart</span></code> 데이터세트를 사용하여 분류 트리를 피팅했는데, 먼저 전체 관측을 훈련 세트와 테스트 세트로 나누고, 훈련 데이터를 사용해 일차적으로 큰 트리를 만들었다. 그 결과가 아래 그림 12.5의 상단에 나와 있는 트리이다. 그런 다음 가지치기를 통해 끝마디 개수가 다른 부분트리들을 생성하였다. 가지치기를 하지 않은 상단의 트리를 보면, 끝마디가 총 18개인데, 이 트리에 대해 가지치기를 통해 끝마디 개수를 하나씩 줄여나가 최종적으로는 끝마디 개수가 1개인 트리에 이르기까지 가지치기를 진행했다.(끝마디가 1개인 트리는 사실상 분할이 이루어지지 않은 상태를 말함.) 이 과정에서 훈련 세트 및 테스트 세트에 대해 분류 오류, 즉 오분류율을 계속 측정했다. 이 결과가 그림 12.5의 왼쪽 하단 패널에 나와 있는데, 검은색이 훈련 세트에 대한 오류이고, 녹색이 테스트 세트에 대한 오류이다. 테스트 세트 오류가 훈련 세트 오류보다 훨씬 큰 것을 알 수 있다.</p>
<p>한편, 위 작업과 함께 교차검증도 진행했다. 훈련 세트의 일부를 검증 세트로 떼어 놓고 번갈아 가면서 트리를 만들고 그것을 검증 세트에 적용해 오류를 계산한 다음, 그것들을 평균화하는 작업이다. 이 교차검증 역시 가장 큰 트리에서 시작해 가지치기를 통해 끝마디 개수를 하나씩 줄여 가면서 검증 세트에 대한 오류를 계산했다. 그 결과가 아래 그림 12.5의 왼쪽 하단 패널에서 오렌지색으로 표시돼 있다. 교차검증 오류는 테스트 오류의 합리적 근사값이다. 그림을 보면, 교차검증 오류는 끝마디가 6개인 트리에서 가장 작아지기 때문에 상단의 큰 트리에 대해 6개의 끝마디를 갖도록 가지치기를 했으며, 그렇게 해서 나온 트리가 오른쪽 하단 그림이다.</p>
<p><strong>그림 12.5.</strong> <code class="docutils literal notranslate"><span class="pre">Heart</span></code> 데이터세트에 대한 분류 트리. 상단: 가지치기 하지 않은 트리. 왼쪽 하단: 트리의 다양한 크기별 교차검증 오류, 훈련 오류, 테스트 오류. 오른쪽 하단: 교차검증 오류를 최소화하는 끝마디 개수를 가진 가지치기된 트리.</p>
<p><img alt="Hitters 분류 트리 1" src="https://raw.githubusercontent.com/pilsunchoi/images/main/12-13.png" />
<img alt="Hitters 분류 트리 2" src="https://raw.githubusercontent.com/pilsunchoi/images/main/12-14.png" /></p>
<ul class="simple">
<li><p>그림 출처: ISLP, FIGURE 8.6</p></li>
</ul>
<p><strong>정성적 예측변수</strong></p>
<p>지금까지 논의에서는 예측변수가 정량적인 경우만 다뤘다. 그러나 정성적 예측변수도 결정 트리를 만드는 데 아무런 문제가 없다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">Heart</span></code> 데이터에서 <code class="docutils literal notranslate"><span class="pre">Sex</span></code>, <code class="docutils literal notranslate"><span class="pre">Thal</span></code>, <code class="docutils literal notranslate"><span class="pre">ChestPain</span></code>과 같은 예측변수는 범주형 변수들이다. 이러한 범주형 변수에 대해 분할을 할 경우에는 범주 중 일부를 하나의 가지에 할당하고 나머지를 다른 가지에 할당하는 식으로 하면 된다.</p>
<p>앞의 그림 12.5에서 일부 내부마디는 정성적 변수를 분할하고 있는데, 가령 상단 그림의 뿌리마디는 <code class="docutils literal notranslate"><span class="pre">Thal</span></code> 변수에 대한 분할이다. 먼저 표기법을 설명하면, <code class="docutils literal notranslate"><span class="pre">Thal:a</span></code>로 돼있는 것은 해당 마디에서 나오는 왼쪽 가지가 <code class="docutils literal notranslate"><span class="pre">Thal</span></code> 변수의 첫 번째 범주(<code class="docutils literal notranslate"><span class="pre">normal</span></code>)에 해당하고, 오른쪽 가지는 나머지 범주(<code class="docutils literal notranslate"><span class="pre">fixed</span></code> 및 <code class="docutils literal notranslate"><span class="pre">reversible</span></code>)에 해당하는 것을 의미한다. 또한 같은 그림에서 뿌리마디의 왼쪽 가지 중 두번째 분할에 <code class="docutils literal notranslate"><span class="pre">ChestPain:bc</span></code> 표시가 있는데, 이는 <code class="docutils literal notranslate"><span class="pre">ChestPain</span></code> 변수의 가능한 값이 <code class="docutils literal notranslate"><span class="pre">typical</span></code>, <code class="docutils literal notranslate"><span class="pre">nontypical</span></code>, <code class="docutils literal notranslate"><span class="pre">non-anginal</span></code>, <code class="docutils literal notranslate"><span class="pre">asymptomatic</span></code> 등 네 개인데, 해당 마디에서 나오는 왼쪽 가지가 네 개 범주 중 두 번째 및 세 번째 값을 갖는 관측으로 구성돼 있음을 나타낸다. 이런 식으로 범주형 예측변수에 대해서도 동일한 방식으로 이항 분할을 하면 된다.</p>
<p><strong>분할 양쪽 끝마디의 예측 범주가 동일한 경우</strong></p>
<p>위 그림 12.5에는 한 가지 흥미로운 부분이 있는데, 일부 분할의 경우에는 양쪽 끝마디의 예측 범주가 동일하다는 점이다. 예를 들어, 그림 12.5의 가지치기되지 않은 상단 트리 그림에서 오른쪽 아래 부분의 분할 <code class="docutils literal notranslate"><span class="pre">RestECG&lt;1</span></code>을 봐보자.(<code class="docutils literal notranslate"><span class="pre">RestECG</span></code>는 휴식 중 심전도 측정 결과로서 0, 1, 2로 표시된 세 개의 범주가 있다.) 이 경우 왼쪽 가지와 오른쪽 가지 모두 다 예측 범주가 <code class="docutils literal notranslate"><span class="pre">Yes</span></code>이다.</p>
<p>범주가 똑같은데도 이렇게 분할이 이루어진 이유는 무엇일까? 그 이유는 이렇게 분할을 함으로써 마디의 불순도가 감소하기 때문이다. 즉, 이 분할에서 오른쪽 끝마디(즉 <code class="docutils literal notranslate"><span class="pre">RestECG</span></code><span class="math notranslate nohighlight">\(\ge1\)</span>)에는 9개의 관측이 여기에 속하는데, 이들의 반응 범주가 모두 <code class="docutils literal notranslate"><span class="pre">Yes</span></code>이다. 이에 반해 왼쪽 끝마디(즉 <code class="docutils literal notranslate"><span class="pre">RestECG</span></code><span class="math notranslate nohighlight">\(&lt;1\)</span>)에는 총 11개의 관측 중 7개만이 범주가 <code class="docutils literal notranslate"><span class="pre">Yes</span></code>이다. 이처럼 두 끝마디의 불순도가 다른 것이다. 이들 두 끝마디를 합쳐 놓는 것(즉 분할을 하지 않는 것)에 비해 <code class="docutils literal notranslate"><span class="pre">RestECG</span></code>=1을 경계로 분할을 함으로써 불순도를 낮출 수 있다. 달리 표현하면 이렇게 분할을 함으로써 추론에 이득이 생긴다고 할 수 있다. 가령 어떤 테스트 관측이 오른쪽 끝마디에 속하면, 반응 범주가 <code class="docutils literal notranslate"><span class="pre">Yes</span></code>라는 것을 <strong>강하게</strong> 확신할 수 있다. 이에 반해, 테스트 관측이 왼쪽 끝마디에 속하면, 이 경우에도 <code class="docutils literal notranslate"><span class="pre">Yes</span></code> 범주로 예측되지만, 그 확신의 정도가 오른쪽 끝마디에 비해 훨씬 낮아진다. 이런 추론 상의 <strong>정보 이득</strong>(information gain) 때문에 양쪽 끝마디의 예측 범주가 동일한 경우에도 분할이 일어날 수 있다.</p>
</section>
<section id="id15">
<h3>트리의 장점과 단점<a class="headerlink" href="#id15" title="Link to this heading">#</a></h3>
<p>이상 회귀 및 분류를 위한 결정 트리에 대해 기본적인 내용을 살펴 보았다. 결정 트리는 선형 회귀나 로지스틱 회귀 등 전통적 접근에 비해 장단점을 지니고 있다. <strong>장점</strong>으로는 이해와 설명이 쉽고, 해석이 용이하다는 점을 들 수 있다. 또한 트리를 그래픽으로 표시할 수 있어 비전문가도 쉽게 이해할 수 있다. 이와 함께 결정 트리가 전통적 접근에 비해 인간의 의사 결정을 더 잘 반영한다는 주장도 있다. 그밖에 트리는 더미변수를 만들 필요 없이 정성적 예측 변수를 쉽게 처리할 수 있다.</p>
<p>이러한 장점에 비해 <strong>단점</strong>도 있는데, 무엇보다 예측 및 분류의 정확도 면에서 전통적 접근에 비해 일반적으로 열위에 있다. 또한 트리는 분석 결과의 강건성(robustness)이 아주 떨어질 수 있다. 즉, 데이터가 약간만 변해도 트리 결과가 크게 달라질 수 있다.</p>
<p>결정 트리의 이런 단점을 보완하기 위해 여러 기법들이 등장했는데, 대표적으로 배깅, 랜덤 포레스트, 부스팅 등이 있다. 소위 앙상블(ensemble) 기법으로 불리는데, 기본 아이디어는 많은 결정 트리를 결합하여 트리의 예측력을 높이는 것이다. 다음 장에서 이들 기법에 대해 다룬다.</p>
</section>
</section>
<section id="id16">
<h2>12.4 결정 트리 예제<a class="headerlink" href="#id16" title="Link to this heading">#</a></h2>
<p>코드 출처: <a class="reference external" href="https://nbviewer.org/github/JWarmenhoven/ISLR-python/blob/master/Notebooks/Chapter%208.ipynb">Tree-based Methods by J. Warmenhoven</a></p>
<p><strong>기본 라이브러리 및 함수 불러오기</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">tree</span>
<span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeRegressor</span><span class="p">,</span> <span class="n">DecisionTreeClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span><span class="p">,</span> <span class="n">confusion_matrix</span><span class="p">,</span> <span class="n">classification_report</span>
</pre></div>
</div>
</div>
</div>
<section id="hitters">
<h3>회귀 트리: Hitters 데이터세트<a class="headerlink" href="#hitters" title="Link to this heading">#</a></h3>
<p>앞에서도 다뤘던 <code class="docutils literal notranslate"><span class="pre">Hitters</span></code> 데이터세트는 1986년과 1987년 시즌 미국 메이저리그에서 뛰었던 322명 선수들에 대해 20개 항목을 기록한 데이터이다.</p>
<p><strong>데이터 로딩</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Hitters</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;../Data/Hitters.csv&#39;</span><span class="p">)</span>
<span class="n">Hitters</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
RangeIndex: 322 entries, 0 to 321
Data columns (total 20 columns):
 #   Column     Non-Null Count  Dtype  
---  ------     --------------  -----  
 0   AtBat      322 non-null    int64  
 1   Hits       322 non-null    int64  
 2   HmRun      322 non-null    int64  
 3   Runs       322 non-null    int64  
 4   RBI        322 non-null    int64  
 5   Walks      322 non-null    int64  
 6   Years      322 non-null    int64  
 7   CAtBat     322 non-null    int64  
 8   CHits      322 non-null    int64  
 9   CHmRun     322 non-null    int64  
 10  CRuns      322 non-null    int64  
 11  CRBI       322 non-null    int64  
 12  CWalks     322 non-null    int64  
 13  League     322 non-null    object 
 14  Division   322 non-null    object 
 15  PutOuts    322 non-null    int64  
 16  Assists    322 non-null    int64  
 17  Errors     322 non-null    int64  
 18  Salary     263 non-null    float64
 19  NewLeague  322 non-null    object 
dtypes: float64(1), int64(16), object(3)
memory usage: 50.4+ KB
</pre></div>
</div>
</div>
</div>
<p><strong>변수 설명</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">AtBat</span></code> : 1986년 타수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Hits</span></code> : 1986년 안타수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HmRun</span></code> : 1986년 홈런 수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Runs</span></code> : 1986년 득점</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RBI</span></code> : 1986년 타점</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Walks</span></code> : 1986년 볼넷 수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Years</span></code> : 메이저 리그 연차</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CAtBat</span></code> : 경력 중 타수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CHits</span></code> : 경력 중 안타수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CHmRun</span></code> : 경력 중 홈런 수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CRuns</span></code> : 경력 중 득점 수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CRBI</span></code> : 경력 중 타점 수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CWalks</span></code> : 경력 중 볼넷 수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">League</span></code> : 1986년말 소속 리그(A-아메리칸, N-내셔널)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Division</span></code> : 1986년말 소속 디비전(E-동부, W-서부)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PutOuts</span></code> : 1986년 풋아웃(아웃 실행) 수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Assists</span></code> : 1986년 어시스트(아웃 도움) 수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Errors</span></code> : 1986년 에러 수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Salary</span></code> : 1987년 리그 개막 당시 연봉(천 달러)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NewLeague</span></code> : 1987년초 소속 리그(A-아메리칸, N-내셔널)</p></li>
</ul>
<p><strong>결측값 지닌 관측 제거</strong></p>
<p>위 <code class="docutils literal notranslate"><span class="pre">info()</span></code> 메서드 결과를 보면, <code class="docutils literal notranslate"><span class="pre">Salary</span></code> 변수의 경우, 상당수 관측에 결측값이 있다. 따라서 <code class="docutils literal notranslate"><span class="pre">dropna()</span></code> 메서드를 사용해 결측값을 지닌 관측들을 제거한다. 이렇게 하면, 관측 개수가 263개로 줄어든다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">Hitters</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(263, 20)
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AtBat</th>
      <th>Hits</th>
      <th>HmRun</th>
      <th>Runs</th>
      <th>RBI</th>
      <th>Walks</th>
      <th>Years</th>
      <th>CAtBat</th>
      <th>CHits</th>
      <th>CHmRun</th>
      <th>CRuns</th>
      <th>CRBI</th>
      <th>CWalks</th>
      <th>League</th>
      <th>Division</th>
      <th>PutOuts</th>
      <th>Assists</th>
      <th>Errors</th>
      <th>Salary</th>
      <th>NewLeague</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>315</td>
      <td>81</td>
      <td>7</td>
      <td>24</td>
      <td>38</td>
      <td>39</td>
      <td>14</td>
      <td>3449</td>
      <td>835</td>
      <td>69</td>
      <td>321</td>
      <td>414</td>
      <td>375</td>
      <td>N</td>
      <td>W</td>
      <td>632</td>
      <td>43</td>
      <td>10</td>
      <td>475.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>2</th>
      <td>479</td>
      <td>130</td>
      <td>18</td>
      <td>66</td>
      <td>72</td>
      <td>76</td>
      <td>3</td>
      <td>1624</td>
      <td>457</td>
      <td>63</td>
      <td>224</td>
      <td>266</td>
      <td>263</td>
      <td>A</td>
      <td>W</td>
      <td>880</td>
      <td>82</td>
      <td>14</td>
      <td>480.0</td>
      <td>A</td>
    </tr>
    <tr>
      <th>3</th>
      <td>496</td>
      <td>141</td>
      <td>20</td>
      <td>65</td>
      <td>78</td>
      <td>37</td>
      <td>11</td>
      <td>5628</td>
      <td>1575</td>
      <td>225</td>
      <td>828</td>
      <td>838</td>
      <td>354</td>
      <td>N</td>
      <td>E</td>
      <td>200</td>
      <td>11</td>
      <td>3</td>
      <td>500.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>4</th>
      <td>321</td>
      <td>87</td>
      <td>10</td>
      <td>39</td>
      <td>42</td>
      <td>30</td>
      <td>2</td>
      <td>396</td>
      <td>101</td>
      <td>12</td>
      <td>48</td>
      <td>46</td>
      <td>33</td>
      <td>N</td>
      <td>E</td>
      <td>805</td>
      <td>40</td>
      <td>4</td>
      <td>91.5</td>
      <td>N</td>
    </tr>
    <tr>
      <th>5</th>
      <td>594</td>
      <td>169</td>
      <td>4</td>
      <td>74</td>
      <td>51</td>
      <td>35</td>
      <td>11</td>
      <td>4408</td>
      <td>1133</td>
      <td>19</td>
      <td>501</td>
      <td>336</td>
      <td>194</td>
      <td>A</td>
      <td>W</td>
      <td>282</td>
      <td>421</td>
      <td>25</td>
      <td>750.0</td>
      <td>A</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p><strong>예측변수 및 반응변수</strong></p>
<p>총 19개 예측변수 중 <code class="docutils literal notranslate"><span class="pre">Years</span></code>와 <code class="docutils literal notranslate"><span class="pre">Hits</span></code> 2개를 편의상 <code class="docutils literal notranslate"><span class="pre">X</span></code>라는 이름으로 지정한다. <code class="docutils literal notranslate"><span class="pre">Salary</span></code>를 반응변수 <code class="docutils literal notranslate"><span class="pre">y</span></code>로 지정하되, 여기에 자연로그를 취하기로 한다. 로그를 취하기 전과 후의 연봉 분포를 히스토그램으로 그려봤다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;Years&#39;</span><span class="p">,</span> <span class="s1">&#39;Hits&#39;</span><span class="p">]]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">Salary</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">Salary</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Salary&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Log(Salary)&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p><strong>회귀 트리 피팅 실행</strong></p>
<p>사이킷런의 <code class="docutils literal notranslate"><span class="pre">DecisionTreeRegressor()</span></code> 함수를 사용해 회귀 트리 모형을 설정한다. 끝마디 최대 개수를 3개로 지정해보자(<code class="docutils literal notranslate"><span class="pre">max_leaf_nodes=3</span></code>). 이렇게 설정한 모형을 <code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드를 사용해 데이터(<code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>)에 피팅시킨다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">regr</span> <span class="o">=</span> <span class="n">DecisionTreeRegressor</span><span class="p">(</span><span class="n">max_leaf_nodes</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">regr</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><style>#sk-container-id-3 {
  /* Definition of color scheme common for light and dark mode */
  --sklearn-color-text: black;
  --sklearn-color-line: gray;
  /* Definition of color scheme for unfitted estimators */
  --sklearn-color-unfitted-level-0: #fff5e6;
  --sklearn-color-unfitted-level-1: #f6e4d2;
  --sklearn-color-unfitted-level-2: #ffe0b3;
  --sklearn-color-unfitted-level-3: chocolate;
  /* Definition of color scheme for fitted estimators */
  --sklearn-color-fitted-level-0: #f0f8ff;
  --sklearn-color-fitted-level-1: #d4ebff;
  --sklearn-color-fitted-level-2: #b3dbfd;
  --sklearn-color-fitted-level-3: cornflowerblue;

  /* Specific color for light theme */
  --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
  --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, white)));
  --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
  --sklearn-color-icon: #696969;

  @media (prefers-color-scheme: dark) {
    /* Redefinition of color scheme for dark theme */
    --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
    --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, #111)));
    --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
    --sklearn-color-icon: #878787;
  }
}

#sk-container-id-3 {
  color: var(--sklearn-color-text);
}

#sk-container-id-3 pre {
  padding: 0;
}

#sk-container-id-3 input.sk-hidden--visually {
  border: 0;
  clip: rect(1px 1px 1px 1px);
  clip: rect(1px, 1px, 1px, 1px);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}

#sk-container-id-3 div.sk-dashed-wrapped {
  border: 1px dashed var(--sklearn-color-line);
  margin: 0 0.4em 0.5em 0.4em;
  box-sizing: border-box;
  padding-bottom: 0.4em;
  background-color: var(--sklearn-color-background);
}

#sk-container-id-3 div.sk-container {
  /* jupyter's `normalize.less` sets `[hidden] { display: none; }`
     but bootstrap.min.css set `[hidden] { display: none !important; }`
     so we also need the `!important` here to be able to override the
     default hidden behavior on the sphinx rendered scikit-learn.org.
     See: https://github.com/scikit-learn/scikit-learn/issues/21755 */
  display: inline-block !important;
  position: relative;
}

#sk-container-id-3 div.sk-text-repr-fallback {
  display: none;
}

div.sk-parallel-item,
div.sk-serial,
div.sk-item {
  /* draw centered vertical line to link estimators */
  background-image: linear-gradient(var(--sklearn-color-text-on-default-background), var(--sklearn-color-text-on-default-background));
  background-size: 2px 100%;
  background-repeat: no-repeat;
  background-position: center center;
}

/* Parallel-specific style estimator block */

#sk-container-id-3 div.sk-parallel-item::after {
  content: "";
  width: 100%;
  border-bottom: 2px solid var(--sklearn-color-text-on-default-background);
  flex-grow: 1;
}

#sk-container-id-3 div.sk-parallel {
  display: flex;
  align-items: stretch;
  justify-content: center;
  background-color: var(--sklearn-color-background);
  position: relative;
}

#sk-container-id-3 div.sk-parallel-item {
  display: flex;
  flex-direction: column;
}

#sk-container-id-3 div.sk-parallel-item:first-child::after {
  align-self: flex-end;
  width: 50%;
}

#sk-container-id-3 div.sk-parallel-item:last-child::after {
  align-self: flex-start;
  width: 50%;
}

#sk-container-id-3 div.sk-parallel-item:only-child::after {
  width: 0;
}

/* Serial-specific style estimator block */

#sk-container-id-3 div.sk-serial {
  display: flex;
  flex-direction: column;
  align-items: center;
  background-color: var(--sklearn-color-background);
  padding-right: 1em;
  padding-left: 1em;
}


/* Toggleable style: style used for estimator/Pipeline/ColumnTransformer box that is
clickable and can be expanded/collapsed.
- Pipeline and ColumnTransformer use this feature and define the default style
- Estimators will overwrite some part of the style using the `sk-estimator` class
*/

/* Pipeline and ColumnTransformer style (default) */

#sk-container-id-3 div.sk-toggleable {
  /* Default theme specific background. It is overwritten whether we have a
  specific estimator or a Pipeline/ColumnTransformer */
  background-color: var(--sklearn-color-background);
}

/* Toggleable label */
#sk-container-id-3 label.sk-toggleable__label {
  cursor: pointer;
  display: block;
  width: 100%;
  margin-bottom: 0;
  padding: 0.5em;
  box-sizing: border-box;
  text-align: center;
}

#sk-container-id-3 label.sk-toggleable__label-arrow:before {
  /* Arrow on the left of the label */
  content: "▸";
  float: left;
  margin-right: 0.25em;
  color: var(--sklearn-color-icon);
}

#sk-container-id-3 label.sk-toggleable__label-arrow:hover:before {
  color: var(--sklearn-color-text);
}

/* Toggleable content - dropdown */

#sk-container-id-3 div.sk-toggleable__content {
  max-height: 0;
  max-width: 0;
  overflow: hidden;
  text-align: left;
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-3 div.sk-toggleable__content.fitted {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

#sk-container-id-3 div.sk-toggleable__content pre {
  margin: 0.2em;
  border-radius: 0.25em;
  color: var(--sklearn-color-text);
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-3 div.sk-toggleable__content.fitted pre {
  /* unfitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

#sk-container-id-3 input.sk-toggleable__control:checked~div.sk-toggleable__content {
  /* Expand drop-down */
  max-height: 200px;
  max-width: 100%;
  overflow: auto;
}

#sk-container-id-3 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {
  content: "▾";
}

/* Pipeline/ColumnTransformer-specific style */

#sk-container-id-3 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-3 div.sk-label.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Estimator-specific style */

/* Colorize estimator box */
#sk-container-id-3 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-3 div.sk-estimator.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-2);
}

#sk-container-id-3 div.sk-label label.sk-toggleable__label,
#sk-container-id-3 div.sk-label label {
  /* The background is the default theme color */
  color: var(--sklearn-color-text-on-default-background);
}

/* On hover, darken the color of the background */
#sk-container-id-3 div.sk-label:hover label.sk-toggleable__label {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-unfitted-level-2);
}

/* Label box, darken color on hover, fitted */
#sk-container-id-3 div.sk-label.fitted:hover label.sk-toggleable__label.fitted {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Estimator label */

#sk-container-id-3 div.sk-label label {
  font-family: monospace;
  font-weight: bold;
  display: inline-block;
  line-height: 1.2em;
}

#sk-container-id-3 div.sk-label-container {
  text-align: center;
}

/* Estimator-specific */
#sk-container-id-3 div.sk-estimator {
  font-family: monospace;
  border: 1px dotted var(--sklearn-color-border-box);
  border-radius: 0.25em;
  box-sizing: border-box;
  margin-bottom: 0.5em;
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-3 div.sk-estimator.fitted {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

/* on hover */
#sk-container-id-3 div.sk-estimator:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-3 div.sk-estimator.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Specification for estimator info (e.g. "i" and "?") */

/* Common style for "i" and "?" */

.sk-estimator-doc-link,
a:link.sk-estimator-doc-link,
a:visited.sk-estimator-doc-link {
  float: right;
  font-size: smaller;
  line-height: 1em;
  font-family: monospace;
  background-color: var(--sklearn-color-background);
  border-radius: 1em;
  height: 1em;
  width: 1em;
  text-decoration: none !important;
  margin-left: 1ex;
  /* unfitted */
  border: var(--sklearn-color-unfitted-level-1) 1pt solid;
  color: var(--sklearn-color-unfitted-level-1);
}

.sk-estimator-doc-link.fitted,
a:link.sk-estimator-doc-link.fitted,
a:visited.sk-estimator-doc-link.fitted {
  /* fitted */
  border: var(--sklearn-color-fitted-level-1) 1pt solid;
  color: var(--sklearn-color-fitted-level-1);
}

/* On hover */
div.sk-estimator:hover .sk-estimator-doc-link:hover,
.sk-estimator-doc-link:hover,
div.sk-label-container:hover .sk-estimator-doc-link:hover,
.sk-estimator-doc-link:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

div.sk-estimator.fitted:hover .sk-estimator-doc-link.fitted:hover,
.sk-estimator-doc-link.fitted:hover,
div.sk-label-container:hover .sk-estimator-doc-link.fitted:hover,
.sk-estimator-doc-link.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

/* Span, style for the box shown on hovering the info icon */
.sk-estimator-doc-link span {
  display: none;
  z-index: 9999;
  position: relative;
  font-weight: normal;
  right: .2ex;
  padding: .5ex;
  margin: .5ex;
  width: min-content;
  min-width: 20ex;
  max-width: 50ex;
  color: var(--sklearn-color-text);
  box-shadow: 2pt 2pt 4pt #999;
  /* unfitted */
  background: var(--sklearn-color-unfitted-level-0);
  border: .5pt solid var(--sklearn-color-unfitted-level-3);
}

.sk-estimator-doc-link.fitted span {
  /* fitted */
  background: var(--sklearn-color-fitted-level-0);
  border: var(--sklearn-color-fitted-level-3);
}

.sk-estimator-doc-link:hover span {
  display: block;
}

/* "?"-specific style due to the `<a>` HTML tag */

#sk-container-id-3 a.estimator_doc_link {
  float: right;
  font-size: 1rem;
  line-height: 1em;
  font-family: monospace;
  background-color: var(--sklearn-color-background);
  border-radius: 1rem;
  height: 1rem;
  width: 1rem;
  text-decoration: none;
  /* unfitted */
  color: var(--sklearn-color-unfitted-level-1);
  border: var(--sklearn-color-unfitted-level-1) 1pt solid;
}

#sk-container-id-3 a.estimator_doc_link.fitted {
  /* fitted */
  border: var(--sklearn-color-fitted-level-1) 1pt solid;
  color: var(--sklearn-color-fitted-level-1);
}

/* On hover */
#sk-container-id-3 a.estimator_doc_link:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

#sk-container-id-3 a.estimator_doc_link.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-3);
}
</style><div id="sk-container-id-3" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>DecisionTreeRegressor(max_leaf_nodes=3)</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item"><div class="sk-estimator fitted sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-3" type="checkbox" checked><label for="sk-estimator-id-3" class="sk-toggleable__label fitted sk-toggleable__label-arrow fitted">&nbsp;&nbsp;DecisionTreeRegressor<a class="sk-estimator-doc-link fitted" rel="noreferrer" target="_blank" href="https://scikit-learn.org/1.5/modules/generated/sklearn.tree.DecisionTreeRegressor.html">?<span>Documentation for DecisionTreeRegressor</span></a><span class="sk-estimator-doc-link fitted">i<span>Fitted</span></span></label><div class="sk-toggleable__content fitted"><pre>DecisionTreeRegressor(max_leaf_nodes=3)</pre></div> </div></div></div></div></div></div>
</div>
<p><strong>트리 결과</strong></p>
<p>사이킷런 <code class="docutils literal notranslate"><span class="pre">tree</span></code> 모듈의 <code class="docutils literal notranslate"><span class="pre">plot_tree()</span></code> 함수를 사용해 트리 결과를 그림으로 그린 것이 아래 나와 있다. 이 결과는 이 장의 맨 앞 그림 12.1에 나와 있는 트리와 사실상 동일하다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">plot_tree</span><span class="p">(</span><span class="n">regr</span><span class="p">,</span>
                   <span class="n">feature_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Years&#39;</span><span class="p">,</span> <span class="s1">&#39;Hits&#39;</span><span class="p">],</span>
                   <span class="n">filled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">fontsize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="heart">
<h3>분류 트리: Heart 데이터세트<a class="headerlink" href="#heart" title="Link to this heading">#</a></h3>
<p>앞에서도 다뤘던 <code class="docutils literal notranslate"><span class="pre">Heart</span></code> 데이터세트는 가슴통증을 호소한 303명의 환자에 대해 심장질환 여부 등 14개 항목을 조사한 데이터다.</p>
<p><strong>데이터 로딩</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Heart</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;../Data/Heart.csv&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;Unnamed: 0&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Heart</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
RangeIndex: 303 entries, 0 to 302
Data columns (total 14 columns):
 #   Column     Non-Null Count  Dtype  
---  ------     --------------  -----  
 0   Age        303 non-null    int64  
 1   Sex        303 non-null    int64  
 2   ChestPain  303 non-null    object 
 3   RestBP     303 non-null    int64  
 4   Chol       303 non-null    int64  
 5   Fbs        303 non-null    int64  
 6   RestECG    303 non-null    int64  
 7   MaxHR      303 non-null    int64  
 8   ExAng      303 non-null    int64  
 9   Oldpeak    303 non-null    float64
 10  Slope      303 non-null    int64  
 11  Ca         299 non-null    float64
 12  Thal       301 non-null    object 
 13  AHD        303 non-null    object 
dtypes: float64(2), int64(9), object(3)
memory usage: 33.3+ KB
</pre></div>
</div>
</div>
</div>
<p><strong>변수 설명</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Age</span></code> : 나이(년)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Sex</span></code> : 성별 (1 = 남성; 0 = 여성)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ChestPain</span></code> : 가슴 통증 유형 (<code class="docutils literal notranslate"><span class="pre">typical</span></code> = 전형적 협심증; <code class="docutils literal notranslate"><span class="pre">nontypical</span></code> = 비전형적 협심증; <code class="docutils literal notranslate"><span class="pre">nonanginal</span></code> = 비협심증 통증; <code class="docutils literal notranslate"><span class="pre">asymptomatic</span></code> = 무증상)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RestBP</span></code> : 안정시 혈압(입원시 측정, 단위: mm Hg)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Chol</span></code> : 혈청 콜레스테롤(mg/dl)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Fbs</span></code> : 공복 혈당 &gt; 120mg/dl (1 = 참; 0 = 거짓)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RestECG</span></code> : 휴식 중 심전도 결과 (0 = 정상; 1 = ST-T파 이상; 2 = Estes 기준에 의해 좌심실 비대가 의심되거나 확실함)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MaxHR</span></code> : 최대 심박수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ExAng</span></code> : 운동 유발 협심증 (1 = 예; 0 = 아니오)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Oldpeak</span></code> : 운동으로 유발된 ST 분절 하강</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Slope</span></code> : 최대 운동 ST 분절의 기울기 (1 = 오르막; 2 = 평평; 3 =  내리막)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Ca</span></code> : 투시영상으로 채색된 주요 혈관의 수 (0-3)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Thal</span></code>: 탈륨(Thallium) 스트레스 테스트(<code class="docutils literal notranslate"><span class="pre">normal</span></code> = 정상;  <code class="docutils literal notranslate"><span class="pre">fixed</span></code> = 고착 결함, <code class="docutils literal notranslate"><span class="pre">reversable</span></code> = 가역적 결함)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AHD</span></code>: 혈관 조영 검사에 의한 심장질환 여부 (<code class="docutils literal notranslate"><span class="pre">Yes</span></code>/<code class="docutils literal notranslate"><span class="pre">No</span></code>)</p></li>
</ul>
<p><strong>결측값 지닌 관측 제거</strong></p>
<p>위 <code class="docutils literal notranslate"><span class="pre">info()</span></code> 메서드 결과를 보면, 일부 변수(<code class="docutils literal notranslate"><span class="pre">Ca</span></code> 및 <code class="docutils literal notranslate"><span class="pre">Thal</span></code>)가 결측값을 지니고 있다. 따라서 <code class="docutils literal notranslate"><span class="pre">dropna()</span></code> 메서드를 사용해 결측값을 지닌 관측들을 제거한다. 이렇게 하면 관측 개수가 297개로 줄어든다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">df2</span> <span class="o">=</span> <span class="n">Heart</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">df2</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(297, 14)
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Age</th>
      <th>Sex</th>
      <th>ChestPain</th>
      <th>RestBP</th>
      <th>Chol</th>
      <th>Fbs</th>
      <th>RestECG</th>
      <th>MaxHR</th>
      <th>ExAng</th>
      <th>Oldpeak</th>
      <th>Slope</th>
      <th>Ca</th>
      <th>Thal</th>
      <th>AHD</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>63</td>
      <td>1</td>
      <td>typical</td>
      <td>145</td>
      <td>233</td>
      <td>1</td>
      <td>2</td>
      <td>150</td>
      <td>0</td>
      <td>2.3</td>
      <td>3</td>
      <td>0.0</td>
      <td>fixed</td>
      <td>No</td>
    </tr>
    <tr>
      <th>1</th>
      <td>67</td>
      <td>1</td>
      <td>asymptomatic</td>
      <td>160</td>
      <td>286</td>
      <td>0</td>
      <td>2</td>
      <td>108</td>
      <td>1</td>
      <td>1.5</td>
      <td>2</td>
      <td>3.0</td>
      <td>normal</td>
      <td>Yes</td>
    </tr>
    <tr>
      <th>2</th>
      <td>67</td>
      <td>1</td>
      <td>asymptomatic</td>
      <td>120</td>
      <td>229</td>
      <td>0</td>
      <td>2</td>
      <td>129</td>
      <td>1</td>
      <td>2.6</td>
      <td>2</td>
      <td>2.0</td>
      <td>reversable</td>
      <td>Yes</td>
    </tr>
    <tr>
      <th>3</th>
      <td>37</td>
      <td>1</td>
      <td>nonanginal</td>
      <td>130</td>
      <td>250</td>
      <td>0</td>
      <td>0</td>
      <td>187</td>
      <td>0</td>
      <td>3.5</td>
      <td>3</td>
      <td>0.0</td>
      <td>normal</td>
      <td>No</td>
    </tr>
    <tr>
      <th>4</th>
      <td>41</td>
      <td>0</td>
      <td>nontypical</td>
      <td>130</td>
      <td>204</td>
      <td>0</td>
      <td>2</td>
      <td>172</td>
      <td>0</td>
      <td>1.4</td>
      <td>1</td>
      <td>0.0</td>
      <td>normal</td>
      <td>No</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p><strong>문자형 범주를 숫자형 범주로 전환</strong></p>
<p>정성적 변수 중 일부가 문자형 범주로 돼있는데, 이를 숫자형 범주로 바꿔야 한다. 예측변수 중에서는 <code class="docutils literal notranslate"><span class="pre">ChestPain</span></code>과 <code class="docutils literal notranslate"><span class="pre">Thal</span></code>이 여기에 속하고, 반응변수인 <code class="docutils literal notranslate"><span class="pre">AHD</span></code>도 여기에 속한다. <code class="docutils literal notranslate"><span class="pre">pandas</span></code>에서 제공하는 <code class="docutils literal notranslate"><span class="pre">factorize()</span></code> 함수를 사용하면 숫자형 범주로 전환하는 작업을 손쉽게 수행할 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pd</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">chained_assignment</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># default=&#39;warn&#39;: 워닝 사인 안나오게 하기</span>

<span class="n">df2</span><span class="p">[</span><span class="s1">&#39;ChestPain&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">df2</span><span class="o">.</span><span class="n">ChestPain</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">df2</span><span class="p">[</span><span class="s1">&#39;Thal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">df2</span><span class="o">.</span><span class="n">Thal</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">df2</span><span class="p">[</span><span class="s1">&#39;AHD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">df2</span><span class="o">.</span><span class="n">AHD</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">df2</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Age</th>
      <th>Sex</th>
      <th>ChestPain</th>
      <th>RestBP</th>
      <th>Chol</th>
      <th>Fbs</th>
      <th>RestECG</th>
      <th>MaxHR</th>
      <th>ExAng</th>
      <th>Oldpeak</th>
      <th>Slope</th>
      <th>Ca</th>
      <th>Thal</th>
      <th>AHD</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>63</td>
      <td>1</td>
      <td>0</td>
      <td>145</td>
      <td>233</td>
      <td>1</td>
      <td>2</td>
      <td>150</td>
      <td>0</td>
      <td>2.3</td>
      <td>3</td>
      <td>0.0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>67</td>
      <td>1</td>
      <td>1</td>
      <td>160</td>
      <td>286</td>
      <td>0</td>
      <td>2</td>
      <td>108</td>
      <td>1</td>
      <td>1.5</td>
      <td>2</td>
      <td>3.0</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>67</td>
      <td>1</td>
      <td>1</td>
      <td>120</td>
      <td>229</td>
      <td>0</td>
      <td>2</td>
      <td>129</td>
      <td>1</td>
      <td>2.6</td>
      <td>2</td>
      <td>2.0</td>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>37</td>
      <td>1</td>
      <td>2</td>
      <td>130</td>
      <td>250</td>
      <td>0</td>
      <td>0</td>
      <td>187</td>
      <td>0</td>
      <td>3.5</td>
      <td>3</td>
      <td>0.0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>41</td>
      <td>0</td>
      <td>3</td>
      <td>130</td>
      <td>204</td>
      <td>0</td>
      <td>2</td>
      <td>172</td>
      <td>0</td>
      <td>1.4</td>
      <td>1</td>
      <td>0.0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p><strong>예측변수 및 반응변수</strong></p>
<p>데이터세트에서 심장질환 여부를 의미하는 <code class="docutils literal notranslate"><span class="pre">AHD</span></code>를 반응변수 <code class="docutils literal notranslate"><span class="pre">y</span></code>로 지정하고, 나머지 총 13개 변수를 예측변수 <code class="docutils literal notranslate"><span class="pre">X</span></code>로 지정한다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X2</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;AHD&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">df2</span><span class="p">[</span><span class="s1">&#39;AHD&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p><strong>모델 및 피팅</strong></p>
<p>사이킷런의 <code class="docutils literal notranslate"><span class="pre">DecisionTreeClassifier()</span></code> 함수를 사용해 분류 트리 모형을 설정한다. 우선 끝마디 최대 개수(<code class="docutils literal notranslate"><span class="pre">max_leaf_nodes</span></code>)를 6개로 했다. 다음으로 예측변수 최대 개수(<code class="docutils literal notranslate"><span class="pre">max_features</span></code>)를 3개로 정했는데, 이는 각 마디에서 이항 분할을 할 때, 예측변수를 최대 몇 개 사용하는지를 의미한다. 그런데 이 경우 주어진 예측변수 개수는 총 13개인데, 모든 이항 분할을 실행할 때, 이 중에서 최대 3개 변수만 사용하는 것이기 때문에 3개를 어떻게 고를지가 문제이다. 이 점에 있어서 <code class="docutils literal notranslate"><span class="pre">DecisionTreeClassifier()</span></code> 함수는 “무작위로” 고르는 방식을 취한다. 모든 분할 작업에서 매번 13개 변수 중에 3개를 무작위로 선택하는 것이다. 따라서 이런 경우(즉, 주어진 예측변수 개수보다 <code class="docutils literal notranslate"><span class="pre">max_features</span></code>를 작게 설정하는 경우), <strong>트리 피팅을 실행할 때마다 결과가 달라질 가능성</strong>이 크다. 이것을 원하지 않는다면, <code class="docutils literal notranslate"><span class="pre">DecisionTreeClassifier()</span></code> 함수 파라미터 중 <code class="docutils literal notranslate"><span class="pre">random_state</span></code>에 임의의 정수를 부여해놓으면, 다음 번에 실행할 때도 동일한 결과를 얻는다(아래 예에서는 “123”이라는 숫자를 부여함).</p>
<p>이렇게 설정한 모델을 <code class="docutils literal notranslate"><span class="pre">fit()</span></code> 메서드를 사용해 데이터(<code class="docutils literal notranslate"><span class="pre">X2</span></code>, <code class="docutils literal notranslate"><span class="pre">y2</span></code>)에 피팅시킨다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">clf</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                             <span class="n">max_leaf_nodes</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> 
                             <span class="n">max_features</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                             <span class="n">random_state</span><span class="o">=</span><span class="mi">123</span><span class="p">)</span>
<span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><style>#sk-container-id-4 {
  /* Definition of color scheme common for light and dark mode */
  --sklearn-color-text: black;
  --sklearn-color-line: gray;
  /* Definition of color scheme for unfitted estimators */
  --sklearn-color-unfitted-level-0: #fff5e6;
  --sklearn-color-unfitted-level-1: #f6e4d2;
  --sklearn-color-unfitted-level-2: #ffe0b3;
  --sklearn-color-unfitted-level-3: chocolate;
  /* Definition of color scheme for fitted estimators */
  --sklearn-color-fitted-level-0: #f0f8ff;
  --sklearn-color-fitted-level-1: #d4ebff;
  --sklearn-color-fitted-level-2: #b3dbfd;
  --sklearn-color-fitted-level-3: cornflowerblue;

  /* Specific color for light theme */
  --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
  --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, white)));
  --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
  --sklearn-color-icon: #696969;

  @media (prefers-color-scheme: dark) {
    /* Redefinition of color scheme for dark theme */
    --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
    --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, #111)));
    --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
    --sklearn-color-icon: #878787;
  }
}

#sk-container-id-4 {
  color: var(--sklearn-color-text);
}

#sk-container-id-4 pre {
  padding: 0;
}

#sk-container-id-4 input.sk-hidden--visually {
  border: 0;
  clip: rect(1px 1px 1px 1px);
  clip: rect(1px, 1px, 1px, 1px);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}

#sk-container-id-4 div.sk-dashed-wrapped {
  border: 1px dashed var(--sklearn-color-line);
  margin: 0 0.4em 0.5em 0.4em;
  box-sizing: border-box;
  padding-bottom: 0.4em;
  background-color: var(--sklearn-color-background);
}

#sk-container-id-4 div.sk-container {
  /* jupyter's `normalize.less` sets `[hidden] { display: none; }`
     but bootstrap.min.css set `[hidden] { display: none !important; }`
     so we also need the `!important` here to be able to override the
     default hidden behavior on the sphinx rendered scikit-learn.org.
     See: https://github.com/scikit-learn/scikit-learn/issues/21755 */
  display: inline-block !important;
  position: relative;
}

#sk-container-id-4 div.sk-text-repr-fallback {
  display: none;
}

div.sk-parallel-item,
div.sk-serial,
div.sk-item {
  /* draw centered vertical line to link estimators */
  background-image: linear-gradient(var(--sklearn-color-text-on-default-background), var(--sklearn-color-text-on-default-background));
  background-size: 2px 100%;
  background-repeat: no-repeat;
  background-position: center center;
}

/* Parallel-specific style estimator block */

#sk-container-id-4 div.sk-parallel-item::after {
  content: "";
  width: 100%;
  border-bottom: 2px solid var(--sklearn-color-text-on-default-background);
  flex-grow: 1;
}

#sk-container-id-4 div.sk-parallel {
  display: flex;
  align-items: stretch;
  justify-content: center;
  background-color: var(--sklearn-color-background);
  position: relative;
}

#sk-container-id-4 div.sk-parallel-item {
  display: flex;
  flex-direction: column;
}

#sk-container-id-4 div.sk-parallel-item:first-child::after {
  align-self: flex-end;
  width: 50%;
}

#sk-container-id-4 div.sk-parallel-item:last-child::after {
  align-self: flex-start;
  width: 50%;
}

#sk-container-id-4 div.sk-parallel-item:only-child::after {
  width: 0;
}

/* Serial-specific style estimator block */

#sk-container-id-4 div.sk-serial {
  display: flex;
  flex-direction: column;
  align-items: center;
  background-color: var(--sklearn-color-background);
  padding-right: 1em;
  padding-left: 1em;
}


/* Toggleable style: style used for estimator/Pipeline/ColumnTransformer box that is
clickable and can be expanded/collapsed.
- Pipeline and ColumnTransformer use this feature and define the default style
- Estimators will overwrite some part of the style using the `sk-estimator` class
*/

/* Pipeline and ColumnTransformer style (default) */

#sk-container-id-4 div.sk-toggleable {
  /* Default theme specific background. It is overwritten whether we have a
  specific estimator or a Pipeline/ColumnTransformer */
  background-color: var(--sklearn-color-background);
}

/* Toggleable label */
#sk-container-id-4 label.sk-toggleable__label {
  cursor: pointer;
  display: block;
  width: 100%;
  margin-bottom: 0;
  padding: 0.5em;
  box-sizing: border-box;
  text-align: center;
}

#sk-container-id-4 label.sk-toggleable__label-arrow:before {
  /* Arrow on the left of the label */
  content: "▸";
  float: left;
  margin-right: 0.25em;
  color: var(--sklearn-color-icon);
}

#sk-container-id-4 label.sk-toggleable__label-arrow:hover:before {
  color: var(--sklearn-color-text);
}

/* Toggleable content - dropdown */

#sk-container-id-4 div.sk-toggleable__content {
  max-height: 0;
  max-width: 0;
  overflow: hidden;
  text-align: left;
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-4 div.sk-toggleable__content.fitted {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

#sk-container-id-4 div.sk-toggleable__content pre {
  margin: 0.2em;
  border-radius: 0.25em;
  color: var(--sklearn-color-text);
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-4 div.sk-toggleable__content.fitted pre {
  /* unfitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

#sk-container-id-4 input.sk-toggleable__control:checked~div.sk-toggleable__content {
  /* Expand drop-down */
  max-height: 200px;
  max-width: 100%;
  overflow: auto;
}

#sk-container-id-4 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {
  content: "▾";
}

/* Pipeline/ColumnTransformer-specific style */

#sk-container-id-4 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-4 div.sk-label.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Estimator-specific style */

/* Colorize estimator box */
#sk-container-id-4 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-4 div.sk-estimator.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-2);
}

#sk-container-id-4 div.sk-label label.sk-toggleable__label,
#sk-container-id-4 div.sk-label label {
  /* The background is the default theme color */
  color: var(--sklearn-color-text-on-default-background);
}

/* On hover, darken the color of the background */
#sk-container-id-4 div.sk-label:hover label.sk-toggleable__label {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-unfitted-level-2);
}

/* Label box, darken color on hover, fitted */
#sk-container-id-4 div.sk-label.fitted:hover label.sk-toggleable__label.fitted {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Estimator label */

#sk-container-id-4 div.sk-label label {
  font-family: monospace;
  font-weight: bold;
  display: inline-block;
  line-height: 1.2em;
}

#sk-container-id-4 div.sk-label-container {
  text-align: center;
}

/* Estimator-specific */
#sk-container-id-4 div.sk-estimator {
  font-family: monospace;
  border: 1px dotted var(--sklearn-color-border-box);
  border-radius: 0.25em;
  box-sizing: border-box;
  margin-bottom: 0.5em;
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-4 div.sk-estimator.fitted {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

/* on hover */
#sk-container-id-4 div.sk-estimator:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-4 div.sk-estimator.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Specification for estimator info (e.g. "i" and "?") */

/* Common style for "i" and "?" */

.sk-estimator-doc-link,
a:link.sk-estimator-doc-link,
a:visited.sk-estimator-doc-link {
  float: right;
  font-size: smaller;
  line-height: 1em;
  font-family: monospace;
  background-color: var(--sklearn-color-background);
  border-radius: 1em;
  height: 1em;
  width: 1em;
  text-decoration: none !important;
  margin-left: 1ex;
  /* unfitted */
  border: var(--sklearn-color-unfitted-level-1) 1pt solid;
  color: var(--sklearn-color-unfitted-level-1);
}

.sk-estimator-doc-link.fitted,
a:link.sk-estimator-doc-link.fitted,
a:visited.sk-estimator-doc-link.fitted {
  /* fitted */
  border: var(--sklearn-color-fitted-level-1) 1pt solid;
  color: var(--sklearn-color-fitted-level-1);
}

/* On hover */
div.sk-estimator:hover .sk-estimator-doc-link:hover,
.sk-estimator-doc-link:hover,
div.sk-label-container:hover .sk-estimator-doc-link:hover,
.sk-estimator-doc-link:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

div.sk-estimator.fitted:hover .sk-estimator-doc-link.fitted:hover,
.sk-estimator-doc-link.fitted:hover,
div.sk-label-container:hover .sk-estimator-doc-link.fitted:hover,
.sk-estimator-doc-link.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

/* Span, style for the box shown on hovering the info icon */
.sk-estimator-doc-link span {
  display: none;
  z-index: 9999;
  position: relative;
  font-weight: normal;
  right: .2ex;
  padding: .5ex;
  margin: .5ex;
  width: min-content;
  min-width: 20ex;
  max-width: 50ex;
  color: var(--sklearn-color-text);
  box-shadow: 2pt 2pt 4pt #999;
  /* unfitted */
  background: var(--sklearn-color-unfitted-level-0);
  border: .5pt solid var(--sklearn-color-unfitted-level-3);
}

.sk-estimator-doc-link.fitted span {
  /* fitted */
  background: var(--sklearn-color-fitted-level-0);
  border: var(--sklearn-color-fitted-level-3);
}

.sk-estimator-doc-link:hover span {
  display: block;
}

/* "?"-specific style due to the `<a>` HTML tag */

#sk-container-id-4 a.estimator_doc_link {
  float: right;
  font-size: 1rem;
  line-height: 1em;
  font-family: monospace;
  background-color: var(--sklearn-color-background);
  border-radius: 1rem;
  height: 1rem;
  width: 1rem;
  text-decoration: none;
  /* unfitted */
  color: var(--sklearn-color-unfitted-level-1);
  border: var(--sklearn-color-unfitted-level-1) 1pt solid;
}

#sk-container-id-4 a.estimator_doc_link.fitted {
  /* fitted */
  border: var(--sklearn-color-fitted-level-1) 1pt solid;
  color: var(--sklearn-color-fitted-level-1);
}

/* On hover */
#sk-container-id-4 a.estimator_doc_link:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

#sk-container-id-4 a.estimator_doc_link.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-3);
}
</style><div id="sk-container-id-4" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>DecisionTreeClassifier(max_features=3, max_leaf_nodes=6, random_state=123)</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item"><div class="sk-estimator fitted sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-4" type="checkbox" checked><label for="sk-estimator-id-4" class="sk-toggleable__label fitted sk-toggleable__label-arrow fitted">&nbsp;&nbsp;DecisionTreeClassifier<a class="sk-estimator-doc-link fitted" rel="noreferrer" target="_blank" href="https://scikit-learn.org/1.5/modules/generated/sklearn.tree.DecisionTreeClassifier.html">?<span>Documentation for DecisionTreeClassifier</span></a><span class="sk-estimator-doc-link fitted">i<span>Fitted</span></span></label><div class="sk-toggleable__content fitted"><pre>DecisionTreeClassifier(max_features=3, max_leaf_nodes=6, random_state=123)</pre></div> </div></div></div></div></div></div>
</div>
<p><strong>트리 결과</strong></p>
<p>사이킷런 <code class="docutils literal notranslate"><span class="pre">tree</span></code> 모듈의 <code class="docutils literal notranslate"><span class="pre">plot_tree()</span></code> 함수를 사용해 트리 결과를 그림으로 그린 것이 아래 나와 있다. 우리가 모델에서 설정한 대로 끝마디 개수가 6개인 것을 확인할 수 있다.</p>
<p><img alt="트리 생성 오류" src="https://raw.githubusercontent.com/pilsunchoi/images/main/12-15.png" /></p>
</section>
<section id="chatgpt-q-a">
<h3>ChatGPT Q&amp;A<a class="headerlink" href="#chatgpt-q-a" title="Link to this heading">#</a></h3>
<blockquote>
<div><p><strong>아래 명령을 실행했더니 오류가 발생했다??</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>fig = plt.figure(figsize=(10,6), dpi=500)  
ax = tree.plot_tree(clf,  
              feature_names=X2.columns,  
              class_names=[&#39;No&#39;, &#39;Yes&#39;],  
              filled=True,  
              fontsize=9)  
</pre></div>
</div>
<p><strong>오류 내용</strong></p>
<p>InvalidParameterError: The ‘feature_names’ parameter of plot_tree must be an instance of ‘list’ or None. Got Index([‘Age’, ‘Sex’, ‘ChestPain’, ‘RestBP’, ‘Chol’, ‘Fbs’, ‘RestECG’, ‘MaxHR’,
‘ExAng’, ‘Oldpeak’, ‘Slope’, ‘Ca’, ‘Thal’],
dtype=’object’) instead.</p>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">plot_tree</span></code> 함수에서 발생한 오류는 <code class="docutils literal notranslate"><span class="pre">feature_names</span></code> 매개변수에 전달된 <code class="docutils literal notranslate"><span class="pre">X2.columns</span></code>가 <code class="docutils literal notranslate"><span class="pre">list</span></code> 형태가 아니라 <code class="docutils literal notranslate"><span class="pre">pandas</span></code>의 <code class="docutils literal notranslate"><span class="pre">Index</span></code> 객체이기 때문에 발생했습니다. <code class="docutils literal notranslate"><span class="pre">plot_tree</span></code> 함수는 <code class="docutils literal notranslate"><span class="pre">feature_names</span></code>로 <code class="docutils literal notranslate"><span class="pre">list</span></code> 형식의 입력을 요구합니다. 따라서, <code class="docutils literal notranslate"><span class="pre">X2.columns</span></code>를 <code class="docutils literal notranslate"><span class="pre">list</span></code>로 변환해주어야 합니다.</p>
<p>아래 코드는 <code class="docutils literal notranslate"><span class="pre">X2.columns</span></code>를 <code class="docutils literal notranslate"><span class="pre">list</span></code>로 변환하여 <code class="docutils literal notranslate"><span class="pre">feature_names</span></code> 매개변수에 제대로 전달하는 방법을 보여줍니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>fig = plt.figure(figsize=(10,6), dpi=500)  
ax = tree.plot_tree(clf,  
              feature_names=list(X2.columns),  
              class_names=[&#39;No&#39;, &#39;Yes&#39;],  
              filled=True,  
              fontsize=9)
</pre></div>
</div>
<p>이렇게 <code class="docutils literal notranslate"><span class="pre">list(X2.columns)</span></code>를 사용하여 <code class="docutils literal notranslate"><span class="pre">Index</span></code> 객체를 <code class="docutils literal notranslate"><span class="pre">list</span></code>로 변환함으로써, <code class="docutils literal notranslate"><span class="pre">plot_tree</span></code> 함수의 <code class="docutils literal notranslate"><span class="pre">feature_names</span></code> 매개변수로 올바른 형태의 입력을 제공할 수 있습니다.</p>
</div></blockquote>
<p><strong>ChatGPT가 제시한 코드 실행</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">plot_tree</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span>
                   <span class="n">feature_names</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">X2</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span>
                   <span class="n">class_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;No&#39;</span><span class="p">,</span> <span class="s1">&#39;Yes&#39;</span><span class="p">],</span>
                   <span class="n">filled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">fontsize</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="carseats">
<h3>분류 트리: Carseats 데이터세트<a class="headerlink" href="#carseats" title="Link to this heading">#</a></h3>
<p>이번에는 <code class="docutils literal notranslate"><span class="pre">Carseats</span></code> 데이터를 사용해 다시 한 번 분류 트리를 만들어 보자. 이것은 어느 어린이용 카시트 판매회사의 400개 매장별 판매량과 관련된 데이터세트이다.</p>
<p><strong>데이터 로딩</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Carseats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;../Data/Carseats.csv&#39;</span><span class="p">)</span>
<span class="n">Carseats</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Sales</th>
      <th>CompPrice</th>
      <th>Income</th>
      <th>Advertising</th>
      <th>Population</th>
      <th>Price</th>
      <th>ShelveLoc</th>
      <th>Age</th>
      <th>Education</th>
      <th>Urban</th>
      <th>US</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>9.50</td>
      <td>138</td>
      <td>73</td>
      <td>11</td>
      <td>276</td>
      <td>120</td>
      <td>Bad</td>
      <td>42</td>
      <td>17</td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
    <tr>
      <th>1</th>
      <td>11.22</td>
      <td>111</td>
      <td>48</td>
      <td>16</td>
      <td>260</td>
      <td>83</td>
      <td>Good</td>
      <td>65</td>
      <td>10</td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10.06</td>
      <td>113</td>
      <td>35</td>
      <td>10</td>
      <td>269</td>
      <td>80</td>
      <td>Medium</td>
      <td>59</td>
      <td>12</td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
    <tr>
      <th>3</th>
      <td>7.40</td>
      <td>117</td>
      <td>100</td>
      <td>4</td>
      <td>466</td>
      <td>97</td>
      <td>Medium</td>
      <td>55</td>
      <td>14</td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4.15</td>
      <td>141</td>
      <td>64</td>
      <td>3</td>
      <td>340</td>
      <td>128</td>
      <td>Bad</td>
      <td>38</td>
      <td>13</td>
      <td>Yes</td>
      <td>No</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>395</th>
      <td>12.57</td>
      <td>138</td>
      <td>108</td>
      <td>17</td>
      <td>203</td>
      <td>128</td>
      <td>Good</td>
      <td>33</td>
      <td>14</td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
    <tr>
      <th>396</th>
      <td>6.14</td>
      <td>139</td>
      <td>23</td>
      <td>3</td>
      <td>37</td>
      <td>120</td>
      <td>Medium</td>
      <td>55</td>
      <td>11</td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <th>397</th>
      <td>7.41</td>
      <td>162</td>
      <td>26</td>
      <td>12</td>
      <td>368</td>
      <td>159</td>
      <td>Medium</td>
      <td>40</td>
      <td>18</td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
    <tr>
      <th>398</th>
      <td>5.94</td>
      <td>100</td>
      <td>79</td>
      <td>7</td>
      <td>284</td>
      <td>95</td>
      <td>Bad</td>
      <td>50</td>
      <td>12</td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
    <tr>
      <th>399</th>
      <td>9.71</td>
      <td>134</td>
      <td>37</td>
      <td>0</td>
      <td>27</td>
      <td>120</td>
      <td>Good</td>
      <td>49</td>
      <td>16</td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
  </tbody>
</table>
<p>400 rows × 11 columns</p>
</div></div></div>
</div>
<p><strong>변수 설명</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Sales</span></code>: 매장의 판매량(단위: 천 개)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CompPrice</span></code>: 매장에서 경쟁사가 부과하는 가격</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Income</span></code>: 지역 소득 수준(천 달러)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Advertising</span></code>: 매장의 광고 예산(천 달러)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Population</span></code>: 지역의 인구 규모(천 명)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Price</span></code>: 매장이 부과하는 카시트 가격</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ShelveLoc</span></code>: 매장에서 카시트가 전시되는 매장 내 공간을 <code class="docutils literal notranslate"><span class="pre">Bad</span></code>, <code class="docutils literal notranslate"><span class="pre">Medium</span></code>, <code class="docutils literal notranslate"><span class="pre">Good</span></code>의 세 가지 등급으로 평가</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Age</span></code>: 지역 인구의 평균 연령</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Education</span></code>: 지역의 교육 수준</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Urban</span></code>: 매장이 도시에 있는지를 <code class="docutils literal notranslate"><span class="pre">Yes</span></code>와 <code class="docutils literal notranslate"><span class="pre">No</span></code>로 표시</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">US</span></code>: 매장이 미국내에 있는지를 <code class="docutils literal notranslate"><span class="pre">Yes</span></code>와 <code class="docutils literal notranslate"><span class="pre">No</span></code>로 표시</p></li>
</ul>
<p><strong><code class="docutils literal notranslate"><span class="pre">Sales</span></code> 변수를 이항 변수로 전환</strong></p>
<p>트리를 사용해 카시트 판매량(<code class="docutils literal notranslate"><span class="pre">Sales</span></code>)을 결정하는 요인을 분석하려고 한다. 회귀 트리가 아니라 분류 트리 만드는 것을 연습해보기 위해 정량적 변수인 <code class="docutils literal notranslate"><span class="pre">Sales</span></code>를 이항 변수(bianry variable)로 인코딩한다. <code class="docutils literal notranslate"><span class="pre">map</span></code> 메서드와 <code class="docutils literal notranslate"><span class="pre">lambda</span></code> 함수를 사용하여 <code class="docutils literal notranslate"><span class="pre">High</span></code>라는 이름의 범주형 변수를 생성한다. 이 변수는 <code class="docutils literal notranslate"><span class="pre">Sales</span></code>가 8을 초과하면 1의 값을 갖고, 그렇지 않으면 0인 더미변수이다.</p>
<p>한편, <code class="docutils literal notranslate"><span class="pre">ShelveLoc</span></code> 변수의 경우, 매장에서 카시트가 전시되는 매장 내 공간을 <code class="docutils literal notranslate"><span class="pre">Bad</span></code>, <code class="docutils literal notranslate"><span class="pre">Medium</span></code>, <code class="docutils literal notranslate"><span class="pre">Good</span></code>의 세 가지 범주로 구분한 것으로서 이것 역시 문자형 범주를 숫자형으로 바꿔야 한다. 이를 위해 <code class="docutils literal notranslate"><span class="pre">pd.factorize()</span></code> 함수를 사용했다. 이와 함께, <code class="docutils literal notranslate"><span class="pre">Urban</span></code>과 <code class="docutils literal notranslate"><span class="pre">US</span></code> 변수 역시 각각 <code class="docutils literal notranslate"><span class="pre">map</span></code> 메서드를 사용해서 <code class="docutils literal notranslate"><span class="pre">Yes</span></code>는 1, <code class="docutils literal notranslate"><span class="pre">No</span></code>는 0의 값을 갖는 더미변수로 만들었다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Carseats</span><span class="p">[</span><span class="s1">&#39;High&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Carseats</span><span class="o">.</span><span class="n">Sales</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">8</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">Carseats</span><span class="o">.</span><span class="n">ShelveLoc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">Carseats</span><span class="o">.</span><span class="n">ShelveLoc</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">Carseats</span><span class="o">.</span><span class="n">Urban</span> <span class="o">=</span> <span class="n">Carseats</span><span class="o">.</span><span class="n">Urban</span><span class="o">.</span><span class="n">map</span><span class="p">({</span><span class="s1">&#39;No&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Yes&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">})</span>
<span class="n">Carseats</span><span class="o">.</span><span class="n">US</span> <span class="o">=</span> <span class="n">Carseats</span><span class="o">.</span><span class="n">US</span><span class="o">.</span><span class="n">map</span><span class="p">({</span><span class="s1">&#39;No&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Yes&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">})</span>

<span class="n">Carseats</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Sales</th>
      <th>CompPrice</th>
      <th>Income</th>
      <th>Advertising</th>
      <th>Population</th>
      <th>Price</th>
      <th>ShelveLoc</th>
      <th>Age</th>
      <th>Education</th>
      <th>Urban</th>
      <th>US</th>
      <th>High</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>9.50</td>
      <td>138</td>
      <td>73</td>
      <td>11</td>
      <td>276</td>
      <td>120</td>
      <td>0</td>
      <td>42</td>
      <td>17</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>11.22</td>
      <td>111</td>
      <td>48</td>
      <td>16</td>
      <td>260</td>
      <td>83</td>
      <td>1</td>
      <td>65</td>
      <td>10</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10.06</td>
      <td>113</td>
      <td>35</td>
      <td>10</td>
      <td>269</td>
      <td>80</td>
      <td>2</td>
      <td>59</td>
      <td>12</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>7.40</td>
      <td>117</td>
      <td>100</td>
      <td>4</td>
      <td>466</td>
      <td>97</td>
      <td>2</td>
      <td>55</td>
      <td>14</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4.15</td>
      <td>141</td>
      <td>64</td>
      <td>3</td>
      <td>340</td>
      <td>128</td>
      <td>0</td>
      <td>38</td>
      <td>13</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p><strong>예측변수 및 반응변수</strong></p>
<p>데이터세트에서 판매량이 많고 적음을 의미하는 <code class="docutils literal notranslate"><span class="pre">High</span></code>를 반응변수 <code class="docutils literal notranslate"><span class="pre">y</span></code>로 지정하고, 이것을 제외한 나머지 총 10개를 예측변수 <code class="docutils literal notranslate"><span class="pre">X</span></code>로 지정한다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">Carseats</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;Sales&#39;</span><span class="p">,</span> <span class="s1">&#39;High&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Carseats</span><span class="o">.</span><span class="n">High</span>
</pre></div>
</div>
</div>
</div>
<p><strong>모델 및 피팅</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">DecisionTreeClassifier()</span></code> 함수를 사용해 분류 트리 모형을 설정한다. 여기에서는 트리의 최대 깊이(<code class="docutils literal notranslate"><span class="pre">max_depth</span></code>)를 6으로 제한했다. 트리의 “깊이”란 뿌리마디 아래로 몇 단계까지 마디가 성장하는지를 의미한다.</p>
<p>한편, 아래 명령문에서 <code class="docutils literal notranslate"><span class="pre">random_state</span></code>를 설정한 이유는 트리를 만들 때 무작위성(randomness)이 개입될 수 있기 때문이다. 우리는 바로 위 <code class="docutils literal notranslate"><span class="pre">Heart</span></code> 데이터세트 예에서 예측변수 최대 개수(<code class="docutils literal notranslate"><span class="pre">max_features</span></code>)와 관련하여 무작위성이 개입되기 때문에 다음 번에 실행할 때도 동일한 결과를 얻기 위해서는 <code class="docutils literal notranslate"><span class="pre">random_state</span></code>에 임의의 정수를 부여해야 한다는 것을 알았다. 그런데 아래의 분류 트리 모델에서 <code class="docutils literal notranslate"><span class="pre">max_features</span></code>를 따로 지정하지 않았는데도 <code class="docutils literal notranslate"><span class="pre">random_state</span></code>를 둔 이유는 또 다른 무작위성이 발생할 수 있기 때문이다. 즉 이항 분할을 할 때, 가령 지니 지수 값을 계산했는데, 어떤 두 가지 이상 선택지의 값이 정확히 동일한 경우가 발생할 수 있다. 이런 경우 <code class="docutils literal notranslate"><span class="pre">DecisionTreeClassifier()</span></code> 함수는 그 중 무작위로 하나를 고르게 된다. 이런 이유 때문에 트리 피팅을 실행할 때마다 결과가 달라질 수 있으며, 이런 상황을 원치 않으면 아래와 같이 <code class="docutils literal notranslate"><span class="pre">random_state</span></code>에 임의의 숫자를 부여해놓으면 된다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">clf</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
                             <span class="n">random_state</span><span class="o">=</span><span class="mi">123</span><span class="p">)</span>
<span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><style>#sk-container-id-5 {
  /* Definition of color scheme common for light and dark mode */
  --sklearn-color-text: black;
  --sklearn-color-line: gray;
  /* Definition of color scheme for unfitted estimators */
  --sklearn-color-unfitted-level-0: #fff5e6;
  --sklearn-color-unfitted-level-1: #f6e4d2;
  --sklearn-color-unfitted-level-2: #ffe0b3;
  --sklearn-color-unfitted-level-3: chocolate;
  /* Definition of color scheme for fitted estimators */
  --sklearn-color-fitted-level-0: #f0f8ff;
  --sklearn-color-fitted-level-1: #d4ebff;
  --sklearn-color-fitted-level-2: #b3dbfd;
  --sklearn-color-fitted-level-3: cornflowerblue;

  /* Specific color for light theme */
  --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
  --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, white)));
  --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
  --sklearn-color-icon: #696969;

  @media (prefers-color-scheme: dark) {
    /* Redefinition of color scheme for dark theme */
    --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
    --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, #111)));
    --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
    --sklearn-color-icon: #878787;
  }
}

#sk-container-id-5 {
  color: var(--sklearn-color-text);
}

#sk-container-id-5 pre {
  padding: 0;
}

#sk-container-id-5 input.sk-hidden--visually {
  border: 0;
  clip: rect(1px 1px 1px 1px);
  clip: rect(1px, 1px, 1px, 1px);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}

#sk-container-id-5 div.sk-dashed-wrapped {
  border: 1px dashed var(--sklearn-color-line);
  margin: 0 0.4em 0.5em 0.4em;
  box-sizing: border-box;
  padding-bottom: 0.4em;
  background-color: var(--sklearn-color-background);
}

#sk-container-id-5 div.sk-container {
  /* jupyter's `normalize.less` sets `[hidden] { display: none; }`
     but bootstrap.min.css set `[hidden] { display: none !important; }`
     so we also need the `!important` here to be able to override the
     default hidden behavior on the sphinx rendered scikit-learn.org.
     See: https://github.com/scikit-learn/scikit-learn/issues/21755 */
  display: inline-block !important;
  position: relative;
}

#sk-container-id-5 div.sk-text-repr-fallback {
  display: none;
}

div.sk-parallel-item,
div.sk-serial,
div.sk-item {
  /* draw centered vertical line to link estimators */
  background-image: linear-gradient(var(--sklearn-color-text-on-default-background), var(--sklearn-color-text-on-default-background));
  background-size: 2px 100%;
  background-repeat: no-repeat;
  background-position: center center;
}

/* Parallel-specific style estimator block */

#sk-container-id-5 div.sk-parallel-item::after {
  content: "";
  width: 100%;
  border-bottom: 2px solid var(--sklearn-color-text-on-default-background);
  flex-grow: 1;
}

#sk-container-id-5 div.sk-parallel {
  display: flex;
  align-items: stretch;
  justify-content: center;
  background-color: var(--sklearn-color-background);
  position: relative;
}

#sk-container-id-5 div.sk-parallel-item {
  display: flex;
  flex-direction: column;
}

#sk-container-id-5 div.sk-parallel-item:first-child::after {
  align-self: flex-end;
  width: 50%;
}

#sk-container-id-5 div.sk-parallel-item:last-child::after {
  align-self: flex-start;
  width: 50%;
}

#sk-container-id-5 div.sk-parallel-item:only-child::after {
  width: 0;
}

/* Serial-specific style estimator block */

#sk-container-id-5 div.sk-serial {
  display: flex;
  flex-direction: column;
  align-items: center;
  background-color: var(--sklearn-color-background);
  padding-right: 1em;
  padding-left: 1em;
}


/* Toggleable style: style used for estimator/Pipeline/ColumnTransformer box that is
clickable and can be expanded/collapsed.
- Pipeline and ColumnTransformer use this feature and define the default style
- Estimators will overwrite some part of the style using the `sk-estimator` class
*/

/* Pipeline and ColumnTransformer style (default) */

#sk-container-id-5 div.sk-toggleable {
  /* Default theme specific background. It is overwritten whether we have a
  specific estimator or a Pipeline/ColumnTransformer */
  background-color: var(--sklearn-color-background);
}

/* Toggleable label */
#sk-container-id-5 label.sk-toggleable__label {
  cursor: pointer;
  display: block;
  width: 100%;
  margin-bottom: 0;
  padding: 0.5em;
  box-sizing: border-box;
  text-align: center;
}

#sk-container-id-5 label.sk-toggleable__label-arrow:before {
  /* Arrow on the left of the label */
  content: "▸";
  float: left;
  margin-right: 0.25em;
  color: var(--sklearn-color-icon);
}

#sk-container-id-5 label.sk-toggleable__label-arrow:hover:before {
  color: var(--sklearn-color-text);
}

/* Toggleable content - dropdown */

#sk-container-id-5 div.sk-toggleable__content {
  max-height: 0;
  max-width: 0;
  overflow: hidden;
  text-align: left;
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-5 div.sk-toggleable__content.fitted {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

#sk-container-id-5 div.sk-toggleable__content pre {
  margin: 0.2em;
  border-radius: 0.25em;
  color: var(--sklearn-color-text);
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-5 div.sk-toggleable__content.fitted pre {
  /* unfitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

#sk-container-id-5 input.sk-toggleable__control:checked~div.sk-toggleable__content {
  /* Expand drop-down */
  max-height: 200px;
  max-width: 100%;
  overflow: auto;
}

#sk-container-id-5 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {
  content: "▾";
}

/* Pipeline/ColumnTransformer-specific style */

#sk-container-id-5 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-5 div.sk-label.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Estimator-specific style */

/* Colorize estimator box */
#sk-container-id-5 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-5 div.sk-estimator.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-2);
}

#sk-container-id-5 div.sk-label label.sk-toggleable__label,
#sk-container-id-5 div.sk-label label {
  /* The background is the default theme color */
  color: var(--sklearn-color-text-on-default-background);
}

/* On hover, darken the color of the background */
#sk-container-id-5 div.sk-label:hover label.sk-toggleable__label {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-unfitted-level-2);
}

/* Label box, darken color on hover, fitted */
#sk-container-id-5 div.sk-label.fitted:hover label.sk-toggleable__label.fitted {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Estimator label */

#sk-container-id-5 div.sk-label label {
  font-family: monospace;
  font-weight: bold;
  display: inline-block;
  line-height: 1.2em;
}

#sk-container-id-5 div.sk-label-container {
  text-align: center;
}

/* Estimator-specific */
#sk-container-id-5 div.sk-estimator {
  font-family: monospace;
  border: 1px dotted var(--sklearn-color-border-box);
  border-radius: 0.25em;
  box-sizing: border-box;
  margin-bottom: 0.5em;
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-5 div.sk-estimator.fitted {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

/* on hover */
#sk-container-id-5 div.sk-estimator:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-5 div.sk-estimator.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Specification for estimator info (e.g. "i" and "?") */

/* Common style for "i" and "?" */

.sk-estimator-doc-link,
a:link.sk-estimator-doc-link,
a:visited.sk-estimator-doc-link {
  float: right;
  font-size: smaller;
  line-height: 1em;
  font-family: monospace;
  background-color: var(--sklearn-color-background);
  border-radius: 1em;
  height: 1em;
  width: 1em;
  text-decoration: none !important;
  margin-left: 1ex;
  /* unfitted */
  border: var(--sklearn-color-unfitted-level-1) 1pt solid;
  color: var(--sklearn-color-unfitted-level-1);
}

.sk-estimator-doc-link.fitted,
a:link.sk-estimator-doc-link.fitted,
a:visited.sk-estimator-doc-link.fitted {
  /* fitted */
  border: var(--sklearn-color-fitted-level-1) 1pt solid;
  color: var(--sklearn-color-fitted-level-1);
}

/* On hover */
div.sk-estimator:hover .sk-estimator-doc-link:hover,
.sk-estimator-doc-link:hover,
div.sk-label-container:hover .sk-estimator-doc-link:hover,
.sk-estimator-doc-link:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

div.sk-estimator.fitted:hover .sk-estimator-doc-link.fitted:hover,
.sk-estimator-doc-link.fitted:hover,
div.sk-label-container:hover .sk-estimator-doc-link.fitted:hover,
.sk-estimator-doc-link.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

/* Span, style for the box shown on hovering the info icon */
.sk-estimator-doc-link span {
  display: none;
  z-index: 9999;
  position: relative;
  font-weight: normal;
  right: .2ex;
  padding: .5ex;
  margin: .5ex;
  width: min-content;
  min-width: 20ex;
  max-width: 50ex;
  color: var(--sklearn-color-text);
  box-shadow: 2pt 2pt 4pt #999;
  /* unfitted */
  background: var(--sklearn-color-unfitted-level-0);
  border: .5pt solid var(--sklearn-color-unfitted-level-3);
}

.sk-estimator-doc-link.fitted span {
  /* fitted */
  background: var(--sklearn-color-fitted-level-0);
  border: var(--sklearn-color-fitted-level-3);
}

.sk-estimator-doc-link:hover span {
  display: block;
}

/* "?"-specific style due to the `<a>` HTML tag */

#sk-container-id-5 a.estimator_doc_link {
  float: right;
  font-size: 1rem;
  line-height: 1em;
  font-family: monospace;
  background-color: var(--sklearn-color-background);
  border-radius: 1rem;
  height: 1rem;
  width: 1rem;
  text-decoration: none;
  /* unfitted */
  color: var(--sklearn-color-unfitted-level-1);
  border: var(--sklearn-color-unfitted-level-1) 1pt solid;
}

#sk-container-id-5 a.estimator_doc_link.fitted {
  /* fitted */
  border: var(--sklearn-color-fitted-level-1) 1pt solid;
  color: var(--sklearn-color-fitted-level-1);
}

/* On hover */
#sk-container-id-5 a.estimator_doc_link:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

#sk-container-id-5 a.estimator_doc_link.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-3);
}
</style><div id="sk-container-id-5" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>DecisionTreeClassifier(max_depth=6, random_state=123)</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item"><div class="sk-estimator fitted sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-5" type="checkbox" checked><label for="sk-estimator-id-5" class="sk-toggleable__label fitted sk-toggleable__label-arrow fitted">&nbsp;&nbsp;DecisionTreeClassifier<a class="sk-estimator-doc-link fitted" rel="noreferrer" target="_blank" href="https://scikit-learn.org/1.5/modules/generated/sklearn.tree.DecisionTreeClassifier.html">?<span>Documentation for DecisionTreeClassifier</span></a><span class="sk-estimator-doc-link fitted">i<span>Fitted</span></span></label><div class="sk-toggleable__content fitted"><pre>DecisionTreeClassifier(max_depth=6, random_state=123)</pre></div> </div></div></div></div></div></div>
</div>
<p><strong>트리 결과</strong></p>
<p>아래 트리 그림 결과를 보면, 앞에서 트리의 깊이가 6이라는 것이 무엇을 의미하는지 확인할 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">plot_tree</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span>
                   <span class="n">feature_names</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span>
                   <span class="n">class_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;No&#39;</span><span class="p">,</span> <span class="s1">&#39;Yes&#39;</span><span class="p">],</span>
                   <span class="n">filled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">fontsize</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>분류 성과</strong></p>
<p>혼동행렬(confusion matrix, 분류결과표)은 앞의 7장 “로지스틱 회귀를 이용한 분류”의 부록에서 설명했듯이 관측 중 얼마만큼이 정확하게 분류되었고, 얼마만큼이 잘못 분류되었는지를 표로 정리한 것이다. 사이킷런(<code class="docutils literal notranslate"><span class="pre">sklearn</span></code>)이 제공하는 <code class="docutils literal notranslate"><span class="pre">confusion_matrix()</span></code> 함수를 이용하여 혼동행렬을 만들 수 있다.</p>
<p>아래 결과에서 각 열(column)의 레이블이 “예측(Predicted)”에 해당하고 각 행(row)의 레이블이 “실제(True)” 관측에 해당한다. 혼동행렬에서 정확도는 전체 관측 중에서 올바르게 예측된 관측의 비율인데, 아래 결과를 보면 총 400개 관측 중 <span class="math notranslate nohighlight">\(3+30=33\)</span>개(8.3%)를 제외하고는 올바르게 예측됐다. 따라서 오분류율은 8.3%이고, 정확도는 91.7%이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="n">cm_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;No&#39;</span><span class="p">,</span> <span class="s1">&#39;Yes&#39;</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;No&#39;</span><span class="p">,</span> <span class="s1">&#39;Yes&#39;</span><span class="p">])</span>
<span class="n">cm_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;True&#39;</span>
<span class="n">cm_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Predicted&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cm_df</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Predicted   No  Yes
True               
No         233    3
Yes         30  134
</pre></div>
</div>
</div>
</div>
<p>한편, <code class="docutils literal notranslate"><span class="pre">classification_report()</span></code>을 이용하면 혼동행렬과 관련하여 정확도(<code class="docutils literal notranslate"><span class="pre">accuracy</span></code>) 등 여러 정보들을 얻을 수 있다. 아래 결과에서 정확도가 91.7%라는 것을 확인할 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">digits</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>              precision    recall  f1-score   support

           0      0.886     0.987     0.934       236
           1      0.978     0.817     0.890       164

    accuracy                          0.917       400
   macro avg      0.932     0.902     0.912       400
weighted avg      0.924     0.917     0.916       400
</pre></div>
</div>
</div>
</div>
</section>
<section id="id17">
<h3>가지치기<a class="headerlink" href="#id17" title="Link to this heading">#</a></h3>
<p>앞에서 트리의 크기를 줄이는 가지치기(pruning)에 대해 살펴 봤다. 일단 큰 트리를 만든 다음, 어떤 기준에 의해 트리의 가지들을 없애 크기를 줄이는 것이다. 대표적인 것이 소위 <strong>비용-복잡성 가지치기</strong>(cost-complexity pruning: “ccp”)로서 회귀 트리와 관련된 내용이 식 12.4에 나와 있다. 이 식에서 조정 파라미터 <span class="math notranslate nohighlight">\(\alpha\)</span>값을 적절히 선택해 가지치기를 수행하게 된다.(또는 교차검증을 통해 최적의 <span class="math notranslate nohighlight">\(\alpha\)</span>값을 선택한다.) 식 12.4는 회귀 트리에 대한 것이지만, 분류 트리도 사실상 이와 동일한 방식으로 비용-복잡성 가지치기를 한다.</p>
<p>분류 트리에 대해 가지치기를 수행하려면, <code class="docutils literal notranslate"><span class="pre">DecisionTreeClassifier()</span></code> 함수의 파라미터 <code class="docutils literal notranslate"><span class="pre">ccp_alpha</span></code>에 어떤 플러스 값을 지정해주기만 하면 된다. <code class="docutils literal notranslate"><span class="pre">ccp_alpha</span></code>는 식 12.4의 <span class="math notranslate nohighlight">\(\alpha\)</span>값에 해당하는 것으로 앞에서 설명했듯이 이 값이 0이면, 가지치기를 하지 않은 원래 트리가 생성된다. <code class="docutils literal notranslate"><span class="pre">DecisionTreeClassifier()</span></code> 함수에서 <code class="docutils literal notranslate"><span class="pre">ccp_alpha</span></code> 파라미터는 기본값이 0이기 때문에 이 값을 따로 지정하지 않는 한, 비용-복잡성 가지치기가 행해지지 않고 원래의 큰 트리가 생성된다. 여기에서는 앞에서 피팅한 원래의 트리(즉 <code class="docutils literal notranslate"><span class="pre">max_depth=6</span></code>)에 대해 <code class="docutils literal notranslate"><span class="pre">ccp_alpha=0.01</span></code>을 추가하여 가지치기를 실행했다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">clf</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
                             <span class="n">ccp_alpha</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                             <span class="n">random_state</span><span class="o">=</span><span class="mi">123</span><span class="p">)</span>
<span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><style>#sk-container-id-6 {
  /* Definition of color scheme common for light and dark mode */
  --sklearn-color-text: black;
  --sklearn-color-line: gray;
  /* Definition of color scheme for unfitted estimators */
  --sklearn-color-unfitted-level-0: #fff5e6;
  --sklearn-color-unfitted-level-1: #f6e4d2;
  --sklearn-color-unfitted-level-2: #ffe0b3;
  --sklearn-color-unfitted-level-3: chocolate;
  /* Definition of color scheme for fitted estimators */
  --sklearn-color-fitted-level-0: #f0f8ff;
  --sklearn-color-fitted-level-1: #d4ebff;
  --sklearn-color-fitted-level-2: #b3dbfd;
  --sklearn-color-fitted-level-3: cornflowerblue;

  /* Specific color for light theme */
  --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
  --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, white)));
  --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
  --sklearn-color-icon: #696969;

  @media (prefers-color-scheme: dark) {
    /* Redefinition of color scheme for dark theme */
    --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
    --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, #111)));
    --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
    --sklearn-color-icon: #878787;
  }
}

#sk-container-id-6 {
  color: var(--sklearn-color-text);
}

#sk-container-id-6 pre {
  padding: 0;
}

#sk-container-id-6 input.sk-hidden--visually {
  border: 0;
  clip: rect(1px 1px 1px 1px);
  clip: rect(1px, 1px, 1px, 1px);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}

#sk-container-id-6 div.sk-dashed-wrapped {
  border: 1px dashed var(--sklearn-color-line);
  margin: 0 0.4em 0.5em 0.4em;
  box-sizing: border-box;
  padding-bottom: 0.4em;
  background-color: var(--sklearn-color-background);
}

#sk-container-id-6 div.sk-container {
  /* jupyter's `normalize.less` sets `[hidden] { display: none; }`
     but bootstrap.min.css set `[hidden] { display: none !important; }`
     so we also need the `!important` here to be able to override the
     default hidden behavior on the sphinx rendered scikit-learn.org.
     See: https://github.com/scikit-learn/scikit-learn/issues/21755 */
  display: inline-block !important;
  position: relative;
}

#sk-container-id-6 div.sk-text-repr-fallback {
  display: none;
}

div.sk-parallel-item,
div.sk-serial,
div.sk-item {
  /* draw centered vertical line to link estimators */
  background-image: linear-gradient(var(--sklearn-color-text-on-default-background), var(--sklearn-color-text-on-default-background));
  background-size: 2px 100%;
  background-repeat: no-repeat;
  background-position: center center;
}

/* Parallel-specific style estimator block */

#sk-container-id-6 div.sk-parallel-item::after {
  content: "";
  width: 100%;
  border-bottom: 2px solid var(--sklearn-color-text-on-default-background);
  flex-grow: 1;
}

#sk-container-id-6 div.sk-parallel {
  display: flex;
  align-items: stretch;
  justify-content: center;
  background-color: var(--sklearn-color-background);
  position: relative;
}

#sk-container-id-6 div.sk-parallel-item {
  display: flex;
  flex-direction: column;
}

#sk-container-id-6 div.sk-parallel-item:first-child::after {
  align-self: flex-end;
  width: 50%;
}

#sk-container-id-6 div.sk-parallel-item:last-child::after {
  align-self: flex-start;
  width: 50%;
}

#sk-container-id-6 div.sk-parallel-item:only-child::after {
  width: 0;
}

/* Serial-specific style estimator block */

#sk-container-id-6 div.sk-serial {
  display: flex;
  flex-direction: column;
  align-items: center;
  background-color: var(--sklearn-color-background);
  padding-right: 1em;
  padding-left: 1em;
}


/* Toggleable style: style used for estimator/Pipeline/ColumnTransformer box that is
clickable and can be expanded/collapsed.
- Pipeline and ColumnTransformer use this feature and define the default style
- Estimators will overwrite some part of the style using the `sk-estimator` class
*/

/* Pipeline and ColumnTransformer style (default) */

#sk-container-id-6 div.sk-toggleable {
  /* Default theme specific background. It is overwritten whether we have a
  specific estimator or a Pipeline/ColumnTransformer */
  background-color: var(--sklearn-color-background);
}

/* Toggleable label */
#sk-container-id-6 label.sk-toggleable__label {
  cursor: pointer;
  display: block;
  width: 100%;
  margin-bottom: 0;
  padding: 0.5em;
  box-sizing: border-box;
  text-align: center;
}

#sk-container-id-6 label.sk-toggleable__label-arrow:before {
  /* Arrow on the left of the label */
  content: "▸";
  float: left;
  margin-right: 0.25em;
  color: var(--sklearn-color-icon);
}

#sk-container-id-6 label.sk-toggleable__label-arrow:hover:before {
  color: var(--sklearn-color-text);
}

/* Toggleable content - dropdown */

#sk-container-id-6 div.sk-toggleable__content {
  max-height: 0;
  max-width: 0;
  overflow: hidden;
  text-align: left;
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-6 div.sk-toggleable__content.fitted {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

#sk-container-id-6 div.sk-toggleable__content pre {
  margin: 0.2em;
  border-radius: 0.25em;
  color: var(--sklearn-color-text);
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-6 div.sk-toggleable__content.fitted pre {
  /* unfitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

#sk-container-id-6 input.sk-toggleable__control:checked~div.sk-toggleable__content {
  /* Expand drop-down */
  max-height: 200px;
  max-width: 100%;
  overflow: auto;
}

#sk-container-id-6 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {
  content: "▾";
}

/* Pipeline/ColumnTransformer-specific style */

#sk-container-id-6 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-6 div.sk-label.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Estimator-specific style */

/* Colorize estimator box */
#sk-container-id-6 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-6 div.sk-estimator.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-2);
}

#sk-container-id-6 div.sk-label label.sk-toggleable__label,
#sk-container-id-6 div.sk-label label {
  /* The background is the default theme color */
  color: var(--sklearn-color-text-on-default-background);
}

/* On hover, darken the color of the background */
#sk-container-id-6 div.sk-label:hover label.sk-toggleable__label {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-unfitted-level-2);
}

/* Label box, darken color on hover, fitted */
#sk-container-id-6 div.sk-label.fitted:hover label.sk-toggleable__label.fitted {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Estimator label */

#sk-container-id-6 div.sk-label label {
  font-family: monospace;
  font-weight: bold;
  display: inline-block;
  line-height: 1.2em;
}

#sk-container-id-6 div.sk-label-container {
  text-align: center;
}

/* Estimator-specific */
#sk-container-id-6 div.sk-estimator {
  font-family: monospace;
  border: 1px dotted var(--sklearn-color-border-box);
  border-radius: 0.25em;
  box-sizing: border-box;
  margin-bottom: 0.5em;
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-6 div.sk-estimator.fitted {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

/* on hover */
#sk-container-id-6 div.sk-estimator:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-6 div.sk-estimator.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Specification for estimator info (e.g. "i" and "?") */

/* Common style for "i" and "?" */

.sk-estimator-doc-link,
a:link.sk-estimator-doc-link,
a:visited.sk-estimator-doc-link {
  float: right;
  font-size: smaller;
  line-height: 1em;
  font-family: monospace;
  background-color: var(--sklearn-color-background);
  border-radius: 1em;
  height: 1em;
  width: 1em;
  text-decoration: none !important;
  margin-left: 1ex;
  /* unfitted */
  border: var(--sklearn-color-unfitted-level-1) 1pt solid;
  color: var(--sklearn-color-unfitted-level-1);
}

.sk-estimator-doc-link.fitted,
a:link.sk-estimator-doc-link.fitted,
a:visited.sk-estimator-doc-link.fitted {
  /* fitted */
  border: var(--sklearn-color-fitted-level-1) 1pt solid;
  color: var(--sklearn-color-fitted-level-1);
}

/* On hover */
div.sk-estimator:hover .sk-estimator-doc-link:hover,
.sk-estimator-doc-link:hover,
div.sk-label-container:hover .sk-estimator-doc-link:hover,
.sk-estimator-doc-link:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

div.sk-estimator.fitted:hover .sk-estimator-doc-link.fitted:hover,
.sk-estimator-doc-link.fitted:hover,
div.sk-label-container:hover .sk-estimator-doc-link.fitted:hover,
.sk-estimator-doc-link.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

/* Span, style for the box shown on hovering the info icon */
.sk-estimator-doc-link span {
  display: none;
  z-index: 9999;
  position: relative;
  font-weight: normal;
  right: .2ex;
  padding: .5ex;
  margin: .5ex;
  width: min-content;
  min-width: 20ex;
  max-width: 50ex;
  color: var(--sklearn-color-text);
  box-shadow: 2pt 2pt 4pt #999;
  /* unfitted */
  background: var(--sklearn-color-unfitted-level-0);
  border: .5pt solid var(--sklearn-color-unfitted-level-3);
}

.sk-estimator-doc-link.fitted span {
  /* fitted */
  background: var(--sklearn-color-fitted-level-0);
  border: var(--sklearn-color-fitted-level-3);
}

.sk-estimator-doc-link:hover span {
  display: block;
}

/* "?"-specific style due to the `<a>` HTML tag */

#sk-container-id-6 a.estimator_doc_link {
  float: right;
  font-size: 1rem;
  line-height: 1em;
  font-family: monospace;
  background-color: var(--sklearn-color-background);
  border-radius: 1rem;
  height: 1rem;
  width: 1rem;
  text-decoration: none;
  /* unfitted */
  color: var(--sklearn-color-unfitted-level-1);
  border: var(--sklearn-color-unfitted-level-1) 1pt solid;
}

#sk-container-id-6 a.estimator_doc_link.fitted {
  /* fitted */
  border: var(--sklearn-color-fitted-level-1) 1pt solid;
  color: var(--sklearn-color-fitted-level-1);
}

/* On hover */
#sk-container-id-6 a.estimator_doc_link:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

#sk-container-id-6 a.estimator_doc_link.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-3);
}
</style><div id="sk-container-id-6" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>DecisionTreeClassifier(ccp_alpha=0.01, max_depth=6, random_state=123)</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item"><div class="sk-estimator fitted sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-6" type="checkbox" checked><label for="sk-estimator-id-6" class="sk-toggleable__label fitted sk-toggleable__label-arrow fitted">&nbsp;&nbsp;DecisionTreeClassifier<a class="sk-estimator-doc-link fitted" rel="noreferrer" target="_blank" href="https://scikit-learn.org/1.5/modules/generated/sklearn.tree.DecisionTreeClassifier.html">?<span>Documentation for DecisionTreeClassifier</span></a><span class="sk-estimator-doc-link fitted">i<span>Fitted</span></span></label><div class="sk-toggleable__content fitted"><pre>DecisionTreeClassifier(ccp_alpha=0.01, max_depth=6, random_state=123)</pre></div> </div></div></div></div></div></div>
</div>
<p><strong>트리 결과(가지치기된 트리)</strong></p>
<p>아래의 가지치기된 트리 결과를 보면, 앞에서 본 원래의 큰 트리에 비해 크기가 대폭 축소된 것을 확인할 수 있을 것이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">plot_tree</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span>
                   <span class="n">feature_names</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span>
                   <span class="n">class_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;No&#39;</span><span class="p">,</span> <span class="s1">&#39;Yes&#39;</span><span class="p">],</span>
                   <span class="n">filled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">fontsize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>분류 성과(가지치기된 트리)</strong></p>
<p>가지치기를 실행한 트리에 대해 혼동행렬로 분류 성과를 평가한 결과가 아래 나와 있다. 앞의 가지치기 이전의 트리에 비해 정확도가 91.7%에서 86.0%로 크게 낮아진 것을 알 수 있다. 이와 같은 결과는 결코 놀라운 것이 아니다. 가지치기의 목표 자체가 데이터의 과적합을 막으려는 것이기 때문이다. 즉 모델이 훈련 세트에 대해서(만) 분류를 너무 잘하는 바람에 테스트 세트에 대한 분류 성과가 크게 떨어질 수 있는 것이 과적합 문제인 것이다. 따라서 가지치기에 의해 트리가 훨씬 단순해지면 훈련 세트에 대해서는 분류 성과가 떨어지는 것은 충분히 예상되는 일이다. 따라서 추정에 사용된 훈련 세트를 대상으로 가지치기의 성과를 비교해서는 안되고, 훈련 세트와 테스트 세트를 분리한 다음, 훈련 세트를 사용해 도출한 트리를 테스트 세트에 적용하는 방식으로 분류 성과를 비교할 필요가 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="n">cm_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;No&#39;</span><span class="p">,</span> <span class="s1">&#39;Yes&#39;</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;No&#39;</span><span class="p">,</span> <span class="s1">&#39;Yes&#39;</span><span class="p">])</span>
<span class="n">cm_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;True&#39;</span>
<span class="n">cm_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Predicted&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cm_df</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">digits</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Predicted   No  Yes
True               
No         220   16
Yes         40  124

              precision    recall  f1-score   support

           0      0.846     0.932     0.887       236
           1      0.886     0.756     0.816       164

    accuracy                          0.860       400
   macro avg      0.866     0.844     0.851       400
weighted avg      0.862     0.860     0.858       400
</pre></div>
</div>
</div>
</div>
</section>
<section id="id18">
<h3>가지치기 전후의 테스트 오류 비교<a class="headerlink" href="#id18" title="Link to this heading">#</a></h3>
<p><strong>데이터세트 분할</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">Carseats</span></code> 데이터세트를 임의로 절반씩 나누어 훈련 세트와 테스트 세트로 분할한다. <code class="docutils literal notranslate"><span class="pre">sklearn</span></code> <code class="docutils literal notranslate"><span class="pre">model_selection</span></code> 모듈의 <code class="docutils literal notranslate"><span class="pre">train_test_split()</span></code> 함수를 사용하면, 데이터세트 분리 작업을 간단히 수행할 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>기본 트리</strong></p>
<p>앞에서와 마찬가지로 트리의 최대 깊이(<code class="docutils literal notranslate"><span class="pre">max_depth</span></code>)가 6인 경우를 (가지치기 이전의) 기본 트리로 삼기로 한다. 훈련 세트(<code class="docutils literal notranslate"><span class="pre">X_train</span></code>, <code class="docutils literal notranslate"><span class="pre">y_train</span></code>)에 피팅한 결과를 테스트 세트(<code class="docutils literal notranslate"><span class="pre">X_test</span></code>)에 적용하여 예측 범주(<code class="docutils literal notranslate"><span class="pre">pred</span></code>)를 구했다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">clf</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
                             <span class="n">random_state</span><span class="o">=</span><span class="mi">123</span><span class="p">)</span>
<span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">pred</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>기본 트리의 테스트 오류</strong></p>
<p>테스트 세트에 대해 예측 범주(<code class="docutils literal notranslate"><span class="pre">pred</span></code>)와 실제 범주(<code class="docutils literal notranslate"><span class="pre">y_test</span></code>)를 비교하여 혼동행렬을 작성했다. 아래 결과를 보면, 가지치기 이전 원래의 큰 트리에 있어서 테스트 정확도는 74.5%이다. 즉 테스트 오분류율이 25.5%인 것이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
<span class="n">cm_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;No&#39;</span><span class="p">,</span> <span class="s1">&#39;Yes&#39;</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;No&#39;</span><span class="p">,</span> <span class="s1">&#39;Yes&#39;</span><span class="p">])</span>
<span class="n">cm_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;True&#39;</span>
<span class="n">cm_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Predicted&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cm_df</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">digits</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Predicted  No  Yes
True              
No         99   19
Yes        32   50

              precision    recall  f1-score   support

           0      0.756     0.839     0.795       118
           1      0.725     0.610     0.662        82

    accuracy                          0.745       200
   macro avg      0.740     0.724     0.729       200
weighted avg      0.743     0.745     0.741       200
</pre></div>
</div>
</div>
</div>
<p><strong>가지치기된 트리</strong></p>
<p>앞에서와 마찬가지로 비용-복잡성 가지치기의 <span class="math notranslate nohighlight">\(\alpha\)</span>값(<code class="docutils literal notranslate"><span class="pre">ccp_alpha</span></code>)을 0.01로 정하여 가지치기된 트리를 구했다. 그런 다음, 동일한 절차를 통해 테스트 관측에 대한 예측 범주(<code class="docutils literal notranslate"><span class="pre">pred</span></code>)를 구했다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">clf</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
                             <span class="n">ccp_alpha</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                             <span class="n">random_state</span><span class="o">=</span><span class="mi">123</span><span class="p">)</span>
<span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">pred</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>가지치기된 트리의 테스트 오류</strong></p>
<p>테스트 세트에 대해 예측 범주(<code class="docutils literal notranslate"><span class="pre">pred</span></code>)와 실제 범주(<code class="docutils literal notranslate"><span class="pre">y_test</span></code>)를 비교하여 혼동행렬을 작성했다. 아래 결과를 보면, 공교롭게도 가지치기된 트리의 테스트 정확도 역시 앞의 원래 큰 트리와 마찬가지로 74.5%이다. 우리는 앞에서 훈련 세트에 대해서는 가지치기된 트리의 정확도가 크게 낮아지는 것을 보았는데, 테스트 세트에 대해서는 정확도에 차이가 없게 나타난 것이다.</p>
<p>물론 <span class="math notranslate nohighlight">\(\alpha\)</span>값, 즉 <code class="docutils literal notranslate"><span class="pre">ccp_alpha</span></code> 파라미터 값을 어떻게 정하느냐에 따라, 그리고 어떤 테스트 세트를 사용하느냐에 따라 결과가 달라지겠지만, 어쨌든 여기서 한 가지 확인할 수 있는 것은 가지치기를 통해 트리의 크기를 대폭 줄였음에도 테스트 분류 성과는 별 차이가 없다는 점이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
<span class="n">cm_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;No&#39;</span><span class="p">,</span> <span class="s1">&#39;Yes&#39;</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;No&#39;</span><span class="p">,</span> <span class="s1">&#39;Yes&#39;</span><span class="p">])</span>
<span class="n">cm_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;True&#39;</span>
<span class="n">cm_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Predicted&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cm_df</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">digits</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Predicted  No  Yes
True              
No         97   21
Yes        30   52

              precision    recall  f1-score   support

           0      0.764     0.822     0.792       118
           1      0.712     0.634     0.671        82

    accuracy                          0.745       200
   macro avg      0.738     0.728     0.731       200
weighted avg      0.743     0.745     0.742       200
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./notebooks"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="11_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">11장 추천 시스템</p>
      </div>
    </a>
    <a class="right-next"
       href="13_%ED%8A%B8%EB%A6%AC_%EA%B8%B0%EB%B0%98_%EB%AA%A8%ED%98%95.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">13장 트리 기반 모형</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">12.1 결정 트리 소개</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">트리 기반 접근</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">12.2 회귀 트리 만들기</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">특성 공간의 계층화를 통한 예측</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">회귀 트리 만들기 간단한 예</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">회귀 트리 코딩</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">반복 이항 분할로 회귀 트리 만들기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tree-pruning">트리 가지치기(Tree Pruning)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">회귀 트리 예제</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">12.3 분류 트리 만들기</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">분류 트리 만들기 간단한 예</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">분류 트리 코딩</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">불순도 측정 도구</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">분류 트리 예제</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">트리의 장점과 단점</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">12.4 결정 트리 예제</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hitters">회귀 트리: Hitters 데이터세트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#heart">분류 트리: Heart 데이터세트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#chatgpt-q-a">ChatGPT Q&amp;A</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#carseats">분류 트리: Carseats 데이터세트</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">가지치기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">가지치기 전후의 테스트 오류 비교</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By 최필선 민인식
</p>

  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>